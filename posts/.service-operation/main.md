---
title: 2년 10개월간의 1인 서비스 운영기
category: development
---

저는 부동산 매물을 관리하는 작은 서비스를 운영하고 있습니다. 이 서비스는 어머니를 도와드리기 위해 만든 것으로, 공개되어있기는 하나 일단은 비즈니스로서 운영하지는 않고 있어서 아직까지도 저희 어머니 한 분께서만 사용하고 계십니다.

깃 로그를 확인해보니 개발을 시작한 것이 2020년 7월 12일로, 약 2년 10개월째 서비스를 운영하고 있습니다. 비록 작은 서비스이지만 이 서비스를 운영하며 배운 점이 많아 정리해두고자 합니다.

# 시작

어머니가 부동산 일을 하시게 된 것은 꽤 오래전입니다. 그때는 일을 시작한 지 얼마 되지도 않았고 매물도 많지 않아 단순히 종이로 된 표에 매물을 기록하셨습니다.

매물은 가면 갈수록 많아졌고 곧 종이로는 매물을 관리하게 어렵게 됐습니다. 아버지께서는 (컴퓨터를 전공하시지는 않으셨지만) Visual Basic을 사용하여 엑셀을 다룰 줄 아셨고, 간단한 CRUD 기능을 가진 프로그램을 어머니께 만들어주셨습니다.

이 프로그램은

- 매물과 고객을 생성, 검색, 편집, 삭제하는 기능을 가지고 있었습니다.
- 사진이 모아진 디렉토리에서 건물의 이름이 포함된 사진들을 가져와서 캐러셀 형태로 보여주는 기능도 있었습니다.
- 데이터베이스로 숨겨진 시트를 사용했습니다.
- 그래서 필요할 때면 데이터를 곧바로 표로 인쇄하여 사용할 수도 있었습니다.

물론 아버지가 프로그래밍을 깊게 공부하시지 않은 만큼 약간의 문제점은 있었습니다.

- 데이터베이스는 정규화되어있지 않았습니다.
- 건물과 고객은 실제로는 n:n 관계이지만 같은 시트에 관리되어서 오직 1:1 매칭만이 가능했습니다. 그래서 새 고객을 등록하려면 이전 고객 정보를 지워야 했습니다.
- 모든 코드가 한 개 파일에 모여있고 코드의 중복이 많아서 코드 길이는 1만 줄이 넘었습니다.

그럼에도 프로그램은 완벽하게 동작했고 어머니께서는 일하시기가 대단히 편해지셨습니다.

그러나 일을 계속할수록 필요한 기능은 계속 늘어났습니다. 프로그램은 갈수록 복잡해져서 더이상 새로운 기능을 추가하는 것이 불가능하게 되었습니다. 그래서 저는 이 프로그램을 다시 만들어보기로 했습니다.

# 도메인

먼저 개발에 앞서 도메인 지식을 얻어야 했습니다. 물론 그때는 클린 아키텍쳐나 도메인 주도 개발, 엔티티나 유즈케이스같은 개념들을 전혀 몰랐습니다. 그러나 나름의 경험상 도메인 지식과 유저의 상세한 요구사항 없이 프로그래머가 생각했던 대로 프로그램을 만들면 결국에는 전부 고쳐야 한다는 것은 알고 있었습니다. 그래서 저는 어머니를 모셔다 놓고 종이와 연필을 가지고 어떤 UI와 어떤 기능이 필요한지를 물어보았습니다.

이 과정에서 유저와 개발자의 차이, 그리고 유저와 소통하는 방법을 배울 수 있었습니다.

첫 번째로 중요한 것은 유저와 대화할 때는 과정이 아니라 결과로 이야기해야 한다는 것입니다. 어떤 기능이 내부적으로 어떻게 동작하는지는 유저는 이해할 수 없을 뿐더러 이해할 필요도 없습니다. 유저에게 중요한 것은 결과입니다.

예를 들어서 어머니께서는 프로그램이 로컬에서 돌아가는지 아니면 서버-클라이언트 형태인지, 그게 사용하는 데 있어 어떤 차이가 생기는지를 전혀 모르셨고, 스마트폰에서 웹 페이지 바로가기와 네이티브 앱의 차이 역시 알지 못하셨습니다. 하지만 웹 어플리케이션이나 네이티브 앱을 설명하는 대신 '이렇게 하면 인터넷이 연결되어야만 쓸 수 있고, 대신 컴퓨터랑 노트북에서 동기화가 자동으로 된다'라고 설명드렸습니다. 실제로는 서버-클라이언트 구조는 동기화와는 아무런 관계도 없습니다. 그러나 유저가 동작 방식을 완벽하게 이해했으므로 구체적인 작동 방식은 별로 중요하지 않았습니다.

다음으로 중요한 것은 유저는 어떤 것이 필요한지를 잘 모르며, 알고 있다고 하더라도 정확하게 설명하지 못하는 경우가 많다는 것입니다.

그리고 어떤 모순적인 개념을 원하거나 아니면 개념을 잘 설명하시지 못하는 경우도 많았습니다. 예를 들어서 건물들이 주소 순서로 나열되기를 바라지만 최근 수정한 건물 순으로 나열되면 좋겠다는 요구사항이 있었습니다. 그러나 주소와 수정 시간은 둘 다 고유한 값이므로 (다세대 주택의 예외가 있기는 하지만) 이 정렬 기준은 일반적으로 만족시킬 수가 없습니다. 그래서 유저 인터뷰를 더 진행해봤고, 그 결과 주소 순서로 나열되기를 바라는 이유가 지역별로 건물을 관리하기 위해서임을 알게 되었습니다. 즉, 주소가 아니라 지역(지번주소에서 동)을 기준으로 정렬하고 다음으로 정보 수정 시간을 기준으로 정렬하면 되는 것이었습니다. 다만 이후에 여러 정렬 기준이 필요해졌고, 결국 정렬 기준을 유저가 직접 선택할 수 있도록 했습니다.

물론 이것 말고도 일반적인 사람과 프로그래머의 관점의 차이로 인해 발생하는 문제는 정말 많았습니다. 기존 엑셀의 데이터를 마이그레이션하려고 보니 중복되는 데이터가 많았고 값들의 형식은 비일관적이었습니다. 특히 날짜는 연도가 생략되거나 불확실한 날짜를 \*로 표시하는 등 (2023-01-1\*처럼) 다양한 표기 방법이 있었습니다. 이 문제는 마땅히 해결가능한 방법이 없는데다 비일관적인 데이터가 많지 않아 그냥 수작업으로 처리했습니다. 다만 불확실한 날짜를 표기하는 방법은 비즈니스적인 의미가 있었기 때문에 그대로 유지했습니다. 그래서 이 부분의 날짜 데이터는 Datetime 대신 String 형식으로 저장되며 대신 형식을 지정하여 검사하도록 구현했습니다.

또한 유저에게 요구사항을 받을 때는 유저가 달성하려는 목적을 조사해야지, 기능을 조사하면 안 된다는 것도 알게 되었습니다. 요구사항 중에는 '평'과 '제곱미터'를 변환할 수 있는 계산기와 도로명주소와 지번주소를 변환할 수 있는 기능이 있었습니다. 탭을 하나 추가해서 이런 계산기나 변환기를 구현하는 건 간단한 작업입니다. 그러나 조금 더 생각해보자면 결국 유저가 원하는 건 변환기가 아니라 건물 정보를 볼 때 두 개 정보 중 하나로부터 다른 하나를 얻는 거였습니다. 그래서 건물 정보를 입력하는 칸에 도로명주소와 지번주소를 입력하는 칸을 둘 다 만들되, 아무 쪽에나 아무 주소를 입력하면 (예컨대 도로명주소 칸에 지번주소를 입력한다거나) 나중에 자동으로 적절히 변환된 값이 둘 다 입력되도록 구현했습니다. 평수 역시 평수 입력칸과 제곱미터 입력칸을 둘 다 만들고 한 쪽에 값을 입력하면 다른 쪽은 자동으로 채워지도록 구현했습니다.

# 개발

도메인을 습득한 후 서비스 개발을 시작했습니다. React와 Chakra UI를 사용하여 프론트엔드를 만들고 Koa를 사용하여 백엔드를 구축했습니다. 데이터베이스로는 Mongo Atlas를 이용했고 DB를 제외한 나머지 컴포넌트는 모두 제 개인 서버에 있는 쿠버네티스 클러스터 위에 올라갔습니다.

개발하면서 다양한 문제와 고민이 발생했습니다. 한 개 건물의 속성은 약 90개나 되었고 속성들은 대단히 자주 바뀌었고 UI 변경 역시 엄청나게 잦았습니다. 특히 처음에는 타입스크립트를 사용하지 않고 자바스크립트로 UI를 구성했으므로 개발은 빨랐지만 타입 검사가 이루어지 않아 발생하는 오류도 잦았습니다. 결국 나중에 소스코드 전체를 타입스크립트로 리팩토링했습니다. 한 달 정도 걸렸던 것으로 기억합니다.

아키텍처를 잘 설계하지 못해 발생하는 문제도 있었습니다. 서비스의 주요 UI는 건물이나 고객 정보를 입력/표시하는 Input Component인데, 그 변경을 을 쉽게 할 수 있도록 Input 컴포넌트에 적절한 attribute 이름을 집어넣으면 context에 있는 데이터 오브젝트의 필드를 수정할 수 있도록 구현했습니다. 이 구현은 UI 변경을 쉽게 만들어주었지만 프론트엔드 로직, Input Component, React Framework 세 가지를 대단히 강하게 결합했고 그래서 나중에 더 큰 규모의 변경이 정말로 어려워졌습니다. 결국 이 구조는 아키텍쳐상 문제가 있다는 것을 깨닫고 비즈니스 룰, 프레임워크, UI를 깔끔하게 분리하도록 완전히 다시 작성했습니다.

좋아보이는 기술을 무작정 도입했다가 낭패를 본 적도 있습니다. 전에 새로운 기술을 사용해보겠다고 무작정 GraphQL을 적용한 적이 있습니다. 도입할 때는 깔끔하고 세련된 기술이라고 생각했습니다. 그러나 작업하면서 데이터를 입맞에 맞게 가져오기에는 적절하지만 복잡한 필터를 적용하거나 데이터를 조작하기는 꽤 어렵고, N+1 문제가 생각보다 크게 작용하는데다 프론트에서 구조를 깔끔하게 가져가기가 힘들다는 걸 알게 됐습니다. 그래서 결국 REST API로 돌아갔습니다. 이 리팩토링을 수행하면서 GraphQL과 비즈니스 룰을 너무 강하게 결합했다는 것도 깨달았고, 이후에는 프론트에서도 repository를 구현해 구현과 추상을 분리해냈습니다.

복잡한 aggregation이 필요해서 얼떨결에 CQRS를 구현하기도 했습니다. 고객 리스트에서 대금 지불이 이루어지지 않은 고객을 상위에 노출시키는 작업이었는데, 이걸 구현하기 위해서는 각 고객이 가진 거래들 중 대금 지불이 이루어지지 않은 거래가 존재하는지를 알아낸 후 이 순서로 정렬을 수행해야 합니다. MongoDB에서 Aggregation은 RDB의 Join과 다르게 성능이 그렇게 좋지 않은데다 정렬까지 하게 되니 이 연산은 대단히 비효율적이게 되었습니다. 그래서 아예 Read를 위한 모델을 따로 만들었습니다. 이 모델은 고객 모델에 대금이 지불이 이루어지지 않은 거래들의 ID를 추가한 거였고 고객을 수정하거나 거래를 수정하면 이 모델을 수정하도록 구현했습니다. 이 경우 한 번에 한 명의 고객만을 수정하는데다 정렬도 하지 않으므로 시간복잡도는 늘어나지 않지만, 조회할 때는 인덱스를 사용할 수 있으므로 성능이 대폭 향상되었습니다. 이게 Read model을 분리한 일종의 CQRS라는 걸 나중에 알게 되었습니다.

개발 환경과 서버를 구축하는 것도 재밌는 과정이었습니다. 이 서비스는 프론트 서버, 백 서버, MongoDB와 레디스 4개의 컴포넌트가 있어야 정상 동작합니다. 그런데 로컬에서 개발 서버를 띄우자니 다른 포트와 충돌하는 경우가 잦았습니다. 포트를 바꾸는 건 어렵지 않지만 그럴 때마다 카카오 로그인 등을 위해 등록된 서버 정보를 새롭게 수정해줘야 했습니다. 이 문제는 추후에 개발한 [http-tunneling](https://github.com/unknownpgr/http-tunnelling) 툴을 활용하여 도메인으로 접근할 수 있도록 개발 서버를 구성해서 깔끔하게 해결했습니다.

# 배포

배포 역시 쉬운 일이 아니었습니다. 그나마 다행인 점은 리포지토리를 분리하기 귀찮았던 나머지 프론트와 백을 하나의 리포지토리에 몰아 넣고 개발했던 것입니다. 그게 모노레포라는 하나의 엄연한 방식이라는 것은 나중에 알게 되었습니다.

그럼에도 불구하고 배포 프로세스를 작성하는 것은 생각보다 어려웠습니다. 처음에는 ArgoCD, GitHub Actions 등 다양한 CI/CD 툴들을 사용해봤습니다. 그러나 ArgoCD를 사용하자니 이미지 빌드와 배포가 분리되어서 배포 프로세스가 복잡해졌고 GitHub Actions에서 모든 것을 처리하는 것은 나름 괜찮은 방법이었지만 너무 느렸고 시크릿 관리가 어려웠습니다.

무엇보다 큰 문제는 관리 포인트였습니다. 앞서 말한 방법들은 모두 완벽하게 동작했습니다. 그러나 문제는 이 프로젝트는 오직 저 혼자서 개발하는 프로젝트라는 거였습니다. 뭔가 변경 사항이 생기는 경우 관리 포인트가 많아질수록 관리하기가 어려워졌습니다. 예컨대 ECR, GitHub Actions, ArgoCD를 사용한다고 가정하면 서비스 하나를 추가하거나 이미지 이름을 변경하려면 소스코드를 포함하여 건드려야 할 부분이 네 가지나 됩니다.

그러면서 앞서 말한 멋진 CI/CD 스택들은 모두 많은 사람이 모여 개발하는 경우를 상정하여 설계된 것이고 소규모 프로젝트에서 저런 스택들을 도입하는 것은 그냥 겉멋에 불과하다는 걸 깨달았습니다. 그래서 빌드와 배포를 모두 간단한 쉘 스크립트를 도입해서 해결했습니다. 빌드는 로컬에서 docker buildx를 사용하여 수행되며, 이미지 빌드가 성공하면 kustomize를 사용하여 배포 환경(production/staging)에 맞는 단일 manifest 파일을 생성합니다. 이 파일에서 이미지 이름은 모두 환경 변수 형식으로 되어 있어 envsubst를 사용하여 치환합니다. 이렇게 만들어진 manifest 파일은 git에 추적됩니다. 초기에는 시크릿 관리 방법을 몰라 이를 추적하지 않았지만 이후 Sealed Secret을 도입하여 추적할 수 있도록 만들었습니다. 이후 kubectl을 사용하여 로컬에서 배포를 수행합니다.

이 방식은 대단히 효율적입니다. 전에 GitHub Actions를 사용했을 때는 배포 기간이 3~5분까지 걸렸지만 이를 1분 이내로 단축할 수 있었습니다. 기본적으로 이전에는 푸시 이후 빌드 환경이 뜨고 Git Clone을 수행하고, registry에서 Docker cache를 로드하는 과정이 시간을 꽤 잡아먹었습니다. 그러나 이 방식을 도입함으로써 빌드 환경을 띄우는 작업이나 Git Clone은 애초에 할 필요가 없으며 Docker cache는 local cache를 사용하므로 캐시 로드 시간은 사실상 무시할 수 있습니다. 그래서 애초에 아무 변경사항이 없는 경우에도 기존의 배포 프로세스는 적어도 30초는 소요되지만, 모든 빌드를 로컬에서 수행하는 경우 이 시간이 0.9초로 단축됩니다.

그리고 배포 프로세스가 외부에 의존하지 않으므로 관리 포인트가 대단히 줄어들어 프로젝트 관리 역시 대단히 편리해졌습니다. 특히 kubernetes resource 자체가 Git으로 추적되는 단일 파일에 관리되기 때문에 나중에 오류가 발생한 경우 rollback역시 간단해졌습니다. stable한 배포를 한 이후 해당 커밋에 태그를 붙여 놓았다가 문제가 발생하면 그 커밋으로 돌아가서 해당 manifest.yaml파일을 배포하기만 하면 되기 때문입니다.

배포와 관련해서도 재밌는 일화가 있습니다. 훈련소에서 훈련을 받던 중, 갑자기 소대장이 부모님께 전화가 왔다고 저를 부르셨습니다. 그래서 전화를 받아 보니 이 프로그램이 갑자기 동작하지 않아 일을 할 수가 없다는 거였습니다. 당황스러웠지만 일단 훈련소에서는 스마트폰이나 컴퓨터를 사용할 수 없기 때문에 잠깐만 옛날의 방식 - 엑셀이나 종이 등 - 을 사용하라고 말씀드릴 수밖에 없었습니다. 그리고 몇 주 뒤, 어버이날이 되어서 10분간 스마트폰을 사용하도록 허락받았습니다. 원래는 부모님께 전화를 드리는 데 사용하는 시간이었는데 저는 그동안 SSH로 서버에 접속해서 열심히 문제점을 조사했습니다. 저희 집의 IP는 유동 IP여서 가끔 바뀌곤 하는데 이때문에 도메인에 연결된 IP가 바뀌었 게 원인이었습니다. 이럴 것을 대비해서 DDNS 서비스를 띄워 놓고 오긴 했는데, 실수로 서브도메인을 DDNS에 등록하지 않았었습니다. 만약 이 서비스가 아예 작동하지 않았다면 SSH조차 사용할 수 없었을 것입니다. 이후 Route53에 접속해서 수동으로 IP를 수정했고 아슬아슬한 타이밍에 서비스를 살렸습니다. 만약 이게 많은 사람들이 유료로 사용하는 서비스였다면 어땠을지 섬짓해지는 순간이었습니다.

나중에 알아보니 하필 그때 아파트에 네트워크 관련 공사가 있어 전체 네트워크가 다운되었고, 그래서 IP가 재발급됐던 거였습니다. 방금 로그를 확인해보니 그때 바뀐 이후로 1년이 다 돼 가는 지금까지 그 IP가 그대로 유지되고 있습니다.
