---
title: "Career Master Plan Project"
category: Career
date:
---

커리어를 위한 마스터플랜을 제작한다.

- 현재 내가 가지고 있는 역량
- 진행한 프로젝트들
- 유의미한 경험들
- 코딩 테스트, CS, 면접 대비 등을 진행한다.

이때 About page와 중복되지 않게 구성하기로 한다. About page에서 누락된 내용은 여기에 적을 수 있으며, 주기적으로 about page에 동기화하자.

# Projects

- The-Form
- 부동산

# What I do?

- Everyday coding
- Dev blog

# Ability

- **Backend**: Node.js(Express, Koa, Next.js), Python(FastAPI, Django), NginX
- **DevOps**: AWS(EC2, S3, Route53, ELB, EKS), k3s, Grafana, Prometheus, Traefik, GitHub Actions
- **Database**: MySQL, SQLite, Redis, MongoDB
- **Frontend**: React, Next.js, Typescript, HTML5, CSS(SASS, CSS-module)
- **Tools**: VSCode, Vim, Eclipse
- **Collaboration**: Git, GitHub, GitLab, Slack
- **Machine Learning**: Tensorflow, PyTorch, Slurm, MATLAB
- **Embedded / Hardware**: ARM(STM32Fxx), PCB Artwork basics (EasyEDA)
- **Graphics**: WebGL, OpenCV(both C++ and Python)

# Coding Test / Algorithm

- Definition and implementation of basic algorithms including

  - Set / Map / Hash / HashMap
  - Priority Queue (Heap)
  - Binary search methods (considering duplicated elements, elements at end of the array)
  - Cumulative sum, Prefix sum
  - Topological Sort

- Implementation of advanced algorithms including
  - Dijkstra
  - Floyd-Warshall
  - Bellman-Ford
  - Union-Find
  - MST, Kruskal
  - Segment Tree
  - Tri

# Interview Questions

- ==와 equals의 차이점
- Array, LinkedList, ArrayList의 차이점
- Call by value와 Call by reference의 차이점
- 자바에서는 call by value와 reference중 어떤 것으로 호출하는가?
- DAO DTO VO 차이
- equals()와 hashCode()의 차이점

- setTimeout(…, 0)의 실행 타이밍
- 이벤트 위임이란?
- 이벤트 루프란?
- 일급함수란?
- 호이스팅이란?
- 클로저란?
- 쿠키/세션 구분 설명
- Web Server & Web Application Server 구분 설명
- js에서 원시타입은 무엇이 있나?
- this란?
- prototype, prototype chaining이란?
- 시멘틱 웹이란?
- Unknown과 Any의 차이

- 1분 자기소개
- 본인이 했던 프로젝트 중에 제일 자신있는거
- 프로젝트를 하면서 어떤 cs 지식을 응용하였는지
- 퀵소트 응용방법에 대해 자세히 설명해달라
- 스마트팩토리 플랫폼 개발할때 고가용성을 위해 어떤것이 필요한가?
- 데이터베이스 무결성 3가지
- 관계형dbms의 특징, 요즘 db 신기술에 뭐가있는지
- 마지막 한마디

- 1분 자기소개
- sk에서 인턴 했던거 채용연계형인지?
- 왜 떨어졌다고 생각하는지
- 스펙 말고 직무 역량을 키우기 위해 어떠한 노력을 했는지
- 데이터베이스 역량을 말로만 말고 증명할 수 있는게 있는지?
- 학점이 안좋은데 대학생활때 어떤것을 주로 했는지
- 본인이 학점보다 사람관계를 더 중요시 했던 이유?

- 자기소개
- 대학전공수업 중 기억에 남는 수업
- 코딩테스트 아쉬웠던점
- 코딩테스트와 실제 개발과의 차이
- 대규모 프로모션을 진행할때 고려해야할 사항, 대비방법(미리 대비, 실시간 대비)
- 클라우드 네이티브 환경에 대한 특징

- 자기소개
- 1분자기소개
- 대학 다니면서 어려웠던것, 학업
- 친구가 몇명정도 있는지? + 여가시간은 어떻게 보내는지
- 프로젝트에 대한 설명
- 의사소통 역량을 발휘했던 경험
- 인생 살면서 부정적이었던 경험(그 전에 칭찬들음)
- 칭찬에 대한 감사를 먼저 표함, 경험에 대한 설명
- 일런머스크를 존경하는 인물로 뽑은 이유 + 혁신이란 무엇이라고 생각하는지
- 클라우드가 혁신인 이유
- 교양수업 들었던 이유
- 식물과 인간의 미래는 무슨수업? + 노동법의 이해는 무슨내용?
- 클라우드 써본것
- aws 이용해본 경험 설명.
- 영어 성적이 좋지는 않은데 앞으로 더 개선할 생각이 있는지
- 인턴은 어떤일을 수행했는지 설명
- 마지막 하고싶은 말
- 면접 진행 감사 표함

- 프로젝트 핵심기능
- db설계 중 중점사항
- 네이버 라인의 동작과정이 어떻게 될 것 같은지
- 인턴 경험 설명 요청

- 스프링 시큐리티란 무엇인지?
- CSRF가 무엇인지?
- TCP와 UDP의 차이점
- 삼성 SDS를 지원한 이유, 하고싶은 업무
- 물류 관련 프로젝트를 해본 적이 있는지
- 자바랑 C++비교할 때 자바의 장점
- 자바의 GC 설명
- 마지막 하고싶은 말

- 자바가 옛날엔 느렷는데 왜 그랫는지 아느냐
- 스트링이 이뮤터블인데 왜그러냐
- 스트링빌더와 스트링 버퍼 차이점
- 객체지향 5대원칙과 어떻게 그것을 적용하고 있는지
- 오버라이드 통해서 이콜스와 해시코드를 구현해서 보통 사용하는데 해본적 있는지 그리고 왜 그렇게 해야한다고 생각하는지
- 그리고 인터페이스에서 메서드를 추상이 아닌 실제 구현이 가능한데 어케 하면되는지
- orm사용은 왜하는지
- 줄게이트웨이의 1.0버전의 치명적 문제가 있는데 뭔지 아는지
- 서킷브레이커 장점- 쿠키랑 세션 차이
- 자바 버전 별 특징에 대해 아는지
- acid란 무엇인지
- 해시맵에서 해시함수를 왜쓰는지
- 쓰레드에 세이프하다는게 무슨 뜻인지
- Jvm 구조
- Gc 과정 설명
- 세션 쿠키 토큰
- 디비 조회 병목현상 => 레디스
- Rest url 설계
- 디렉토리 구조 설계
- 람다
- 함수형 인터페이스
- 옵셔널
- 마이바티스 jpa 차이점
- Jpa 지연로딩, 페치조인
- 배치 이중화 처리
- 스프링 카페인 캐시 설정
- 로드밸런싱 (엔진엑스, haproxy)
- 디자인패턴(전략, 빌더, 정적팩토리메소드)
- 함수형 프로그래밍이란?
- 야놀자에 지원한 이유
- 원하는 개발문화
- Oom경험
- Osi 7계층 설명
- 자바 8 버전 특징 ​
- 자바 스트림 특징 ​
- 자바 옵셔널 특징 ​
- 자바 11과 자바8차이 ​
- 스프링부트 버전 ​
- 최신 서비스 개발 시, 어떤 언어, 프레임워크 사용하고싶은지 ​
- JPA에서 옵셔널 리턴해줄때 어떻게 처리하는지, 서비스단에서 처리하는지? ​
- 엔티티에서 DTO 변환할때 어떤 유틸 클래스 쓰는지, 엔티티 내에서 xxxToDTO 메소드 만드는지? ​
- 객체지향 원칙 Solid에서 사용해본거 ​
- 전략패턴 설명 ​
- 정적 팩토리 메소드 설명 ​
- 회원가입 요청이 갑자기 많이 늘어났을 때 어떻게 할 것인지, 인프라적으로, 애플리케이션적으로 나눠서
- 스프링 클라우드, 서킷브레이커, 카프카, fast fail 방법 (API Timeout)
- 테스트 코드 작성은 어떻게 하고 있는지
- 서비스 클래스 설계할때 중점적으로 생각하는 것
- 프론트엔드와 백엔드 중 백엔드 선택 이유
- 회사내에서 주도적으로 기존 코드를 수정한 경험
- JVM에서 GC 동작과정
- application.yaml파일에 있는 설정값들이 동작하는 과정​
- JVM 동작과정 설명
- static 명령어 사용하는 이유
- Http랑 tcp 차이
- Osi7계층 구분 이유
- 브라우저에서 검색창에 youtube.com 입력했을때 동작과정
- 뮤텍스와 세마포어 차이
- 자바 스레드 동시성이슈 해결법
- Jvm튜닝경험
- Jvm oom 해결방법
- Jmeter 경험
- 플젝 질문들
- 스프링 프레임워크의 동작 원리 (DI, IOC)
- 정산 솔루션에 쓰이는 기술
- 스프링 배치, 쿼츠 스케줄러, 카프카
- 네이버페이랑 어떻게 연동되는지
- 네이버 자산관리랑 어떻게 연동되는지(소비자 관점에서)
- 클린코드에 대해 어떻게 구현하는지
- 테스트 코드를 짤때 본인만의 노하우
- 스프링을 사용하는 이유
- 스프링의 구동방식
- JPA에서 복잡한 쿼리 사용
- 인덱스 사용 의의
- 인덱스 사용 주의사항
- 인덱스에 사용된 자료구조
- B-tree와 인덱스 사용 주의사항을 연관지어 설명
- 클라이언트에서 http요청을 보낼때 스프링에서 어떻게 동작하는지
- 이직하는 이유
- 자바 static의 생존주기
- 일반 객체의 생존주기
- 클래스에 대한 정보는 언제 메모리에 올라가는지
- 16,17을 고려해서 18을 설명
- 자신이 갖고있는 장점
- AOP 설명
- Transactional Annotation 동작과정 설명
- 스프링에서 ioc와 di를 안쓰고 코드 작성이 가능한지
- 유명한 보안취약점에 대해 설명
- 테스트 코드 짤 때 mocking 쓰는지, 장점?
- filter 사용 위치
- HTTP 특성에 대해 설명
- 세션, 쿠키에 대한 설명, X-Forward-For, JessionID

- 1년밖에 안됐는데 회사를 옮기려는 이유
- 기획자가 로그를 100만개 찍어달라고 요구했을때 해결방안
- 파일을 만드는것이 db에 저장하는거보다 빠른 이유
- 쿠폰을 생성할때, 어떻게 만들어야 다른사람이 임의로 쿠폰번호를 입력했을때 문제가 발생하지 않을 수 있는지
- 내부클래스 생성 시, static을 붙인것과 안붙인것의 차이
- 자바의 철학이란?
- 본인만의 강점
- 회원 테이블 식별자 어떻게 사용하는지

- 이직사유
- 스프링 카페인 캐시 사용 이유
- 레디스 쓰지않은 이유
- 2번으로 인한 문제점
- 현재 회사 개발자 구성
- 로드밸런싱 어떻게 구성되어있는지
- 단위테스트를 어떻게 짜고있는지
- 테스트 커버리지에 대한 문제점
- 도커 서비스 트러블 슈팅 경험
- 스프링 클라우드 컨피그 서버와 스프링 부트 액츄에이터 적용 경험, 액츄에이터의 매트릭스에 대해 아는지?
- ReflectionUtils 사용경험
- Mockito 사용경험
- 부서 내 협업 툴 사용 경험
- 코드 리뷰 경험
- 라이브코딩 진행
  - 무한등비급수 라이브 코딩 + 리팩토링 + 클린코드 + 네이밍
- JPA와 mybatis를 둘다 쓰는 이유
- 세션 스케쥴링을 하는 이유
- 세션 만료시간이 없는건지?

- 1차면접때 본 라이브코딩을 가지고 단위테스트 라이브코딩
- 블로그 글 작성하던데 어떤 이유로 작성하는지?
- 3시간전에 올라온 글이 있던데 그에 대한 질문 > 클래스로딩 시점
- 왜 클래스로딩에 대해 궁금하게 되었는지? > 스프링 싱글톤 -> 멀티스레딩 -> 스레드 세이프 -> 스레드 풀 -> static은? -> 클래스로딩 순으로 공부
- 최근에 읽은 개발 서적

- 이직사유
- 부서 구성
- 주도적으로 개발한 내용
- 개발하면서 어려웠던점과 아쉬웠던점
- 단위테스트 레이어별로 작성 전략 및 mocking
- 단위테스트 작성 시 중요하게 생각하는점
- JAVA8의 default GC란?
- 스프링 Transactional 어노테이션 설명
- 최근 공부하고 있는 내용
- java8 GC 설명
- GC가 중요한 이유
- 단위 테스트 작성할때 시간 관련된 코드는 어떻게 하는지
- Transactional 어노테이션을 같은 클래스에서 호출하는 경우?
- Transactional 어노테이션이 Checked Exception과 Unchecked Exception에서 어떻게 동작하는지
- Transactional 어노테이션 전파레벨
- JPA의 N+1 문제

- 자바의 final 키워드가 적용되는 세가지 경우에 대해 설명해주세요
- final키워드와 finally, finalize의 차이점을 말해주세요
- 자바 api 정렬에서 Arrays.sort()는 어떤 정렬 알고리즘을 사용하나요? 최악의 경우 시간복잡도는? Arrays.sort()의 대안은?
- 자바 optional에 대해 설명해주세요
- 자바 static키워드의 생성시기와 소멸시기를 설명해주세요
- 자바의 객체 리플렉션에 대해 설명해주세요.
- Jdbc에 대해 설명해주세요
- JVM의 구조에 대해 설명해주세요
- 자바 소스코드가 JVM을 통해 실행되는 과정을 설명해주세요
- 가비지 콜렉터가 동작하는 과정을 설명해주세요
- 자바에서 Runnable인터페이스와 Thread 클래스의 차이점을 설명해주세요
- 이렇게 두가지 방법이 지원되는 이유를 설명해주세요
- 자바의 String/ StringBuffer/ StringBuilder의 차이점에 대해 설명해주세요
- 자바의 String 객체 생성시 리터럴로 생성하는 것과 new String()으로 객체를 생성하는 것의 차이점을 설명해주세요
- 자바의 Wrapper class에 대해 설명해주세요
- 자바의 boxing과 unboxing에 대해 설명해주세요
- 자바의 가비지 콜렉터에서 메모리 영역에 대해 설명해주세요
- 가비지 콜렉터의 동작과정을 설명해주세요
- 객체지향의 장점과 단점을 설명해주세요
- 객체지향의 특징을 설명해주세요(3가지 물어볼경우와 5가지 물어볼경우에 답이 다름)
- 멀티스레딩의 장단점에 대해 설명해주세요
- 생성자란 무엇인가요?
- 싱글톤 패턴이란 무엇인가요?
- 싱글톤 객체의 필요성에 대해 설명해주세요
- 자바에서 싱글톤 패턴을 구현하는 방법은? (3가지중에서 최적의 방법)
- 자바의 접근제한자에 대해 설명해주세요
- 파이썬은 접근제한자가 없는데 어떻게 구현해야하나요?
- 자바의 추상클래스와 인터페이스의 차이점에 대해 설명해주세요
- 데이터베이스 무결성 3가지에 대해 설명해주세요
- 관계형 데이터베이스와 비관계형 데이터베이스에 대해 설명해주세요
- 트랜잭션에 대해 설명해주세요
- 트랜잭션 ACID에 대해 설명해주세요
- 트랜잭션 고립성 수준에 대해 설명해주세요
- Non-repeatable read와 Phantom Read의 차이점에 대해 설명해주세요
- DB인덱스 설정 시 고려해야할 점을 설명해주세요. 성별과 주민등록번호 중에 어떤 것을 인덱스로 해야할까요? 그 이유는?
- SQL 인젝션 공격에 대해 설명해주세요
- SQL인젝션 공격을 막는 방법 중 하나인 prepared statement에 대해 설명해주세요
- 파이썬은 이것으로 간단하게 sql 인젝션 공격을 막을 수 있습니다. 이것은 무엇일까요?
- DB정규화에 대해 설명해주세요
- 정규화의 목적은 무엇인가요?
- TCP 3way handshaking과 4way handshaking의 차이를 설명해주세요
- 동기와 비동기 호출에 대해 설명해주세요
- CDN에 대해 설명해주세요
- CORS에 대해 설명해주세요
- HTTP에 대해 설명해주세요
- HTTP 메소드에 대해 설명해주세요
- HTTP Get과 Post의 차이점에 대해 설명해주세요
- HTTP 상태코드 401과 403의 차이점에 대해 설명해주세요
- HTTP와 HTTPS의 차이점에 대해 설명해주세요
- IPv6의 특징에 대해 설명해주세요
- 웹서버에 대해 설명해주세요
- Was(웹 어플리케이션 서버)에 대해 설명해주세요
- Nginx에 대해 설명해주세요
- Nginx와 Apache의 차이점에 대해 설명해주세요
- 프록시 서버란 무엇인가요?
- 포워드 프록시와 리버스 프록시에 대해 설명해주세요
- OSI 7계층이 존재하는 목적에 대해 말해주세요
- API란 무엇인가요?
- 그렇다면 REST API란 무엇인가요?
- 세션과 쿠키의 차이점에 대해 말해주세요(3가지)
- TCP와 TCP/IP에 대해 각각 설명해주세요
- 그렇다면 인터넷브라우저(크롬 등)의 주소창에 www.naver.com을 입력했을때 동작과정을 설명해주세요
- 브로드캐스트, 멀티캐스트, 유니캐스트에 대해 설명해주세요
- 브로드캐스트와 멀티캐스트는 어떤 차이가 있나요?
- UDP에 대해 설명해주세요
- UDP와 TCP의 차이에 대해 설명해주세요
- 웹 스토리지란 무엇인가요?
- 웹 스토리지와 쿠키의 차이점은 무엇인가요?
- 소켓이란 무엇인가요?
- 포트란 무엇인가요?
- 로드밸런서란 무엇인가요?
- L4 로드밸런싱과 L7 로드밸런싱의 차이에 대해 말해주세요
- 프로세스와 스레드의 차이에 대해 말해주세요
- 멀티스레딩에서 한 스레드에서 기존 작업을 중단하고 다른 스레드에서 새로운 작업을 처리한 다음 다시 원래 작업을 하려할때 어떻게 정보를 기억하나요?
- 멀티 프로세스의 장단점을 말해주세요
- 멀티 스레드의 장단점을 말해주세요
- IPC의 3가지 방법을 말해주세요
- 프로세스를 구성하는 저장공간 중 스택과 힙 중 무엇이 더 빠른가요?
- 선점 스케줄링과 비선점 스케줄링 기법을 각각 하나씩 말해주세요
- 라운드로빈 스케줄링에 대해 설명해주세요
- 뮤텍스와 세마포어의 차이점에 대해 설명해주세요
- 데드락이란 무엇인가요?
- 데드락의 발생 조건을 말해주세요
- 데드락 회피기법 중 은행원 알고리즘에 대해 말해주세요
- 내부 단편화와 외부 단편화에 대해 설명해주세요
- 페이징 기법에 대해 설명해주세요
- 페이징 알고리즘 중 FIFO의 단점에 대해 설명해주세요
- 세그멘테이션 기법에 대해 설명해주세요
- 캐시 동작의 원리 중 시간지역성과 공간지역성에 대해 설명해주세요
- 컴파일러와 인터프리터의 장단점에 대해 말해주세요
- 자바스크립트 호이스팅에 대해 말해주세요
- 자바스크립트 var, let, const의 차이에 대해 말해주세요
- 콜백 함수란 무엇인가요?
- 콜백함수의 문제점과 해결책은 무엇인가요?
- Ajax란 무엇인가요?
- 가상 돔이란 무엇인가요? 이러한 개념이 등장한 이유는?
- SPA란 무엇인가요?
- MVVM 패턴에 대해 설명해주세요
- (공통) 대학다니면서 어려웠던 일이 있었나요?
- (공통) 인생 살면서 부정적인 경험이 있었다면 설명해주세요
- (공통) 4차산업혁명중에서 어떤게 제일 혁신적이라고 생각하나요?
- (자료구조) 구구단, 이진탐색, 퀵소트, 해시맵의 시간복잡도를 설명해주세요
- (자료구조) DP와 재귀함수 중 어떤것을 더 선호하나요?
- (운영체제) 펌웨어와 운영체제 그리고 커널에 대해 설명해주세요
- (운영체제) 인터럽트와 폴링에 대해 설명해주세요
- (네트워크) TCP의 3way handshaking과 4way handshaking 과정을 그려주세요
- (데이터베이스) NoSQL이란 무엇인가요?
- (데이터베이스) DB 이력관리 중 선분이력이란 무엇인가요?
- (자바) 상속관계에서 생성자 호출 순서를 설명해주세요
- (스프링) 스프링 시큐리티란 무엇인가요?
- (스프링) JWT의 구조에 대해 설명해주세요
- (스프링) 스프링 프레임워크를 사용하는 이유는 무엇인가요?

- 자기소개
- 클라우드 (IaaS, PaaS, SaaS) 에 대해 쉽고 알아듣기 편하게 설명해봐라
- 클라우드 사업을 하는 것에 대한 단점 및 보완방법
- 웹 개발을 할 때 기술적으로 중요하다고 생각하는 것
- 회사생활을 하면서 가장 중요하다고 생각하는 것
- 신한카드 IT 서비스 중에서 개선해야된다고 생각하는 것
- 100억이 생긴다면 해보고싶은 사업
- IT역량중에 본인들이 특히 자신있는 기술스택
- 마지막 하고싶은 말

- Spring 에서 동시성 이슈 처리 방법.
  - ex) 동시에 동일한 Request가 들어오는 경우, 어떻게 처리해야할까?
- Spring 에서 Circular Dependency 를 피하기 위해서는 어떻게 해야할까?
- Spring 으로 서버를 두었을때, 무중단 배포 방법.​
- Scenario Case 질문

  ```
  Spring으로 만든 서버에서, black list ip를 관리 및 서버를 보호하고 싶다.
  black list ip는 ip4의 형태로 관리되며, 그 형태는
  192.168.0.1(32bit),
  192.168.0.xxx(24bit),
  192.168.xxx.xxx(16bit),
  192.xxx.xxx.xxx(8bit)
  와 같이 상위 8n bit로 판변한다고 할때,
  DB 구성 및 Request 마다 판별하는 방법은?
  (black list ip는 약 10만개, 초당 리퀘스트는 100개로 가정)
  ```

- 자기소개서를 요약해서 알려주세요
- 언제부터 프로그래밍을 하고싶었나요? 계기
- 다른 직업이 있음에도 프로그래머를 선택한 이유
- 프로젝트를 진행하면서 어려웠던 프로젝트
- 개인 프로젝트와 연구실에서 일했을때의 차이점
- 회사에서 일을 할땐 어떤게 중요하다고 생각하는지
- 의사소통을 할때 본인만의 강점
- (코테) 정렬을 하지 않고 문제푸는법
- 프로젝트 중 어떠한 것을 위주로 개발을 했는지
- 인덱스 복합키 설정을 어떻게 했는지​
- HTTP와 HTTPS의 차이점
- HTTP Body란?
- Get과 Post의 차이점
- Rest API란
- Call by value와 Call by reference의 차이점
- 자바는 Call by reference 인가요?
- 데이터 중복이 많은 열과 적은 열 중 어떠한 것을 인덱스로 만들어야하는지
- 스프링 IOC와 DI란?
- DI의 장점
- 단방향 암호화와 양방향 암호화
- 도커란 무엇인지
- 프로세스와 스레드의 차이점
- 리눅스에서 kill 명령어
- 자기소개
- IT전문회사가 아닌 은행을 지원한 이유
- 마이데이터 산업을 신한은행이 어떻게 이끌어가야할지
- 애너그램인지 아닌지 확인하는 라이브코딩
- c에서 call by value vs call by reference
- c에서 동적할당 및 해제 방법
- c에서 동적할당된 메모리가 다른 곳에서도 쓰이고 있을때 한쪽에서 해제한다면 어떤 문제가 발생하는지와 그 해결방법
- 자바의 추상클래스 vs 인터페이스
- final 명령어를 변수, 클래스, 메소드에 붙였을때 생명주기
- string을 따옴표 선언했을때와 new로 선언했을 때의 차이
- 재귀함수로 팩토리얼 구현하기
- 구구단의 이진탐색/ 퀵소트/ 해시맵 간 시간복잡도 차이
- 싱글턴 패턴이란? 용도는?
- 토론면접 + 개별질문 (2:8)
  1.  토론 주제 : 전산시스템을 개발할 때 통합개발을 해야하는지 부서별 개발을 해야하는지
  2.  토론에 대한 개별질문 1개씩
  3.  대한항공에 와서 어떠한 프로그램을 개발하고 싶은지
  4.  DT 중에 어떠한 것을 해보고 싶은지
  5.  애자일 프로세스를 아는지
  6.  하이브리드 앱과 네이티브 앱의 차이점
- 지원동기
- 1분자기소개
- 프로젝트 관련 질문
- 고객의 요구사항이 지나칠 때 어떻게 해결할 것인지?
- 마지막 하고싶은 말
- 지원동기
- 1분자기소개
- 프로젝트 관련 질문
- 여행 중 기억에 남는 일
- 마지막 하고싶은 말​

- 1분 자기소개
- 지원동기
- 네이버와 카카오보다 E1을 선호하는 이유
- 프로젝트 관련 질문
- 언제부터 컴퓨터 관련 일을 하고싶었는지? 그 이유?
- 마지막 하고싶은 말

- 1분자기소개
- 지원동기
- 고객이 마감기한을 빨리 요구한다면 어떻게 할것인가?
- 재귀함수와 DP중 시간복잡도가 낮은것, 어떤 것을 더 선호하는지? 그 이유?
- 프로젝트 관련 질문​ -토론면접(협상토론 - 갑사와 을사간의 실제 협상처럼 진행 - 중요도 떨어짐) -코딩테스트(2문제/DFS(재귀)/완전탐색(BFS))

- MAU가 10억정도 되는 서비스를 디자인해봐라.
- 카프카 구조는?
- 카프카가 reliability를 보장할 수 있는 이유는?
- ETag http header란?
- HTTP/2?3 에서 Connection Header재사용이 막힌 이유는?
- HTTP UDP Based로 바뀐 이유는?
- QUIC 설명
- CSSOM?

- SSL이란?
- OAuth 설명 - 구조 그려봐라
- TCP UDP 차이는?
- TCP Connect Disconnect에 대해 설명해봐
- 정규화 비정규화 예시 들어서 설명해봐
- 데브옵스가 뭐야?
- 성능테스트에서 얻었던 인사이트는?
- CI/CD 파이프라인은?
- 쿠버네티스 사용해서 컨테이너 배포 말고 그냥 배포는 어떻게 할 거야?
- 모니터링 해봤니?
- 프로메테우스가 뭘 위한 도구인지?
- 우리가 모니터링할 매트릭이 뭐가 있나?
- 프로메테우스가 어떻게 로그를 저장하지?

  - 그게 단점인데 어떻게 보완할까?

- 트러블 슈팅 경험은?
- 어떤 툴을 썼는지?
- 플랫폼은 어떤 아키텍쳐로 만들 건지?
- IaC써봤는지?
- 어떤 서비스를 만들고 싶은지? e.g. Google Health Check

- 0.1 + 1.1 == 1.2 틀린 이유

# Memo

얼마 전에 좋은 질문이 있길래 조금 더 깊이있게 풀이해보고 싶어서 정리좀 해봤어. 일단 예제 코드를 먼저 볼게.

int a[20][20] = {1,};
for (int i=0; i<20; i++) {
for (int j=0; j<20; j++) {
sum += a[i][j];
}
}

원본 질문은 저 2차원 배열에서 어떤 차원을 먼저 반복하는게 빠른 지가 질문이었어. 이 질문은 단순하지만 사실 쉽게 대답하긴 힘든 내용이야. 왜냐하면 메모리 캐시가 어떻게 이루어지는지 제대로 알고 있어야 대답할 수 있거든.

간단한 답부터 먼저 말해보면 저 코드에 한해서는 최하단 차원부터 반복하는게 가장 빨라. 저러면 거의 대부분 캐시힛이 발생하거든. 그런데 자료구조에 따라 더 빠르지는 않고 동일할 수 있기도 해. 이런 반례들은 천천히 아래에서 설명할게.

일단 cpu 얘기를 안할 수 없으니 조금 길게 살펴볼게. 현대의 cpu는 L1, L2, L3 캐시 메모리가 cpu on chip으로 달려있고, 실제 메모리는 외부 RAM(16, 32GB 등)을 사용하게 돼. 예전에 펜티엄 이전 싱글코어 시절에는 메인보드에 cpu 캐시가 추가되어 나오는 경우도 있었다고 하던데 요즘에는 예외없이 cpu에 포함되어 있어.

아래는 실제 cpu인 amd 5600x의 캐시 메모리 사양표야.

Cores 6
L1 Cache 64K (per core)
L2 Cache 512K (per core)
L3 Cache 32MB (shared)

위에 나온대로 L1, L2 캐시는 6개의 코어(!)마다 저 용량만큼 하나씩 가지고 있고, L3는 모든 코어가 같이 공유하는 캐시 메모리야. 그리고 cpu 캐시 메모리는 SRAM, 외부 RAM은 DRAM으로 만들어져있어. 그래서 cpu 캐시 메모리는 일반 RAM보다 더 빠르지만 그만큼 비싼 녀석이야.

사양표에 안나온 얘기 조금만 더 해보면, L1 캐시는 다시 데이터와 명령어 캐시로 나눠져서 각각 32KB씩 할당되어 각 타입에 맞게 캐싱하게 되는데 보통 L1d/L1i라고 약어처럼 사용하고, TLB(Translation Lookaside Buffer)란 녀석도 있는데 가상 메모리 주소와 물리 주소의 변환 테이블 역할이고, 만약 TLB miss 발생 시 받은 주소를 변환해서 TLB에 적어두고 다음에 요청이 오면 이를 사용하게 돼.

그럼 캐시는 항상 클수록 좋을까? L1이 아예 L3처럼 크면 안되는건가? 라는 의문을 가질 수 있는데 이건 참 미묘한 문제야. 캐시 접근 측면에서는 어차피 반복문으로 찾지 않고 O(1) 복잡도로 바로 접근이 가능하니 용량이 클수록 캐시힛 비율이 높아져서 좋긴 한데 커질수록 다른 cpu의 캐시와 경합을 벌이거나 캐시의 쓰기 동작의 발생 시에 갱신해야하는 캐시 비용들로 인한 캐시 레이턴시가 길어지는 단점이 있거든. 그리고 캐시 관리 측면에서도 용량이 클수록 알고리즘(LRU, LFU..)에 따라 효율이 떨어지긴 하니까. 뭐 보통 캐시는 적당히 클수록 좋긴 한데 얼마나 큰게 효율적인지 intel, amd 아키텍쳐 분들이 잘 해주실테니 우린 상관없긴 해. (사실 가격 상승만 아니면 크게크게 만들것 같기도 하고..)

잠깐 또 생각난건데 amd를 망하기 직전까지 만들었던 비운의 프로세서 '불도저'가 캐시 정책 부분을 잘못 만들어서 그렇게나 속도가 느렸다고 해. L2, L3용량을 동일하게 8MB로 늘였는데 그러다보니 L2, L3 접근할 때의 캐시 레이턴시가 그 때 나온 인텔과 비교해 두배나 느려서 모든 벤치 하위권에다가 cpu 클럭은 높아서 전성비 나쁘기로 유명했어. 이걸 보면 멀티 프로세서 시대에서는 cpu 클럭만큼 아키텍쳐가 중요한 이유이기도 하고.

최근에 amd에서 3D V-Cache라고 cpu위에 메모리를 적층하는 모델이 나왔더라고. 5800X3D라는 cpu인데 L3 캐시 용량이 전작보다 세배 증가했다고 해. (5800X:32MB, 5800X3D:96MB) 전작 cpu랑 비교한 벤치보니까 일반적인 부분에서는 조금 더 높긴 한데 차이가 크진 않다가 cpu 몰빵한 게임에서는 정말 유의미하게 높게 나오긴 하더라. (로아나 배그에서 20~30% 프레임 향상)

너무 잡설이 길었네. 어쨌든 cpu랑 캐시에 대해 잠깐 살펴봤는데 다시 돌아와서 이제 기억이 희미해진 예제 코드를 한 번 더 보자구.

int a[20][20] = {1,};
for (int i=0; i<20; i++) {
for (int j=0; j<20; j++) {
sum += a[i][j];
}
}

여기서 a[0][0]을 최초 접근할 때 어떤 동작이 발생하는지 볼게.
a[0][0]에 접근하면 먼저 L1 캐시에 해당 주소가 캐시되어 있는지 살펴보고, 없으면 L2 -> L3 -> RAM으로 점점 내려가면서 읽게 돼. 따라서 캐시 미스는 여러 번 발생할 수 있지만 우리는 통상적으로 L3 캐시에 없을 때에야 비로소 캐시 미스라고 부르고 있어.

이렇게 순차적으로 접근하다보니 데이터가 어느 캐시까지 있는지에 따라 조금씩 차이가 있어. 인텔 cpu 문서에 cache and memory subsystem 항목에서 access latency 보면 아래처럼 나와있어. (i7 기준)

L1: 4 (clocks)
L2: 10
L3: 35~40

자. 이걸 기준으로 잠깐 계산해보면 cpu가 2GHz라고 할 때에 L1 캐시 레이턴시가 4 clocks니까 4 / 2GHz = 2ns 로 L1 캐시 레이턴시가 2나노세컨드인걸 알 수 있어. 근데 우리가 L2에 접근할 때는 L1에 검색했다가 없어서 L2로 간거니 10 / 2GHz + L1 = 5ns + 2ns = 7ns.. 이걸 쭉 정리해볼게.

L1: 4 / 2Ghz = 2ns
L2: 10 / 2GHz + L1 = 5 + 2 = 7ns
L3: 36 / 2GHz + L2 = 18 + 7 = 25ns
RAM: DRAM latency + L3 = 60 + 25 = 85ns

DRAM latency는 인터넷 검색해보니 대충 50~150 사이라고 하는데 그냥 60으로 써봤어. 어쨌든 캐시 미스가 발생해서 단계가 내려갈 때마다 2,3배씩 느려지는걸 확인할 수 있어.

다시 예제로 돌아와서 캐시가 비어있다고 가정하면, a배열에 최초 접근 시에는 캐시 미스가 발생할테니 메모리까지 가서 값을 가져오게 돼. 그럼 그 값을 L3, L2, L1 캐시에 순차적으로 등록해서 사용할 수 있어. (이 부분은 cpu에 따라 정책이 다를 수 있어)

근데 가져올 때 딱 4바이트만 가져오면 너무 작고 효율이 안나잖아? 지금 탐색으로 들어간 비용이 얼만데.. 그래서 접근하는 메모리 주소부터 시작해서 일정 구역을 가져오도록 되어 있어. 최근 cpu는 보통 64byte로 설정되어 있는데 이 값을 cache line size, 가져온 구역 하나를 cache line이라고 불러.

그럼 L1d 캐시가 32KB인 cpu의 cache line size가 64byte라고 한다면 캐시 라인 수는 몇 개일까? 답은 32 \* 1024 / 64 = 512개야. 그래서 캐시 라인을 512개만큼 유지하다가 캐시 정책에 의해 만료되는 라인에 다시 쓰고 그러면서 캐시가 동작해.

우리 예제에서는 어디까지 캐시힛이 발생할건지 예측해볼게. 아래는 a배열을 16진수로 출력해 본 실제 주소값이야.

a[0][0]:7fff8981c830
a[0][1]:7fff8981c834
a[0][2]:7fff8981c838
a[1][0]:7fff8981c880
a[1][1]:7fff8981c884
a[1][2]:7fff8981c888

최하단 배열은 해당 배열의 자료형(int)만큼 증가되는걸 볼 수 있고, 상위 배열은 0x50만큼 그러니까 10진수로 80만큼 증가했어. cache line size가 64byte니까 최초에 a[0][0]를 읽으면서 캐시 라인에 등록되면 a[0][15]까지 캐시힛이 발생해. 그러다가 a[0][16]에 접근하면 캐시 미스가 되었다가 캐시를 새로 쓰고, a[0][17]을 읽을 때에는 방금 전에 추가된 캐시로 인해 캐시힛이 발생하게 돼. 결국 16번마다 1번씩 캐시 미스가 발생하니 이대로면 캐시 미스가 6.25%가 나오는 로직이 되겠지.

그럼 반대로 상위 차원으로 반복하는 a[j][i]는 어떻게 될까? 먼저 a[0][0]부터 시작해서 a[j][0]까지 최초 반복 시에는 모두 캐시 미스가 발생할거야. 그리고 그 다음 반복 시에는 a[0][1]을 읽을텐데 a[0][0]이 캐시에 들어있을까? 모르지. 아까 L1 캐시 라인이 512개라고 했잖아? 예제에서는 배열이 20개 뿐이라서 캐시힛이 될 확률이 높긴 한데 배열이 1000개였으면 당연히 L1 캐시에는 없을거야. a[488][0] ~ a[999][0]까지 512개만 L1 캐시에 존재하겠지.

L2 캐시에는 있을까? 그것도 L2 캐시 라인 개수에 따라 다르지만 L3에는 아무래도 있을 확률이 높아. L3 캐시가 워낙 크기도 하고 배열 개수에 비해 데이터가 매우 작으니까. 만약 L3에 존재한다고 하면 캐시 미스까진 아니더라도 L1, L2 캐시를 지나 L3 캐시 접근 비용인 25ns 이후에 데이터를 받을 수 있을거야.

여기서 캐시 미스가 얼마나 성능 하락을 발생시키는지 간단히 계산해볼게. 2GHz cpu는 0.5ns마다 한번씩 cycle을 돌고 있어. 명령어마다 필요한 cycle이 다르지만 평균 2cycle이라고 하면 1ns당 1개의 명령을 실행할 수 있겠지. 근데 캐시 미스가 발생하면 아까 RAM에서부터 가져오는 비용이 85ns라 그랬잖아? 그럼 이론적으로 캐시 미스 한번마다 85개 명령을 실행하지 못하는 손해볼 수 있다는거야.

그래서 큰 데이터를 처리하는 극도로 최적화된 코드를 보면 캐시 미스를 최대한 줄이기 위해 그 다음에 사용할 데이터를 미리 prefetch하는 코드도 있고 그래. inline asm을 사용하거나 volatile 지정자로 컴파일러 최적화 시에도 사라지지 않도록 하는데 실제로 내가 c++로 엔진 코드를 짤 때에 다음에 계산할 3d 모델을 prefetch하는 방식으로 속도를 개선해 본 적이 있어.

여기까진 사실 이론적인 얘기고, 실제로 적용되면 어떤 문제가 발생할 지 한 번 예상해볼까?

일단 cpu는 시분할 시스템을 사용하잖아? 그러니 지금 하는 동작이 인터럽트로 인해 잠깐 멈추고 다른 프로그램을 실행한다면 어떻게 될까? L1~L3 캐시가 그 프로그램에 의해 일부 덮어씌워지겠지. 그렇게 작업하다가 다시 돌아오면 캐시는 제대로 남아있지 않을거야. 그럼 캐시 미스가 발생할테고 이로 인해 예상보단 큰 시간이 걸리겠지.

그러면 이번엔 멀티 프로세서를 생각해보자. 지금 실행되던 동작이 인터럽트로 인해 멈췄다가 내가 원래 실행하던 cpu1번이 아닌 cpu2번으로 할당된다면 어떻게 될까? cpu가 바뀌는 컨텍스트 스위칭이 되면 register 정보는 PCB(Process Control Block)에서 가져오겠지만 해당 cpu2번에는 L1, L2 캐시에 이전 내용이 없어서 캐시 미스까진 아니더라도 L3에서 가져오는 비용을 치러야 할거야. 물론 거기도 없으면 RAM까지 가겠지.

이런 상황이 안생기게 하려고 각 운영체제에서는 프로그램이 최초 실행될 때 할당된 cpu에서 어지간한 상황에서는 바뀌지 않기도 해. 다만 다중 스레드라던가 여러가지 상황으로 인해 제어권이 뺏길 수 있어서 지정된 번호의 cpu를 우선적으로 할당하는 명령도 있어. 대표적으로 윈도우에서는 작업관리자에서 set affinity 메뉴가 있지. 근데 사실 이걸로 성능 테스트를 해본 적은 없어서 잘 작동하는지 확신은 못하겠네.

이 외에 더 생각해보면 좋을 시나리오는 데이터 하나가 cache line size를 넘어가는 자료를 가진 배열의 캐시 동작을 예상해보고 최적화 방향을 고민해 본다던가, 반복문에서 비동기 함수를 호출하게 되면 어떻게 될 지 생각도 해보고 뭐 여러가지가 있을 것 같아. 이런건 답은 없으니 상상으로 남겨둘게.

난 과거에 이런 최적화에 대해 한참 파보다가 나중에 좀 시들해졌는데 내가 굳이 이걸 고민하지 않아도 컴파일러가 알아서 파이프라이닝 잘 되게 instruction 위치랑 데이터 로드하는 위치도 잘 바꿔 주고, 알아서 L1i에 캐시힛 가능하도록 인라인 함수도 만들어주고 그러더라고. cpu는 또 얼마나 똑똑해졌는지 대충 만들어도 자주 실행하는 함수는 하드웨어에서 명령 예측 분기로 예측 실패도 막아주고.. 거기서 더 발전했으니 이제는 진짜 로직에만 집중할 수 있는 좋은 시대구나 싶기도 하고 그러네.

결론)

1. 다차원 배열은 최하위 차원부터 반복하면 캐시힛 확률이 높다
2. 캐시 미스는 상당히 큰 비용이 든다
3. 다만 이론과 실제 동작에는 많은 차이가 있으니 실제 벤치마킹 전에는 확신하지 말자

여기 내용들은 내가 공부했던 지식이 몇년 전에서 멈춰있는 관계로 지금 작동 방식이나 수치가 좀 다를 수 있어. 예를 들면 M1은 아예 system on chip이라고 표방하며 ram, gpu까지 cpu 하나에 다 넣었잖아? 그에 따라 캐시 정책이 많이 달라졌겠지. (근데 애플 얘네들은 왜 cpu 아키텍쳐 관련된 공식 세부 문서가 하나도 없지? 내가 못 찾는건가..)

어쨌든 이 글에서는 큰 맥락만 이해해주면 좋겠고, 혹시 틀린 내용이 있거나 요즘 트렌드에 대한 새로운 소식을 알고 있다면 덧글로 같이 얘기해보면 좋겠어.

긴글 읽느라 고생했어. 연휴 잘 보내.

이전글: https://frogred8.github.io
#frogred8 #cache #cpu
