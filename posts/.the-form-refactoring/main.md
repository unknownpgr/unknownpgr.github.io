---
title: The-Form Refactoring
category: development
---

저는 더폼([The-Form](https://the-form.io))이라는 서비스를 운영 중입니다. 더폼은 이전에 소프트웨어 마에스트로 교육과정을 연수하며 만든 설문조사 플랫폼입니다.

더폼을 개발하기로 결정하고 첫 커밋을 찍은 것이 21년 7월 8일입니다. 그 이후로 2년이 지났고, 더폼에는 많은 변화가 생겼습니다. 그러면서 더폼의 코드도 점점 복잡해졌고, 유지보수가 어려워졌습니다. 그래서 저는 더폼의 코드를 리팩토링하기로 결정했습니다.

이 글에서는 더폼의 리팩토링 과정을 소개하고, 리팩토링을 하면서 느꼈던 점들을 공유하려고 합니다.

## 왜 리팩토링을 하게 되었나?

더폼은 (신기하게도) 많은 유저분들이 사용해주시는 플랫폼으로, 다양한 기능 요청들이 항상 들어오고 있습니다. 어떤 때는 하루에도 수 건씩 새로운 기능에 대한 요청이 들어옵니다. 그런데 이런 기능들을 개발하려고 하다 보니 코드가 너무 복잡하고 불안정해서 새 기능을 추가하는 것이 너무 어려워졌습니다. 물론 어떻게든 개발하려고 하면 못할 것은 없겠지만, 그러다가 일이 잘못되면 도저히 손댈 수가 없게 될 것 같았습니다.

## 더폼의 문제점들

더폼의 가장 큰 문제는 타입스크립트가 아니라 자바스크립트로 개발됐다는 점입니다. 당시 프로덕트를 빠르게 개발하려는 욕심이 있었고, 저를 포함한 팀원들은 타입스크립트에 익숙하지 않았습니다. 그래서 자바스크립트를 사용하기로 의사결정을 내렸었습니다. 프로덕트 구조가 간단하고 항상 코드를 보고 있을 때는 별 문제가 없었는데, 프로덕트가 복잡해지고 한동안 코드를 보지 않다가 다시 코드를 보니 해석하기가 너무 어려웠습니다.

다음으로 컴포넌트들이 별도의 리포지토리로 존재하고 각각이 독립적인 배포 프로세스를 가지고 있습니다. 더폼은 백엔드, 프론트엔드, 인증 서버, 이미지 서버 등 다양한 컴포넌트로 나뉘어져 있습니다. 그런데 이들이 별도의 리포지토리에 존재하다 보니 배포 관련 작업을 바꾸는 것이 너무 큰일이 되어버렸습니다. GitHub Action에 각종 시크릿을 비롯한 중요한 값들이 각 리포지토리마다 설정되어 있어 하나의 설정값을 바꾸려고 해도 모든 설정값을 전부 건드려야 했습니다. 또 GitHub Action에서는 보안상의 이유로 시크릿을 설정하는 것은 가능하나 시크릿을 확인하는 것은 불가능해서, 시크릿을 별도로 유지해야 했습니다. 특히 시크릿은 Git으로 추적할 수도 없어 실수로 유실하기도 했습니다. (물론 쿠버네티스 상에서 그 값을 확인 가능하므로 다시 가져오면 되기는 합니다.)

무엇보다 아키텍쳐가 깔끔하지 않았었습니다. 특히 더폼은 중요한 로직들이 프론트엔드에 많이 들어있습니다. 그런데 규모가 큰 프론트엔드 코드를 작성해본 경험이 부족했을 뿐만 아니라, 아키텍쳐에 대한 이해도 부족해서 프론트엔드에서 비즈니스 로직과 UI 코드가 많이 섞여버리고 말았습니다.

## 리팩토링 전략

리팩토링에 앞서, 리팩토링 전략을 철저하게 짜고 점진적 배포를 목표로 리팩토링에 들어가기로 결심했습니다. 왜냐하면 이전에 한번 리팩토링을 시도했다가 실패한 경험이 있기 때문입니다. 그때는 한 번에 리팩토링을 너무 많이 진행한 나머지 프로덕트가 이전과 너무 많이 달라져 기존 서비스에 저장되어있던 데이터를 이식해오는 것이 사실상 불가능했습니다. 거기다 프론트엔드와 백엔드의 구조를 한번에 너무 많이 바꾸다 보니 데이터 이식이 가능하다 한들 사실상 프로덕트를 새로 만들어 배포하는 상황이었습니다. 그렇게 완전히 새로운 코드베이스를 배포하는 것은 너무 위험한 결정입니다. 그래서 결국 원점으로 돌아왔었습니다.

그래서 가장 먼저 더폼의 모든 리포지토리를 전부 하나의 monorepo에 몰아 넣었습니다. 그리고 CI/CD 파이프라인을 다시 구축했습니다. monorepo로 리포지토리를 합친 것은 테스트를 용이하게 하기 위해서였습니다. 기존의 구조에서는 개발 서버를 로컬에서 띄우기가 힘듭니다. 그러나 monorepo로 프로젝트를 관리함으로써 서비스 전체를 로컬에서 띄울 수 있게 되었습니다. 더폼은 그렇게 무거운 서비스가 아니며 팀 규모가 작기 때문에 다른 서비스를 mocking하기보다는 서비스 전체를 로컬에서 띄워 개발하는 편이 효율이 훨씬 좋습니다.

이 작업과 함께 기존의 모든 리포지토리를 archive했습니다. 기존의 코드베이스를 건드리지 못하게 강제하기 위함입니다. 전에 그렇게 하지 않았더니 사소한 오류 수정이나 디자인 개선을 이유로 기존의 코드베이스를 자꾸 건드리게 되고, 그러다 기존 코드베이스와 새 monorepo의 차이가 너무 커지면서 결국 monorepo로 이전하는 것이 불가능해진 적이 있습니다.

마지막으로, monorepo로 이전한 이후에는 '어쨌든 프로덕션 배포'를 가장 우선의 목표로 삼았습니다. 한 번 프로덕션 배포를 진행해야지만 완전히 코드베이스를 이전했다고 판단할 수 있기 때문입니다.

이후에는 억눌려있었던 다른 개발자, 디자이너, PM의 프로덕트 개선 욕구를 반영하기 위해 리팩토링을 잠시 중지하고 디자인 개선과 각종 데이터 분석 툴 추가, 기능 개선 작업을 진행했습니다. 그러면서 백엔드의 아키텍쳐가 좀 더 견고하게 바뀌었고 메인 페이지의 디자인을 개선했으며 각종 자잘한 오류를 해결했습니다. 이로서 리팩토링을 시작할 최소한의 준비를 마쳤습니다.

이후에는 리팩토링을 백엔드부터 진행할지 프론트엔드부터 진행할지를 고민했습니다. 두 컴포넌트를 동시에 리팩토링하는 것이 불가능하지는 않습니다. 그러나 그 경우 대단히 많은 코드가 수정된 후에야 배포가 가능합니다. 즉, 점진적인 배포가 불가능합니다. 그래서 고민 끝에 프론트엔드를 먼저 리팩토링하고 백엔드를 비롯한 나머지 컴포넌트를 리팩토링하기로 결정했습니다. 왜냐하면 더폼은 설문조사라는 도메인 상 비즈니스 로직이 대부분 프론트엔드에 있기 때문입니다.

## 프론트엔드 리팩토링 [1] - Ts-fy

모든 구조적 리팩토링에 앞서, 프론트엔드를 JS에서 TS로 리팩토링했습니다. 불확실한 부분에 전부 `any`를 넣는 한이 있더라도 일단 모든 파일을 타입스크립트로 변환했습니다. 그러면서 UI컴포넌트를 비롯하여 세부적인 부분들을 전부 안정적인 타입스크립트로 변환할 수 있었습니다. 

## 프론트엔드 리팩토링 [2] - 아키텍쳐 설계

이후에는 클린 아키텍쳐에 기반한 설문 구조를 구현했습니다. 이 과정에서 가장 힘든 부분은 비즈니스 로직을 구현하기 위한 프로그래밍 방법론을 결정하는 거였습니다. 프로그래밍에는 절차지향형, 함수형, 객체지향형 등 다양한 패러다임이 있습니다. 더폼의 비즈니스 로직을 구현하는 데는 객체지향형(Object Oriented Programming; OOP)와 자료지향형(Data Oriented Programming; DOP) 두 가지 방법론이 적당한데 두 방법론 모두 장단점이 있기 때문입니다.

- 전자를 택하면 값을 숨기고 메서드만 노출함으로써 엔티티를 안정적으로 만들 수 있습니다. 그러나 값과 메서드가 섞인다는 단점이 있으며 그래서 프론트엔드 - 백엔드간 엔티티 데이터의 공유가 어렵습니다.
- 후자를 택하면 데이터와 그 데이터를 다루는 함수가 잘 분리된다는 장점이 있으며 스키마만 잘 정의하면 프론트엔드 - 백엔드간 엔티티 데이터의 공유가 쉽다는 장점이 있습니다. 그러나 데이터를 은닉하거나 직접 수정하지 못하도록 강제하는 것이 어렵다는 단점도 있습니다.

이 결정이 어려운 이유는 더폼의 비즈니스 로직이 프론트엔드와 백엔드에 걸쳐있기 때문입니다. 
만약 더폼이 프론트엔드나 백엔드 둘 중 한쪽이 대부분의 비즈니스 로직을 차지하고 다른 쪽은 상대의 인프라, 혹은 표현 레이어에 불과하다면 이러한 고민을 할 필요가 없었을 것입니다.

> 사실 프론트엔드와 백엔드라는 관점은 애초에 아키텍쳐 설계 단계에서는 고려해서는 안 됩니다. 먼저 아키텍쳐를 설계하고 난 후, 구체적인 부분을 구현할 때 프론트와 백이라는 경계를 컴포넌트 사이에 그을 수 있을 뿐입니다.

물론 OOP와 DOP는 관점이 다를 뿐 상충하는 방법론이 아닙니다. 필요에 따라 두 방법론을 조화롭게 사용할 수 있습니다. 그래서 저는 DOP의 관점에서 데이터의 값과 분리되는 스키마를 정의하고, 데이터를 클래스 대신 오브젝트로 다뤘습니다. 대신 Validation 로직을 추가해서 데이터의 타입을 결정할 수 있도록 했습니다. 그러므로 데이터는 서비스 경계를 (심지어 프로그래밍 언어가 다르더라도) 자유롭게 오갈 수 있습니다.

이때 최대한의 범용성과 언어 및 프레임워크에 대한 의존성을 줄이기 위해 설문 스키마는 JSON-Schema로 작성되었고, `zod`를 사용하여 validation을 수행하고 타입스크립트 타입을 추출합니다. 물론 JSON-Schema는 대부분의 언어와 호환되므로 백엔드나 프론트엔드 언어가 바뀌더라도 스키마를 그대로 사용할 수 있습니다.

```typescript
import { Survey, SurveySchema } from 'entity';

class SurveyService{
    private surveyObject: Survey;

    constructor(surveyObject: Survey){
        this.surveyObject = SurveySchema.parse(surveyObject);
        // 실제로는 더 많은 validation 로직이 있습니다.
    }

    public getSurveyObject(): Survey{
        return this.surveyObject;
    }

    public setSurveyTitle(title:string){
        this.surveyObject.title = title;
    }

    // ... 하략
}
```

마지막으로 위와 같이 이러한 데이터를 수정하는 함수들의 집합을 클래스로 만들었습니다. 이 클래스는 내부에 데이터 오브젝트의 참조를 유지하며 메서드를 통해 이 데이터 오브젝트를 수정합니다. 이 부분은 오브젝트를 직접 수정한다는 점에서 OOP의 구현에 가깝습니다. DOP에서는 모든 데이터를 immutable로 간주하기 때문입니다.

## 프론트엔드 리팩토링 [3] - 로직 마이그레이션

이후에는 기존의 프론트엔드를 새롭게 만들어진 깔끔한 비즈니스 로직을 사용하도록 마이그레이션했습니다. 이 과정에서는 새롭게 작성한 코드를 손상시키지 않으면서 리액트와 호환되게 만드는 것이 가장 어려웠습니다.

리액트에서는 모든 상태를 `state`로 관리합니다. `state`는 `setState`에 의하여 값이 설정되고 이후 리액트에 의해 자동으로 렌더링이 다시 이루어집니다. 그런데 새로 만든 아키텍쳐에서 상태는 오브젝트 혹은 이를 포함하는 클래스의 인스턴스일 뿐입니다. 그래서 메서드를 사용해서 내부적으로 값을 변경해도 렌더링이 발생하지 않습니다.

이 문제를 해결하기 위해 정말 많은 고민을 해보고 또 시도해봤습니다.
- 리액트의 `state`를 사용하여 상태 관리를 하는 것을 고려해봤습니다.
    - 그러나 그 경우 엔티티나 유즈케이스처럼 추상적인 부분이 리액트 프레임워크라는 구체적인 부분에 의존합니다. 그러므로 이는 추상화를 위반합니다.
    - 또 `state`는 새로운 값을 어디서나 즉시 참조할 수 있는 것이 아니라 UI가 한 번 렌더링된 후에야 참조할 수 있습니다. 그러므로 비동기나 UI와 무관한 로직을 구현하기에는 적합하지 않습니다.
    - `state`는 `setState`와 `useState`를 포함하여 UI 내부에서만 사용할 수 있으므로 UI에 비즈니스 로직이 의존하게 됩니다.
- `Context API`나 `Redux`를 사용하여 상태 관리를 할 수도 있습니다.
    - 그러나 이것 역시 좀 더 쓰기 편하고 여러 컴포넌트에 걸쳐 있는 `useState`일 뿐입니다.
    - 결과적으로 추상화를 위반합니다.
- Javascript의 `Proxy` API를 사용하면 오브젝트의 변화를 감지할 수 있습니다.
    - 이 방법은 너무 괜찮아 보여서 실제로 구현해보기도 했습니다.
    - 그런데 실제로 해 보니 이 구현은 너무 환경에 의존적입니다. 어떤 브라우저에서는 이 API를 지원하지 않기도 합니다.
    - 일반적으로 어떤 동작이 실행될 것이라고 예상하기 힘든 값 할당에서 동작이 발생하기 때문에 의도치 않은 실수를 유발할 수 있습니다.
    - 경우에 따라 값이 변경되었지만 렌더링을 원하지 않을 수도 있습니다. 같은 값을 재할당하는 경우가 그렇습니다. 그러나 이 경우에도 렌더링이 발생합니다.
- Service에서는 값의 변화를 관찰하는 로직을 전혀 넣지 않습니다. 대신 Service를 React에서 사용할 수 있도록 해주는 Adaptor를 만들고, 거기에서 service의 모든 함수를 wrapping하여 변화를 감지하도록 구현합니다.
     - 이 방법은 아키텍쳐적으로는 가장 깔끔한 방법이라고 생각했습니다.
     - 그러나 이 방법은 Adaptor에서 Service의 모든 함수를 wrapping해야 하므로 코드 중복이 과도하게 발생합니다.
     - 특히 새로운 기능을 추가할 때마다 Adaptor를 수정해야 하므로 유지보수를 어렵게 만듭니다.

이러한 시도 끝에 결국은 가장 확실하고 안정적인 방법을 택하기로 했습니다. 데이터를 관리하는 Service object에는 listener를 등록할 수 있고, 데이터의 값을 변경하는 함수가 호출되면 값을 변경한 후 명시적으로 등록된 listener를 호출하는 방식입니다. 이 방식은 특별한 환경을 요구하지 않으므로 가장 안정적이고 확실한 방법이라고 생각했습니다. 이 방법은 대신 실수로 새로운 기능을 구현하고서 listener 함수를 호출하지 않으면 렌더링이 발생하지 않습니다.

```typescript
class SurveyService{
    // ... 상략
    private listeners: (()=>void)[] = [];
    public addListener(listener:()=>void){
        this.listeners.push(listener);
    }

    private notifyListeners(){
        this.listeners.forEach(listener=>listener());
    }

    public setTitle(title:string){
        this.surveyObject.title = title;
        this.notifyListeners();
    }
    // ... 하략
}
```

## 프론트엔드 리팩토링 [4] - 데이터 마이그레이션

이후에는 데이터를 마이그레이션했습니다. 먼저 백엔드를 호출해야 하는 작업들을 `Repository`라는 인터페이스에 정의하고 이 인터페이스를 구현하는 클래스를 작성했습니다. 이때 백엔드는 아직 전혀 손대지 않은 상태이므로 기존에 백엔드를 호출하던 함수들을 그대로 가져다 썼습니다. 그리고 백엔드에서 가져온 데이터들을 새롭게 바뀐 엔티티 구조로 마이그레이션하는 코드를 넣었습니다.

이때 충격적이게도 백엔드로 값을 집어넣을 때는 마이그레이션이 필요하지 않았습니다. 왜냐하면 백엔드에서 값 검사를 거의 하지 않았기 때문입니다. (그래서 사실 기존 더폼 데이터베이스에는 임의의 JSON 객체를 삽입하는 것이 가능했었습니다.)

마이그레이션 함수를 만들면서는 고민할 것이 별로 없었습니다. 값의 validation이나 parsing은 `zod` 라이브러리를 통해 쉽게 해결했기 때문입니다. 그러나 기존 설문 데이터 구조를 대충 적어만 놓고 그 스키마를 Typescript interface나 JSON-Schema 등으로 만들어두지 않았기 때문에 데이터베이스를 직접 확인하면서 기존 설문 구조를 파악해야만 했습니다. 특히 기존에는 Optinal한 필드가 너무 많았어서 기본값 처리를 하는 것 역시 꽤 난감한 작업이었습니다.

## 프론트엔드 리팩토링 [5] - 용어 정리

구조를 정리하고난 후에는 용어를 확실히 정리했습니다. 이전까지는 여러 용어를 사용하다 보니 혼란이 있었기 때문입니다. 예를 들어 설문의 응답을 나타내기 위해 국문으로 `응답`, `답변`, `결과`, 영문으로는 `answer`, `response`, `result` 등의 용어가 혼용되고 있었습니다. 특히 `response`, 혹은 `응답`은 일반적인 API 응답을 나타내기도 하고 설문 답변을 나타내기도 해서 대단히 혼란스러웠습니다. 그래서 기왕 리팩토링한 거, 용어를 전부 정리했습니다.

- `Survey`: 설문
- `Question`: 설문의 질문. `Survey`는 `Question`을 여러 개 가질 수 있다.
- `Answer`: 한 개 `Question`에 대응하는 답변.
- `Submission`: 응답자가 한 개 `Survey`에 대해 답한 결과. 그러므로 `Submission`은 여러 개의 `Answer`로 이루어진다.
- `Result`: 한 `Survey`에 대한 모든 `Submission`의 집합. 그러므로 `Result`는 여러 개의 `Submission`으로 이루어진다.

## 백엔드 리팩토링 [1] - 아키텍쳐

이후에는 백엔드 리팩토링을 진행했습니다. 이전까지 express router에 들어 있던 비즈니스 로직을 단일 클래스로 모았습니다. 그리고 다양한 기능들의 의존성을 분리했습니다.

예를 들어 이메일을 보내는 기능을 리팩토링했습니다. 이전에는 메일을 보내는 과정이 비즈니스 로직에 직접 포함되어 있었습니다. 비즈니스 로직에서 EJS 템플릿 엔진을 실행하고, 직접 AWS SDK를 호출했습니다. 그러므로 이메일을 보내는 route하나가 라우팅, 파라매터 파싱, 템플릿 렌더링, 보내기까지 모든 과정을 수행했습니다. 그러나 리팩토링을 진행하며 이 기능을 `EmailSender`, `TemplatedEmailSender`라는 두 가지 인터페이스로 분리했습니다.

- `EmailSender`는 `sendEmail(src, dst, title, content)`라는 메서드를 가집니다.
- `TemplatedEmailSender`는 `sendGreetingEmail(...)`, `sendSurveyInfoEmail` 등의 메서드를 가집니다. 각 메서드는 이메일을 보낼 때 필요한 값을 파라매터로 받아 내부적으로 이메일 제목과 내용을 생성합니다.
- `TemplatedEmailSender`는 생성 시 `EmailSender`를 주입받아 메일을 보낼 때 사용합니다.

이후 이를 상속하는 `SesEmailSender`, `TemplatedEmailSenderImpl` 클래스를 실제로 구현했습니다.
- 이로부터 관심사의 분리가 이루어졌습니다.
- 비즈니스 로직을 전혀 건드리지 않고 템플릿을 추가하거나 업데이트할 수 있습니다.
- 이메일을 AWS SES대신 다른 방법으로 보내려는 경우에도 아주 쉽게 이식할 수 있습니다.
- `SesEmailSender`를 제외하면 모두 로컬에서 mocking에 기반한 테스트가 가능합니다.

물론 백엔드에도 데이터베이스 접근을 위한 `Repository` 인터페이스를 만들고 실제로 접근하는 `RepositoryImpl` 클래스를 구현했습니다.

마지막으로 프론트에 있었던 옛날 버전의 설문을 새롭게 마이그레이션하는 코드를 백엔드 repository로 옮겨왔습니다. 몇 가지 사소한 오류를 제외하면 (프론트에서와 다르게 백엔드에서는 `Date` 형식의 값이 문자열이 아니라 오브젝트였기 때문에 발생한) 문제 없이 잘 동작했습니다. 이로부터 백엔드에서도 타입 안전성이 확보되었습니다.

## 백엔드 리팩토링 [2] - API

비즈니스 로직을 리팩토링한 후에는 API 구현을 신경썼습니다. API는 테스트하기 어려울 뿐만 아니라 컴파일 타임에 오류를 잡기도 힘들기 때문입니다. 그래서 API 코드를 직접 구현하는 대신, `tsoa` 라이브러리를 사용하여 자동으로 API route와 OpenAPI Schema를 생성하도록 구현했습니다. 이후 프론트엔드에서 `openapi-typescript-codegen` 라이브러리를 사용하여 API 클라이언트를 자동으로 생성하도록 구현했습니다.

프론트와 백은 OpenAPI의 subset인 JSON Schema로 작성된 엔티티를 공유하기 때문에 타입은 자연스럽게 일치됐습니다. 데이터를 보내는 방식에 따라 일부 차이나는 부분은 frontend의 repository에서 쉽게 해결할 수 있었습니다.

또한 부가적인 이득으로 입력 데이터의 스키마 검증이 자동으로 이루어졌습니다. 예전에는 데이터의 값을 제대로 validation하지 않았기 때문에 사실상 임의의 JSON을 보내도 저장이 가능했습니다. 그러나 지금은 tsoa에서 자동으로 타입 검증을 해 주기 때문에 이런 문제가 발생하지 않습니다.

## 백엔드 리팩토링 [3] - 테스트

이후 드디어 테스트 스크립트를 도입하기로 했습니다. 기존에는 기능이 별로 많지 않아 수동으로 QA를 진행했었습니다. 하지만 앞으로 기능을 더 추가할 예정인데다 배포도 잦아질 것이므로 수동 QA는 합리적이지 않다고 판단했기 때문입니다.

테스트 프레임워크로는 Puppeteer, Playwright를 고려했습니다. Postman, Jmeter 등 다양한 테스트 툴이 있지만 이들은 API나 백엔드 레이턴시 / 스루풋 측정에는 적합해도 UI를 테스트할 수 없다는 단점이 있었기 때문입니다. 더폼은 설문조사 플랫폼이기 때문에 UI 테스트가 필수적입니다.

이 둘 중 Playwright를 선택했습니다.
- 설치 및 환경설정이 편리합니다.
- 공식적으로 docker를 지원합니다.
- Asynchronous / delay가 발생하는 작업에 대한 테스트가 자동화되어 있습니다.
- 여러 브라우저에서 테스트할 수 있는 옵션을 제공합니다.

## 시크릿 관리

그리고 sealed-secret 기반으로 시크릿을 관리하도록 업데이트했습니다. 기존에는 GitHub Action을 동작시킬 때 환경 변수를 통해 시크릿을 주입했습니다. 이 방법은 시크릿 관리가 어려울 뿐만 아니라 Kubernetes resource를 git에 track하는 것이 불가능한 문제가 있었습니다.

그러나 sealed-secret을 사용함으로서 시크릿 및 다른 Kubernetes resource를 git에 track할 수 있게 되었습니다.

## CI / CD 리팩토링 

그와 함께 GitHub Action으로 구현되었던 CI / CD를 로컬에서 동작하는 Node.js 스크립트로 업데이트했습니다.
- 더폼은 팀 규모가 작기 때문에 굳이 무겁고 중앙화된 배포 환경을 사용할 필요가 없습니다.
- 로컬에서 빌드 및 배포를 수행하면 캐시 사용을 극대화하여 빌드 시간이 크게 단축됩니다.
- 필요에 따라 다시 GitHub Action 등으로 옮기는 것도 어렵지 않습니다.

이 Node.js 스크립트는 각 서비스에 대하여 아래 동작을 실행합니다.
1. `node-modules` 등을 제외한 리포지토리의 모든 파일의 목록을 얻습니다.
2. 이를 정렬합니다.
3. 순서에 따라 모든 파일을 읽으며 그 해시를 계산합니다.
4. 파일시스템에 저장되어있는 해시와 비교, 다르다면 빌드를 수행합니다.
5. 도커 이미지를 레지스트리에 푸시합니다. (더폼은 프라이빗 리포지토리를 사용하고 있습니다.)
6. kustomize를 실행하여 더폼 전체 서비스를 띄우는 단일 `manifest.yaml` 파일을 생성합니다.
7. 이를 kubectl로 배포합니다.

이로부터 해당 `manifest.yaml` 파일만 가지고 있으면 더폼 전체 서비스를 배포할 수 있게 되었습니다. 이 파일은 git에 track되어 있으므로 만약 오류가 발견되어 서비스를 롤백해야 하는 경우, 가장 최근 배포한 커밋에서 해당 파일을 가져와서 배포하면 됩니다.