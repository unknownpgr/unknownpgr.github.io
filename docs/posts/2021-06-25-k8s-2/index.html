<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="description" content="Unknownpgr&#x27;s Blog"/><link rel="icon" href="/favicon.png"/><meta property="og:title" content="Unknownpgr&#x27;s Blog"/><meta property="og:url" content="https://unknownpgr.com"/><meta property="og:image" content="/logo.png"/><title>Unknownpgr : 쿠버네티스 클러스터 구축[2] - Lens</title><meta property="og:title" content="Unknownpgr: 쿠버네티스 클러스터 구축[2] - Lens"/><meta name="next-head-count" content="9"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/2e1e96656eb72d38.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2e1e96656eb72d38.css" data-n-g=""/><link rel="preload" href="/_next/static/css/bb77c4673c8d1507.css" as="style"/><link rel="stylesheet" href="/_next/static/css/bb77c4673c8d1507.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-1cd5204319a0e744.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b2167bfc37ff4f0b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-ef770e12683a69af.js" defer=""></script><script src="/_next/static/bg3GNayTREst1g1Voz8hR/_buildManifest.js" defer=""></script><script src="/_next/static/bg3GNayTREst1g1Voz8hR/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="nav_nav__XkaAa"><a class="nav_logo__drPJg" href="/">[UNKNOWN-PGR]</a><a class="nav_link__KHlEJ" href="/">Home</a><a class="nav_link__KHlEJ" href="/categories/">Categories</a><a class="nav_link__KHlEJ" href="/about/">About</a></nav><main class="layout_main__j5lor"><div><h1 class="post_title__aQveY">쿠버네티스 클러스터 구축[2] - Lens</h1><div class="post_info__7zaFc"><i>kubernetes<!-- --> / <!-- -->2021-06-25T19:42:33.030Z</i></div><main class="post_main__mmVmG"><p><img src="/imgs/6a347940f064146525be36b805414901.png" alt="Kubernetes"></p>
<h1>K8S</h1>
<p>Kubernetes는 여러 개의 머신 위에서 여러 개의 컨테이너들을 관리하기 위한 시스템입니다. 쿠버네티스는 여러 머신들을 하나의 클러스터로 묶어 관리하는데, 이 각각의 머신들을 노드(Node)라고 부릅니다.</p>
<p>이 노드을 중 일부는 클러스터 전체를 관리하는 역할을 수행하는 master node이며 일부는 단순 작업을 수행하는 worker node입니다. 모든 클러스터에는 반드시 하나의 마스터 노드가 있어야 합니다.</p>
<p>일반적으로는 보안상의 이유로 master node와 worker를 따로 구성하지만 저처럼 단일 머신만 가지고 있는 경우에는 한 노드가 master와 worker 역할을 동시에 수행할 수도 있습니다.</p>
<p>이때 master node가 정지할 경우 worker node를 제어할 수가 없기 때문에 master node가 하나인 경우에는 마스터 노드가 단일 실패 지점 (single point of failure; SPOF)이 됩니다. 그래서 고가용성 (High Availability; HA) 구성을 하는 경우에는 마스터 노드를 여러 개로 구성하기도 합니다.</p>
<p>아래 설명은 <a href="https://kubernetes.io/ko/docs/concepts/overview/components/">쿠버네티스 공식 도큐먼트</a>를 참고했습니다.</p>
<p>마스터 노드에는 다음과 같은 컴포넌트들이 실행됩니다. 이들은 간단하게 컨테이너 위에서 실행되는 프로세스들이라고 봐도 무방하겠습니다.</p>
<ul>
<li>kube-apiserver</li>
<li>etcd</li>
<li>kube-scheduler</li>
<li>kube-controller-manager</li>
</ul>
<h2>kube-apiserver</h2>
<p>API Server는 쿠버네티스의 모든 명령을 처리하는 서버입니다. 여기로 REST API 형식으로 명령이 전달되면 쿠버네티스 클러스터에 그 명령이 반영됩니다. 이 api 서버 자체도 컨테이너 위에서 실행되며, 이 api 서버 자체를 여러 개 생성해서 로드밸런싱할 수도 있습니다.</p>
<h2>etcd</h2>
<p>etcd는 고가용성 key-value 저장소로 쿠버네티스의 모든 정보가 여기 저장됩니다.</p>
<h2>kube-scheduler</h2>
<p>쿠버네티스에서는 컨테이너를 다룰 때 Pod이라는 단위를 사용합니다. Pod은 사실 컨테이너들의 묶음이지만 보통 Pod 하나에 컨테이너 하나만 있는 구조를 사용합니다. kube-scheduler는 이 pod을 어떤 node에 배정할지 결정해줍니다. 스케줄러가 필요한 이유는 pod을 아무 node에나 배정하면 안 되기 때문입니다. 예를 들어 GPU를 사용하는 pod의 경우 GPU가 있는 node에 배정해야 정상적으로 동작할 수 있을 것입니다. 이렇게 pod을 node에 배정할 수 있는 제약을 affinity라 하고, pod을 node에 배정할 수 없는 제약을 anti-affinity라 합니다. 스케줄러는 이뿐만 아니라 서로 밀접하게 연관된 pod들이 가까운, 혹은 같은 노드에 배정될 수 있도록 하는 등 복잡한 배치 전략을 사용합니다.</p>
<h2>kube-controller-manager</h2>
<p>컨트롤러 매니저는 노드가 다운되거나 pod의 레플리카를 관리하거나, 계정에 관한 관리를 하는 등 말 그대로 여러가지 관리를 수행합니다.</p>
<p>컨트롤러 매니저는 논리적으로는 노드 컨트롤러, 레플리케이션 컨트롤러, 엔트포인트 컨트롤러 등 여러 프로세스로 구성되어있지만 복잡성을 낮추기 위해 바이너리 자체는 하나이며 단일 프로세스 내에서 실행됩니다.</p>
<p>그 외에도 AWS 등 클라우드를 사용할 때 필요한 cloud-controller-manager등이 있지만 저는 베어메탈 위에 바로 클러스터를 구성할 것이므로 넘어가겠습니다.</p>
<p>다음으로 워커 노드에서 작동하는 컴포넌트들을 알아보겠습니다. 워커 노드에서는 다음과 같은 컴포넌트들이 작동합니다.</p>
<ul>
<li>kubelet</li>
<li>kube-proxy</li>
<li>dns</li>
</ul>
<h2>kubelet</h2>
<p>kubelet은 쿠버네티스에서 pod들을 관리하는 핵심 컴포넌트입니다. master와 worker에서 둘 다 실행되며, 어떤 노드를 클러스터에 등록하는 역할을 수행하는 것이 kubelet입니다. 앞서 설명한 kube-apiserver를 컨테이너에 띄우는 역할도 수행합니다.</p>
<p>관리자가 API 서버에 명령을 내리면 앞서 설명했던 kube-scheduler, kube-controller-manager를 통하여 어떤 노드에 어떤 pod들이 생성되어야 하는지 혹은 삭제되어야 하는지가 결정됩니다. 그러면 마스터 노드에서 각 워커 노드로 각 워커 노드에서 실행되어야 할 pod들의 상태를 보내주는데 이를 PodSpec이라 합니다. kubelet은 이 Podspec들을 받아서 거기에 맞게 pod들을 생성하고 삭제하는 역할을 합니다.</p>
<p>kubelet은 직접 apiserver에 접속해서 PodSpec을 받아올 수도 있지만 파일시스템이나 HTTP endpoint를 통해 PodSpec을 받아오거나 kubelet 자체가 서버가 되어 PodSpec을 포함하는 요청을 받을 수도 있습니다.</p>
<h2>kube-proxy</h2>
<p>쿠버네티스에서는 외부에 노출할 pod들을 service라는 개념으로 관리합니다. Service는 간단히 설명하자면 노드로 들어오는 트래픽을 적절히 관련된 pod으로 보내주는 proxy라 할 수 있습니다. kube-proxy는 바로 이 프록시를 실제로 구현하는 컴포넌트입니다.</p>
<h2>dns</h2>
<p>마지막으로 dns는 클러스터 내부에서 동적으로 변화하는 pod들을 ip주소가 아니라 domain name을 통해 통신할 수 있도록 해주는 클러스터 내부 dns 서버입니다.</p>
<h1>K3S</h1>
<p>K3S는 쿠버네티스 운영에 필요한 여러 프로세스들을 하나로 합쳐놓은 가벼운 버전의 쿠버네티스로, 임베디드나 IoT환경에 적합합니다. K3S는 K8S와 다르게 여러 컴포넌트들이 하나의 바이너리로 묶여 있으며 그래서 매우 쉽게 설치하고 실행할 수 있습니다. 그리고 클러스터 상태를 저장하는 데에 상기한 etcd 대신 sqlite가 사용됩니다. 아마 etcd가 너무 무거워서 그런 것이 아닌가 생각됩니다.</p>
<p>물론 저는 충분히 고성능의 머신을 사용하고 있기는 하지만 설치의 편의성과 전기요금을 감안하여 K3S를 사용하기로 결정했습니다.</p>
<blockquote>
<p>저번 포스트에서 작성했던 <code>Vagrantfile</code>을 사용하여 가상 머신을 생성한 경우, bootstrap.sh 스크립트를 통해 자동으로 K3S가 설치됩니다.</p>
</blockquote>
<h1>Lens</h1>
<p><a href="https://k8slens.dev/">Lens</a>는 쿠버네티스 클러스터 관리를 위한 프로그램으로 공식 도큐먼트에는 Kubernetes IDE라고 되어 있습니다. 실제로 매우 편리한 여러가지 기능을 제공합니다. 대표적으로 쿠버네티스 클러스터의 상태를 알 수 있는 멋진 대시보드를 제공합니다.</p>
<blockquote>
<p>물론 Lens같은 GUI 도구 대신 kubectl이라는 커맨드라인 도구를 통해서 클러스터를 관리할 수도 있습니다.</p>
</blockquote>
<h2>kubeconfig</h2>
<p>Lens든 kubectl이든 쿠버네티스의 apiserver에 접속하여 작업을 수행하려면 <code>kubeconfig</code> 파일이 필요합니다. <code>kubeconfig</code> 파일은 쿠버네티스 클러스터에 접속할 수 있는 인증 정보를 담고 있습니다. 물론 실제 파일 이름이 <code>kubeconfig</code>인 것은 아니며 그냥 쿠버네티스 인증을 위한 yaml파일을 그렇게 부르는 것입니다.</p>
<p>K3S의 경우 kubeconfig 파일은 <code>/etc/rancher/k3s/k3s.yaml</code> 경로에 있으며, 다음과 같이 생겼습니다.</p>
<pre><code class="language-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">clusters:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">cluster:</span>
    <span class="hljs-attr">certificate-authority-data:</span> <span class="hljs-string">보안상</span> <span class="hljs-string">생략</span>
    <span class="hljs-attr">server:</span> <span class="hljs-string">https://127.0.0.1:6443</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">default</span>
<span class="hljs-attr">contexts:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">context:</span>
    <span class="hljs-attr">cluster:</span> <span class="hljs-string">default</span>
    <span class="hljs-attr">user:</span> <span class="hljs-string">default</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">default</span>
<span class="hljs-attr">current-context:</span> <span class="hljs-string">default</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Config</span>
<span class="hljs-attr">preferences:</span> {}
<span class="hljs-attr">users:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">default</span>
  <span class="hljs-attr">user:</span>
    <span class="hljs-attr">client-certificate-data:</span> <span class="hljs-string">보안상</span> <span class="hljs-string">생략</span>
    <span class="hljs-attr">client-key-data:</span> <span class="hljs-string">보안상</span> <span class="hljs-string">생략</span>
</code></pre>
<p>kubectl을 사용하는 경우에는 이 파일을 다음과 같이 커맨드라인 인자로 넘겨주면 됩니다.</p>
<pre><code class="language-bash">kubectl --kubeconfig /etc/rancher/k3s/k3s.yaml get nodes
</code></pre>
<p>매번 이렇게 인자로 넘겨주는 것은 매우 번거로운 일이므로 다음과 같이 환경 변수로 설정해줄 수도 있습니다.</p>
<pre><code class="language-bash"><span class="hljs-built_in">export</span> KUBECONFIG=/etc/rancher/k3s/k3s.yaml
</code></pre>
<h2>Lens 연동하기</h2>
<p><img src="/imgs/a7292d4847704c6cee1373298dbb8269.png" alt="image-20210626034050664"></p>
<p>Lens를 실행시켜 보면 위 이미지와 같이 오른쪽 아래에 새 클러스터를 추가할 수 있는 버튼이 있습니다.</p>
<p><img src="/imgs/090b6fad0b4e8acff453f06d87393649.png" alt="image-20210626034135662"></p>
<p>버튼을 눌러 보면 이와 같이 <code>kubeconfig</code>파일을 선택하거나 텍스트 형식으로 붙여넣을 수 있는 옵션이 있습니다. 여기서 텍스트 형식을 선택하여 <code>kubeconfig</code>파일의 내용을 붙여넣어줍니다.</p>
<p>그런데 위의 <code>kubeconfig</code> 파일을 보면 <code>server</code> 부분이 <code>127.0.0.1</code>로 되어 있습니다. 그러므로 이 <code>kubeconfig</code>파일을 통해서는 <strong>오직 마스터 노드에서만 클러스터에 접속할 수 있습니다</strong>. 우리는 Lens를 쿠버네티스 클러스터에 포함되지 않은 다른 컴퓨터에서 동작시킬 것이므로 <strong>이 부분을 마스터 노드의 주소로 바꾸어 주어야 합니다</strong>. 저는 로컬 네트워크상에서 접속하였으므로 저 부분을 저번 포스팅에서 설정한 바와 같이 <code>172.30.1.100</code>으로 바꿔 주었습니다.</p>
<p>저는 처음에 Lens를 통해 접속할 때 이 간단한 것을 몰라서 다섯 시간도 넘게 헤맸습니다. 저는 <code>kubeconfig</code>파일은 권한이 포함된 중요한 파일이니까 수정하면 안 되는 줄 알고 SSH 프록시부터 해서 갖은 시도를 다 해 봤는데 잘 안 됐었습니다...</p>
<p>그러면 아래와 같이 쿠버네티스 클러스터에 접속할 수 있습니다.</p>
<p><img src="/imgs/1836dba3a603e9d35a4cdff11d6a52f4.png" alt="image-20210626034446233"></p>
<h2>Prometheus 설치</h2>
<p>그런데 아마 이 과정을 똑같이 따라오신 분들은 위 이미지와 같은 그래프들이 표시되지 않고 대신 에러 메시지가 표시될 것입니다. 왜냐하면 저 수치들은 Prometheus라는 패키지로부터 제공되는 것인데, 아직 해당 패키지를 클러스터에 설치하지 않았으므로 수치를 받아올 수가 없기 때문입니다. 그 경우 클러스터 아이콘을 우클릭하여 설정 페이지로 들어간 후 Metrics Stack 섹션의 Install 버튼을 눌러 주면 관련 패키지들이 자동으로 설치됩니다.</p>
<blockquote>
<p>패키지라는 표현이 올바른지 잘 모르겠습니다.</p>
</blockquote>
<p><img src="/imgs/b6ef7d6f7d4c37fd08e0ddf5c42449b2.png" alt="image-20210626034754935"></p>
<h3>Helm</h3>
<p>그런데 저는 알 수 없는 이유로 이게 제대로 설치가 안 됐어서 helm을 통해 수동으로 Prometheus를 설치해줬습니다. helm 이란 npm이나 pip과 같이 패키지 및 종속성들을 자동으로 설치할 수 있도록 해 주는 관리자입니다. helm 역시 클러스터 내부에 뭔가 설치를 해야 하므로 서버와 클라이언트 구조로 되어 있습니다. 사용자가 커맨드라인에서 사용하는 클라이언트 부분을 helm이라 하며 클러스터 내에서 클라이언트로부터 요청을 받아 실제로 작업을 수행하는 부분을 tiller라 합니다. Tiller는 이미 K3S 내부에 설치되어있기 때문에 helm만 설치해주면 됩니다. 아래 설치 메뉴얼을 따라, master node에 helm을 설치해줍니다.</p>
<p><a href="https://helm.sh/docs/intro/install/">https://helm.sh/docs/intro/install/</a></p>
<h3>Namespace</h3>
<p>쿠버네티스는 여러 서비스들을 논리적으로 격리하기 위해 namespace라는 개념을 제공합니다. 모니터링 관련된 것들을 따로 관리하기 위해 아래와 같이 monitor namespace를 생성해줍니다.</p>
<pre><code class="language-bash">kubectl create ns monitor
</code></pre>
<h3>Helm chart</h3>
<p>이제 아래와 같이 helm chart를 사용하여 Prometheus 설치를 진행해줍니다. 사실 저도 helm을 오늘 처음 써 봐서, helm chart가 뭔지 아직도 잘 모르겠습니다. 아마 <code>package.json</code>처럼 뭔가 패키지랑 그 종속성들을 다 정리해놓은 거라고 생각 중입니다.</p>
<p>먼저 helm 리포를 추가해줍니다.</p>
<pre><code class="language-bash">helm repo add stable https://charts.helm.sh/stable
</code></pre>
<p>그리고 Prometheus 설치를 진행합니다.</p>
<pre><code class="language-bash">helm install stable/prometheus-operator --generate-name --<span class="hljs-built_in">set</span> prometheusOperator.createCustomResource=<span class="hljs-literal">false</span> --namespace monitor
</code></pre>
<p>이후 다음 명령어를 통해 제대로 설치되었는지 확인해볼 수 있습니다.</p>
<pre><code class="language-bash">kubectl --namespace monitor get pods -l <span class="hljs-string">&quot;release=prometheus-operator-1624614050&quot;</span>
</code></pre>
<p>아래와 같이 뜨면 정상입니다.</p>
<pre><code>NAME                                                            READY   STATUS    RESTARTS   AGE
prometheus-operator-162461-operator-6664cc9bd6-trfp7            2/2     Running   0          9h
prometheus-operator-1624614050-prometheus-node-exporter-bd74t   1/1     Running   0          9h
</code></pre>
<blockquote>
<p>위에서 1624614050는 설치된 버전에 따라 다를 수 있습니다. 본인이 설치한 버전에 맞는 숫자로 바꿔주시면 됩니다.</p>
</blockquote>
<p>마지막으로 아래와 같이 port forwarding을 추가하여 프로메테우스를 확인해볼 수 있습니다. 이는 클러스터 내부에서 외부로 포트포워딩을 해 주는 과정입니다.</p>
<pre><code class="language-bash">kubectl port-forward  --namespace monitor $(kubectl get pod --namespace monitor --selector app=prometheus --output=jsonpath=<span class="hljs-string">&quot;{.items..metadata.name}&quot;</span>) 9090
</code></pre>
<p>이때 주의할 점은 이렇게 포트포워딩을 했다 하더라도 이는 오직 마스터 노드에서 <code>localhost</code>로만 접근이 가능하고 <code>172.30.1.100</code> 과 같은 <strong>로컬호스트가 아닌 아이피로는 접근이 불가능</strong>하다는 점입니다. 그러므로 이렇게 클러스터 내부 → master node로 포트포워딩을 한 후 다시 이를 SSH를 통해 master node → 사용 중인 컴퓨터로 proxy하고, 이후 사용 중인 컴퓨터의 브라우저에서 localhost로 접속해야만 합니다.</p>
<p>VSCode를 사용하여 master node에 접근 중이라면 아래와 같이 이 과정을 쉽게 수행할 수 있습니다.</p>
<p><img src="/imgs/83cdaeadc2fdbb443f3c7af23156f8f6.png" alt="image-20210626041417125"></p>
<p>이후 브라우저를 통해 접속해보면 아래와 같이 접속이 잘 이뤄집니다.</p>
<p><img src="/imgs/8b3fb103c4485a8313a6e237302fc41e.png" alt="image-20210626041704593"></p>
<h2>Lens와 Prometheus 연동</h2>
<p>마지막으로, Lens의 설정 페이지에서 아래와 같이 Prometheus를 설정해줍니다.</p>
<p>아마 초기에는 installation method가 Autodetect로 되어 있고 service address가 보이지 않을 텐데 installation method를 Prometheus Operator로 설정해주면 service address를 입력할 수 있는 칸이 표시됩니다.</p>
<p><img src="/imgs/784940cb4afaf721ee9d8d960786404e.png" alt="image-20210626042443126"></p>
<p>그러면 <strong>Lens 연동하기</strong> 섹션처럼 메인 화면에서 각종 metric들을 확인할 수 있습니다.</p>
<h1>Grafana</h1>
<p>그리고 위 방법으로 Prometheus를 설치하면 Grafana가 따라옵니다. Grafana는 오픈 소스 데이터 분석 및 시각화 툴로 이 경우 Prometheus로부터 데이터를 받아 이쁘게 시각화해줍니다. Grafana 역시 다음과 같이 포트포워딩을 해준 후 이를 다시 로컬로 proxy해주어야 합니다.</p>
<pre><code class="language-bash">kubectl port-forward --namespace monitor $(kubectl get pods -n monitor --selector app.kubernetes.io/name=grafana --output=jsonpath=<span class="hljs-string">&quot;{.items..metadata.name}&quot;</span>) 3000
</code></pre>
<p>이후 브라우저에서 3000번으로 접근하면 아래와 같은 로그인 화면을 볼 수 있습니다.</p>
<p><img src="/imgs/554ffd52c3123f62d03b3d49784004ef.png" alt="image-20210626042113074"></p>
<p>아이디와 패스워드를 <code>admin</code>, <code>prom-operator</code>를 입력해줍니다. 그러면 이와 같이 Prometheus로부터 수집된 다양한 metric들을 시각화하여 확인할 수 있습니다.</p>
<p><img src="/imgs/8072b312d72e7110622640a501444016.png" alt="image-20210626042247059"></p>
<h1>참고문헌</h1>
<ul>
<li><a href="http://www.dcasati.net/posts/installing-prometheus-on-kubernetes-v1.16.9/">http://www.dcasati.net/posts/installing-prometheus-on-kubernetes-v1.16.9/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Grafana">https://en.wikipedia.org/wiki/Grafana</a></li>
<li><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/">https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/</a></li>
<li><a href="https://kubernetes.io/docs/concepts/overview/components/">https://kubernetes.io/docs/concepts/overview/components/</a></li>
<li><a href="https://stackoverflow.com/questions/50352621/where-is-kube-apiserver-located">https://stackoverflow.com/questions/50352621/where-is-kube-apiserver-located</a></li>
<li><a href="https://kubernetes.io/ko/docs/concepts/overview/components/">https://kubernetes.io/ko/docs/concepts/overview/components/</a></li>
<li><a href="https://rancher.com/docs/rke/latest/en/kubeconfig/">https://rancher.com/docs/rke/latest/en/kubeconfig/</a></li>
<li><a href="https://k3s.io/">https://k3s.io/</a></li>
<li><a href="https://docs.k8slens.dev/main/">https://docs.k8slens.dev/main/</a></li>
<li><a href="https://rancher.com/docs/k3s/latest/en/cluster-access/">https://rancher.com/docs/k3s/latest/en/cluster-access/</a></li>
<li><a href="https://bcho.tistory.com/1270?category=731548">https://bcho.tistory.com/1270?category=731548</a></li>
<li><a href="https://kubernetes.io/docs/tasks/extend-kubernetes/http-proxy-access-api/">https://kubernetes.io/docs/tasks/extend-kubernetes/http-proxy-access-api/</a></li>
<li><a href="https://kubernetes.io/ko/docs/tasks/access-application-cluster/access-cluster">https://kubernetes.io/ko/docs/tasks/access-application-cluster/access-cluster/</a></li>
</ul>
<p>아래는 본 포스트에 작성하지는 않았지만, Web Dashboard를 띄우기 위해 찾아 본 내용입니다.</p>
<ul>
<li><a href="https://jogeum.net/22">https://jogeum.net/22</a></li>
<li><a href="https://kubernetes.io/ko/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/ko/docs/tasks/access-application-cluster/web-ui-dashboard/</a></li>
</ul>
<h1>TMI</h1>
<p>온갖 시행착오의 흔적들... 25일 새벽 2시부터 26일 새벽 4시(현재)까지 거의 450개 사이트에 방문... 여태 프로젝트들을 진행하면서 이렇게 많은 삽질을 했던 적이 없는 것 같아서 기념 삼아 남겨둡니다...</p>
<p><img src="/imgs/eafed43b22e7bd184a88382e50b0ff04.png" alt="image-20210626043921889"></p>
</main><h1>Posts in <!-- -->kubernetes<!-- --> category</h1><ul><li class="post_list__OlrZL"><a href="/posts/2021-09-18-k8s-5/">쿠버네티스 클러스터 구축[5] - Multi-Node</a></li><li class="post_list__OlrZL"><a href="/posts/2021-09-05-k8s-4/">쿠버네티스 클러스터 구축[4] - WildCard TLS with Let&#x27;sEncrypt</a></li><li class="post_list__OlrZL"><a href="/posts/2021-09-01-k8s-3/">쿠버네티스 클러스터 구축[3] - Traefik</a></li><li class="post_listSelected__vtK9Y"><a href="/posts/2021-06-25-k8s-2/">쿠버네티스 클러스터 구축[2] - Lens</a></li><li class="post_list__OlrZL"><a href="/posts/2021-06-25-k8s-1/">쿠버네티스 클러스터 구축[1] - 가상 머신</a></li></ul><div></div></div></main><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5695206410217978" data-ad-slot="9579212903" data-ad-format="auto" data-full-width-responsive="true"></ins><footer class="footer_footer__E_Uzl">© 2020 Copyright : Unknownpgr</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"쿠버네티스 클러스터 구축[2] - Lens","category":"kubernetes","date":"2021-06-25T19:42:33.030Z","postStr":"---\ntitle: 쿠버네티스 클러스터 구축[2] - Lens\ncategory: kubernetes\ndate: 2021-06-25T19:42:33.030Z\n\n---\n\n![Kubernetes](imgs/favicon.png) \n\n# K8S\n\nKubernetes는 여러 개의 머신 위에서 여러 개의 컨테이너들을 관리하기 위한 시스템입니다. 쿠버네티스는 여러 머신들을 하나의 클러스터로 묶어 관리하는데, 이 각각의 머신들을 노드(Node)라고 부릅니다.\n\n이 노드을 중 일부는 클러스터 전체를 관리하는 역할을 수행하는 master node이며 일부는 단순 작업을 수행하는 worker node입니다. 모든 클러스터에는 반드시 하나의 마스터 노드가 있어야 합니다.\n\n일반적으로는 보안상의 이유로 master node와 worker를 따로 구성하지만 저처럼 단일 머신만 가지고 있는 경우에는 한 노드가 master와 worker 역할을 동시에 수행할 수도 있습니다.\n\n이때 master node가 정지할 경우 worker node를 제어할 수가 없기 때문에 master node가 하나인 경우에는 마스터 노드가 단일 실패 지점 (single point of failure; SPOF)이 됩니다. 그래서 고가용성 (High Availability; HA) 구성을 하는 경우에는 마스터 노드를 여러 개로 구성하기도 합니다.\n\n아래 설명은 [쿠버네티스 공식 도큐먼트](https://kubernetes.io/ko/docs/concepts/overview/components/)를 참고했습니다.\n\n마스터 노드에는 다음과 같은 컴포넌트들이 실행됩니다. 이들은 간단하게 컨테이너 위에서 실행되는 프로세스들이라고 봐도 무방하겠습니다.\n\n- kube-apiserver\n- etcd\n- kube-scheduler\n- kube-controller-manager\n\n## kube-apiserver\n\nAPI Server는 쿠버네티스의 모든 명령을 처리하는 서버입니다. 여기로 REST API 형식으로 명령이 전달되면 쿠버네티스 클러스터에 그 명령이 반영됩니다. 이 api 서버 자체도 컨테이너 위에서 실행되며, 이 api 서버 자체를 여러 개 생성해서 로드밸런싱할 수도 있습니다.\n\n## etcd\n\netcd는 고가용성 key-value 저장소로 쿠버네티스의 모든 정보가 여기 저장됩니다.\n\n## kube-scheduler\n\n쿠버네티스에서는 컨테이너를 다룰 때 Pod이라는 단위를 사용합니다. Pod은 사실 컨테이너들의 묶음이지만 보통 Pod 하나에 컨테이너 하나만 있는 구조를 사용합니다. kube-scheduler는 이 pod을 어떤 node에 배정할지 결정해줍니다. 스케줄러가 필요한 이유는 pod을 아무 node에나 배정하면 안 되기 때문입니다. 예를 들어 GPU를 사용하는 pod의 경우 GPU가 있는 node에 배정해야 정상적으로 동작할 수 있을 것입니다. 이렇게 pod을 node에 배정할 수 있는 제약을 affinity라 하고, pod을 node에 배정할 수 없는 제약을 anti-affinity라 합니다. 스케줄러는 이뿐만 아니라 서로 밀접하게 연관된 pod들이 가까운, 혹은 같은 노드에 배정될 수 있도록 하는 등 복잡한 배치 전략을 사용합니다.\n\n## kube-controller-manager\n\n컨트롤러 매니저는 노드가 다운되거나 pod의 레플리카를 관리하거나, 계정에 관한 관리를 하는 등 말 그대로 여러가지 관리를 수행합니다.\n\n컨트롤러 매니저는 논리적으로는 노드 컨트롤러, 레플리케이션 컨트롤러, 엔트포인트 컨트롤러 등 여러 프로세스로 구성되어있지만 복잡성을 낮추기 위해 바이너리 자체는 하나이며 단일 프로세스 내에서 실행됩니다.\n\n그 외에도 AWS 등 클라우드를 사용할 때 필요한 cloud-controller-manager등이 있지만 저는 베어메탈 위에 바로 클러스터를 구성할 것이므로 넘어가겠습니다.\n\n다음으로 워커 노드에서 작동하는 컴포넌트들을 알아보겠습니다. 워커 노드에서는 다음과 같은 컴포넌트들이 작동합니다.\n\n- kubelet\n- kube-proxy\n- dns\n\n## kubelet\n\nkubelet은 쿠버네티스에서 pod들을 관리하는 핵심 컴포넌트입니다. master와 worker에서 둘 다 실행되며, 어떤 노드를 클러스터에 등록하는 역할을 수행하는 것이 kubelet입니다. 앞서 설명한 kube-apiserver를 컨테이너에 띄우는 역할도 수행합니다.\n\n관리자가 API 서버에 명령을 내리면 앞서 설명했던 kube-scheduler, kube-controller-manager를 통하여 어떤 노드에 어떤 pod들이 생성되어야 하는지 혹은 삭제되어야 하는지가 결정됩니다. 그러면 마스터 노드에서 각 워커 노드로 각 워커 노드에서 실행되어야 할 pod들의 상태를 보내주는데 이를 PodSpec이라 합니다. kubelet은 이 Podspec들을 받아서 거기에 맞게 pod들을 생성하고 삭제하는 역할을 합니다.\n\nkubelet은 직접 apiserver에 접속해서 PodSpec을 받아올 수도 있지만 파일시스템이나 HTTP endpoint를 통해 PodSpec을 받아오거나 kubelet 자체가 서버가 되어 PodSpec을 포함하는 요청을 받을 수도 있습니다.\n\n## kube-proxy\n\n쿠버네티스에서는 외부에 노출할 pod들을 service라는 개념으로 관리합니다. Service는 간단히 설명하자면 노드로 들어오는 트래픽을 적절히 관련된 pod으로 보내주는 proxy라 할 수 있습니다. kube-proxy는 바로 이 프록시를 실제로 구현하는 컴포넌트입니다.\n\n## dns\n\n마지막으로 dns는 클러스터 내부에서 동적으로 변화하는 pod들을 ip주소가 아니라 domain name을 통해 통신할 수 있도록 해주는 클러스터 내부 dns 서버입니다.\n\n# K3S\n\nK3S는 쿠버네티스 운영에 필요한 여러 프로세스들을 하나로 합쳐놓은 가벼운 버전의 쿠버네티스로, 임베디드나 IoT환경에 적합합니다. K3S는 K8S와 다르게 여러 컴포넌트들이 하나의 바이너리로 묶여 있으며 그래서 매우 쉽게 설치하고 실행할 수 있습니다. 그리고 클러스터 상태를 저장하는 데에 상기한 etcd 대신 sqlite가 사용됩니다. 아마 etcd가 너무 무거워서 그런 것이 아닌가 생각됩니다.\n\n물론 저는 충분히 고성능의 머신을 사용하고 있기는 하지만 설치의 편의성과 전기요금을 감안하여 K3S를 사용하기로 결정했습니다.\n\n\u003e 저번 포스트에서 작성했던 `Vagrantfile`을 사용하여 가상 머신을 생성한 경우, bootstrap.sh 스크립트를 통해 자동으로 K3S가 설치됩니다.\n\n# Lens\n\n[Lens](https://k8slens.dev/)는 쿠버네티스 클러스터 관리를 위한 프로그램으로 공식 도큐먼트에는 Kubernetes IDE라고 되어 있습니다. 실제로 매우 편리한 여러가지 기능을 제공합니다. 대표적으로 쿠버네티스 클러스터의 상태를 알 수 있는 멋진 대시보드를 제공합니다.\n\n\u003e 물론 Lens같은 GUI 도구 대신 kubectl이라는 커맨드라인 도구를 통해서 클러스터를 관리할 수도 있습니다.\n\n## kubeconfig\n\nLens든 kubectl이든 쿠버네티스의 apiserver에 접속하여 작업을 수행하려면 `kubeconfig` 파일이 필요합니다. `kubeconfig` 파일은 쿠버네티스 클러스터에 접속할 수 있는 인증 정보를 담고 있습니다. 물론 실제 파일 이름이 `kubeconfig`인 것은 아니며 그냥 쿠버네티스 인증을 위한 yaml파일을 그렇게 부르는 것입니다.\n\nK3S의 경우 kubeconfig 파일은 `/etc/rancher/k3s/k3s.yaml` 경로에 있으며, 다음과 같이 생겼습니다.\n\n```yaml\napiVersion: v1\nclusters:\n- cluster:\n    certificate-authority-data: 보안상 생략\n    server: https://127.0.0.1:6443\n  name: default\ncontexts:\n- context:\n    cluster: default\n    user: default\n  name: default\ncurrent-context: default\nkind: Config\npreferences: {}\nusers:\n- name: default\n  user:\n    client-certificate-data: 보안상 생략\n    client-key-data: 보안상 생략\n```\n\nkubectl을 사용하는 경우에는 이 파일을 다음과 같이 커맨드라인 인자로 넘겨주면 됩니다.\n\n```bash\nkubectl --kubeconfig /etc/rancher/k3s/k3s.yaml get nodes\n```\n\n매번 이렇게 인자로 넘겨주는 것은 매우 번거로운 일이므로 다음과 같이 환경 변수로 설정해줄 수도 있습니다.\n\n```bash\nexport KUBECONFIG=/etc/rancher/k3s/k3s.yaml\n```\n\n## Lens 연동하기\n\n![image-20210626034050664](imgs/image-20210626034050664.png)\n\nLens를 실행시켜 보면 위 이미지와 같이 오른쪽 아래에 새 클러스터를 추가할 수 있는 버튼이 있습니다.\n\n![image-20210626034135662](imgs/image-20210626034135662.png)\n\n버튼을 눌러 보면 이와 같이 `kubeconfig`파일을 선택하거나 텍스트 형식으로 붙여넣을 수 있는 옵션이 있습니다. 여기서 텍스트 형식을 선택하여 `kubeconfig`파일의 내용을 붙여넣어줍니다.\n\n그런데 위의 `kubeconfig` 파일을 보면 `server` 부분이 `127.0.0.1`로 되어 있습니다. 그러므로 이 `kubeconfig`파일을 통해서는 **오직 마스터 노드에서만 클러스터에 접속할 수 있습니다**. 우리는 Lens를 쿠버네티스 클러스터에 포함되지 않은 다른 컴퓨터에서 동작시킬 것이므로 **이 부분을 마스터 노드의 주소로 바꾸어 주어야 합니다**. 저는 로컬 네트워크상에서 접속하였으므로 저 부분을 저번 포스팅에서 설정한 바와 같이 `172.30.1.100`으로 바꿔 주었습니다.\n\n저는 처음에 Lens를 통해 접속할 때 이 간단한 것을 몰라서 다섯 시간도 넘게 헤맸습니다. 저는 `kubeconfig`파일은 권한이 포함된 중요한 파일이니까 수정하면 안 되는 줄 알고 SSH 프록시부터 해서 갖은 시도를 다 해 봤는데 잘 안 됐었습니다...\n\n그러면 아래와 같이 쿠버네티스 클러스터에 접속할 수 있습니다.\n\n![image-20210626034446233](imgs/image-20210626034446233.png)\n\n## Prometheus 설치\n\n그런데 아마 이 과정을 똑같이 따라오신 분들은 위 이미지와 같은 그래프들이 표시되지 않고 대신 에러 메시지가 표시될 것입니다. 왜냐하면 저 수치들은 Prometheus라는 패키지로부터 제공되는 것인데, 아직 해당 패키지를 클러스터에 설치하지 않았으므로 수치를 받아올 수가 없기 때문입니다. 그 경우 클러스터 아이콘을 우클릭하여 설정 페이지로 들어간 후 Metrics Stack 섹션의 Install 버튼을 눌러 주면 관련 패키지들이 자동으로 설치됩니다.\n\n\u003e 패키지라는 표현이 올바른지 잘 모르겠습니다.\n\n![image-20210626034754935](imgs/image-20210626034754935.png)\n\n### Helm\n\n그런데 저는 알 수 없는 이유로 이게 제대로 설치가 안 됐어서 helm을 통해 수동으로 Prometheus를 설치해줬습니다. helm 이란 npm이나 pip과 같이 패키지 및 종속성들을 자동으로 설치할 수 있도록 해 주는 관리자입니다. helm 역시 클러스터 내부에 뭔가 설치를 해야 하므로 서버와 클라이언트 구조로 되어 있습니다. 사용자가 커맨드라인에서 사용하는 클라이언트 부분을 helm이라 하며 클러스터 내에서 클라이언트로부터 요청을 받아 실제로 작업을 수행하는 부분을 tiller라 합니다. Tiller는 이미 K3S 내부에 설치되어있기 때문에 helm만 설치해주면 됩니다. 아래 설치 메뉴얼을 따라, master node에 helm을 설치해줍니다.\n\n[https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)\n\n### Namespace\n\n쿠버네티스는 여러 서비스들을 논리적으로 격리하기 위해 namespace라는 개념을 제공합니다. 모니터링 관련된 것들을 따로 관리하기 위해 아래와 같이 monitor namespace를 생성해줍니다.\n\n```bash\nkubectl create ns monitor\n```\n\n### Helm chart\n\n이제 아래와 같이 helm chart를 사용하여 Prometheus 설치를 진행해줍니다. 사실 저도 helm을 오늘 처음 써 봐서, helm chart가 뭔지 아직도 잘 모르겠습니다. 아마 `package.json`처럼 뭔가 패키지랑 그 종속성들을 다 정리해놓은 거라고 생각 중입니다.\n\n먼저 helm 리포를 추가해줍니다.\n\n```bash\nhelm repo add stable https://charts.helm.sh/stable\n```\n\n그리고 Prometheus 설치를 진행합니다.\n\n```bash\nhelm install stable/prometheus-operator --generate-name --set prometheusOperator.createCustomResource=false --namespace monitor\n```\n\n이후 다음 명령어를 통해 제대로 설치되었는지 확인해볼 수 있습니다.\n\n```bash\nkubectl --namespace monitor get pods -l \"release=prometheus-operator-1624614050\"\n```\n\n아래와 같이 뜨면 정상입니다.\n\n```\nNAME                                                            READY   STATUS    RESTARTS   AGE\nprometheus-operator-162461-operator-6664cc9bd6-trfp7            2/2     Running   0          9h\nprometheus-operator-1624614050-prometheus-node-exporter-bd74t   1/1     Running   0          9h\n```\n\n\u003e 위에서 1624614050는 설치된 버전에 따라 다를 수 있습니다. 본인이 설치한 버전에 맞는 숫자로 바꿔주시면 됩니다.\n\n마지막으로 아래와 같이 port forwarding을 추가하여 프로메테우스를 확인해볼 수 있습니다. 이는 클러스터 내부에서 외부로 포트포워딩을 해 주는 과정입니다.\n\n```bash\nkubectl port-forward  --namespace monitor $(kubectl get pod --namespace monitor --selector app=prometheus --output=jsonpath=\"{.items..metadata.name}\") 9090\n```\n\n이때 주의할 점은 이렇게 포트포워딩을 했다 하더라도 이는 오직 마스터 노드에서 `localhost`로만 접근이 가능하고 `172.30.1.100` 과 같은 **로컬호스트가 아닌 아이피로는 접근이 불가능**하다는 점입니다. 그러므로 이렇게 클러스터 내부 → master node로 포트포워딩을 한 후 다시 이를 SSH를 통해 master node → 사용 중인 컴퓨터로 proxy하고, 이후 사용 중인 컴퓨터의 브라우저에서 localhost로 접속해야만 합니다.\n\nVSCode를 사용하여 master node에 접근 중이라면 아래와 같이 이 과정을 쉽게 수행할 수 있습니다.\n\n![image-20210626041417125](imgs/image-20210626041417125.png)\n\n이후 브라우저를 통해 접속해보면 아래와 같이 접속이 잘 이뤄집니다.\n\n![image-20210626041704593](imgs/image-20210626041704593.png)\n\n## Lens와 Prometheus 연동\n\n마지막으로, Lens의 설정 페이지에서 아래와 같이 Prometheus를 설정해줍니다.\n\n아마 초기에는 installation method가 Autodetect로 되어 있고 service address가 보이지 않을 텐데 installation method를 Prometheus Operator로 설정해주면 service address를 입력할 수 있는 칸이 표시됩니다.\n\n![image-20210626042443126](imgs/image-20210626042443126.png)\n\n그러면 **Lens 연동하기** 섹션처럼 메인 화면에서 각종 metric들을 확인할 수 있습니다.\n\n# Grafana\n\n그리고 위 방법으로 Prometheus를 설치하면 Grafana가 따라옵니다. Grafana는 오픈 소스 데이터 분석 및 시각화 툴로 이 경우 Prometheus로부터 데이터를 받아 이쁘게 시각화해줍니다. Grafana 역시 다음과 같이 포트포워딩을 해준 후 이를 다시 로컬로 proxy해주어야 합니다.\n\n```bash\nkubectl port-forward --namespace monitor $(kubectl get pods -n monitor --selector app.kubernetes.io/name=grafana --output=jsonpath=\"{.items..metadata.name}\") 3000\n```\n\n이후 브라우저에서 3000번으로 접근하면 아래와 같은 로그인 화면을 볼 수 있습니다.\n\n![image-20210626042113074](imgs/image-20210626042113074.png)\n\n아이디와 패스워드를 `admin`, `prom-operator`를 입력해줍니다. 그러면 이와 같이 Prometheus로부터 수집된 다양한 metric들을 시각화하여 확인할 수 있습니다.\n\n![image-20210626042247059](imgs/image-20210626042247059.png)\n\n# 참고문헌\n\n- [http://www.dcasati.net/posts/installing-prometheus-on-kubernetes-v1.16.9/](http://www.dcasati.net/posts/installing-prometheus-on-kubernetes-v1.16.9/)\n- [https://en.wikipedia.org/wiki/Grafana](https://en.wikipedia.org/wiki/Grafana)\n- [https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/)\n- [https://kubernetes.io/docs/concepts/overview/components/](https://kubernetes.io/docs/concepts/overview/components/)\n- [https://stackoverflow.com/questions/50352621/where-is-kube-apiserver-located](https://stackoverflow.com/questions/50352621/where-is-kube-apiserver-located)\n- [https://kubernetes.io/ko/docs/concepts/overview/components/](https://kubernetes.io/ko/docs/concepts/overview/components/)\n- [https://rancher.com/docs/rke/latest/en/kubeconfig/](https://rancher.com/docs/rke/latest/en/kubeconfig/)\n- [https://k3s.io/](https://k3s.io/)\n- [https://docs.k8slens.dev/main/](https://docs.k8slens.dev/main/)\n- [https://rancher.com/docs/k3s/latest/en/cluster-access/](https://rancher.com/docs/k3s/latest/en/cluster-access/)\n- [https://bcho.tistory.com/1270?category=731548](https://bcho.tistory.com/1270?category=731548)\n- [https://kubernetes.io/docs/tasks/extend-kubernetes/http-proxy-access-api/](https://kubernetes.io/docs/tasks/extend-kubernetes/http-proxy-access-api/)\n- [https://kubernetes.io/ko/docs/tasks/access-application-cluster/access-cluster/](https://kubernetes.io/ko/docs/tasks/access-application-cluster/access-cluster)\n\n아래는 본 포스트에 작성하지는 않았지만, Web Dashboard를 띄우기 위해 찾아 본 내용입니다.\n\n- [https://jogeum.net/22](https://jogeum.net/22)\n- [https://kubernetes.io/ko/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/ko/docs/tasks/access-application-cluster/web-ui-dashboard/)\n\n# TMI\n\n온갖 시행착오의 흔적들... 25일 새벽 2시부터 26일 새벽 4시(현재)까지 거의 450개 사이트에 방문... 여태 프로젝트들을 진행하면서 이렇게 많은 삽질을 했던 적이 없는 것 같아서 기념 삼아 남겨둡니다...\n\n![image-20210626043921889](imgs/image-20210626043921889.png)","html":"\u003cp\u003e\u003cimg src=\"/imgs/6a347940f064146525be36b805414901.png\" alt=\"Kubernetes\"\u003e\u003c/p\u003e\n\u003ch1\u003eK8S\u003c/h1\u003e\n\u003cp\u003eKubernetes는 여러 개의 머신 위에서 여러 개의 컨테이너들을 관리하기 위한 시스템입니다. 쿠버네티스는 여러 머신들을 하나의 클러스터로 묶어 관리하는데, 이 각각의 머신들을 노드(Node)라고 부릅니다.\u003c/p\u003e\n\u003cp\u003e이 노드을 중 일부는 클러스터 전체를 관리하는 역할을 수행하는 master node이며 일부는 단순 작업을 수행하는 worker node입니다. 모든 클러스터에는 반드시 하나의 마스터 노드가 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e일반적으로는 보안상의 이유로 master node와 worker를 따로 구성하지만 저처럼 단일 머신만 가지고 있는 경우에는 한 노드가 master와 worker 역할을 동시에 수행할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e이때 master node가 정지할 경우 worker node를 제어할 수가 없기 때문에 master node가 하나인 경우에는 마스터 노드가 단일 실패 지점 (single point of failure; SPOF)이 됩니다. 그래서 고가용성 (High Availability; HA) 구성을 하는 경우에는 마스터 노드를 여러 개로 구성하기도 합니다.\u003c/p\u003e\n\u003cp\u003e아래 설명은 \u003ca href=\"https://kubernetes.io/ko/docs/concepts/overview/components/\"\u003e쿠버네티스 공식 도큐먼트\u003c/a\u003e를 참고했습니다.\u003c/p\u003e\n\u003cp\u003e마스터 노드에는 다음과 같은 컴포넌트들이 실행됩니다. 이들은 간단하게 컨테이너 위에서 실행되는 프로세스들이라고 봐도 무방하겠습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ekube-apiserver\u003c/li\u003e\n\u003cli\u003eetcd\u003c/li\u003e\n\u003cli\u003ekube-scheduler\u003c/li\u003e\n\u003cli\u003ekube-controller-manager\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003ekube-apiserver\u003c/h2\u003e\n\u003cp\u003eAPI Server는 쿠버네티스의 모든 명령을 처리하는 서버입니다. 여기로 REST API 형식으로 명령이 전달되면 쿠버네티스 클러스터에 그 명령이 반영됩니다. 이 api 서버 자체도 컨테이너 위에서 실행되며, 이 api 서버 자체를 여러 개 생성해서 로드밸런싱할 수도 있습니다.\u003c/p\u003e\n\u003ch2\u003eetcd\u003c/h2\u003e\n\u003cp\u003eetcd는 고가용성 key-value 저장소로 쿠버네티스의 모든 정보가 여기 저장됩니다.\u003c/p\u003e\n\u003ch2\u003ekube-scheduler\u003c/h2\u003e\n\u003cp\u003e쿠버네티스에서는 컨테이너를 다룰 때 Pod이라는 단위를 사용합니다. Pod은 사실 컨테이너들의 묶음이지만 보통 Pod 하나에 컨테이너 하나만 있는 구조를 사용합니다. kube-scheduler는 이 pod을 어떤 node에 배정할지 결정해줍니다. 스케줄러가 필요한 이유는 pod을 아무 node에나 배정하면 안 되기 때문입니다. 예를 들어 GPU를 사용하는 pod의 경우 GPU가 있는 node에 배정해야 정상적으로 동작할 수 있을 것입니다. 이렇게 pod을 node에 배정할 수 있는 제약을 affinity라 하고, pod을 node에 배정할 수 없는 제약을 anti-affinity라 합니다. 스케줄러는 이뿐만 아니라 서로 밀접하게 연관된 pod들이 가까운, 혹은 같은 노드에 배정될 수 있도록 하는 등 복잡한 배치 전략을 사용합니다.\u003c/p\u003e\n\u003ch2\u003ekube-controller-manager\u003c/h2\u003e\n\u003cp\u003e컨트롤러 매니저는 노드가 다운되거나 pod의 레플리카를 관리하거나, 계정에 관한 관리를 하는 등 말 그대로 여러가지 관리를 수행합니다.\u003c/p\u003e\n\u003cp\u003e컨트롤러 매니저는 논리적으로는 노드 컨트롤러, 레플리케이션 컨트롤러, 엔트포인트 컨트롤러 등 여러 프로세스로 구성되어있지만 복잡성을 낮추기 위해 바이너리 자체는 하나이며 단일 프로세스 내에서 실행됩니다.\u003c/p\u003e\n\u003cp\u003e그 외에도 AWS 등 클라우드를 사용할 때 필요한 cloud-controller-manager등이 있지만 저는 베어메탈 위에 바로 클러스터를 구성할 것이므로 넘어가겠습니다.\u003c/p\u003e\n\u003cp\u003e다음으로 워커 노드에서 작동하는 컴포넌트들을 알아보겠습니다. 워커 노드에서는 다음과 같은 컴포넌트들이 작동합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ekubelet\u003c/li\u003e\n\u003cli\u003ekube-proxy\u003c/li\u003e\n\u003cli\u003edns\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003ekubelet\u003c/h2\u003e\n\u003cp\u003ekubelet은 쿠버네티스에서 pod들을 관리하는 핵심 컴포넌트입니다. master와 worker에서 둘 다 실행되며, 어떤 노드를 클러스터에 등록하는 역할을 수행하는 것이 kubelet입니다. 앞서 설명한 kube-apiserver를 컨테이너에 띄우는 역할도 수행합니다.\u003c/p\u003e\n\u003cp\u003e관리자가 API 서버에 명령을 내리면 앞서 설명했던 kube-scheduler, kube-controller-manager를 통하여 어떤 노드에 어떤 pod들이 생성되어야 하는지 혹은 삭제되어야 하는지가 결정됩니다. 그러면 마스터 노드에서 각 워커 노드로 각 워커 노드에서 실행되어야 할 pod들의 상태를 보내주는데 이를 PodSpec이라 합니다. kubelet은 이 Podspec들을 받아서 거기에 맞게 pod들을 생성하고 삭제하는 역할을 합니다.\u003c/p\u003e\n\u003cp\u003ekubelet은 직접 apiserver에 접속해서 PodSpec을 받아올 수도 있지만 파일시스템이나 HTTP endpoint를 통해 PodSpec을 받아오거나 kubelet 자체가 서버가 되어 PodSpec을 포함하는 요청을 받을 수도 있습니다.\u003c/p\u003e\n\u003ch2\u003ekube-proxy\u003c/h2\u003e\n\u003cp\u003e쿠버네티스에서는 외부에 노출할 pod들을 service라는 개념으로 관리합니다. Service는 간단히 설명하자면 노드로 들어오는 트래픽을 적절히 관련된 pod으로 보내주는 proxy라 할 수 있습니다. kube-proxy는 바로 이 프록시를 실제로 구현하는 컴포넌트입니다.\u003c/p\u003e\n\u003ch2\u003edns\u003c/h2\u003e\n\u003cp\u003e마지막으로 dns는 클러스터 내부에서 동적으로 변화하는 pod들을 ip주소가 아니라 domain name을 통해 통신할 수 있도록 해주는 클러스터 내부 dns 서버입니다.\u003c/p\u003e\n\u003ch1\u003eK3S\u003c/h1\u003e\n\u003cp\u003eK3S는 쿠버네티스 운영에 필요한 여러 프로세스들을 하나로 합쳐놓은 가벼운 버전의 쿠버네티스로, 임베디드나 IoT환경에 적합합니다. K3S는 K8S와 다르게 여러 컴포넌트들이 하나의 바이너리로 묶여 있으며 그래서 매우 쉽게 설치하고 실행할 수 있습니다. 그리고 클러스터 상태를 저장하는 데에 상기한 etcd 대신 sqlite가 사용됩니다. 아마 etcd가 너무 무거워서 그런 것이 아닌가 생각됩니다.\u003c/p\u003e\n\u003cp\u003e물론 저는 충분히 고성능의 머신을 사용하고 있기는 하지만 설치의 편의성과 전기요금을 감안하여 K3S를 사용하기로 결정했습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e저번 포스트에서 작성했던 \u003ccode\u003eVagrantfile\u003c/code\u003e을 사용하여 가상 머신을 생성한 경우, bootstrap.sh 스크립트를 통해 자동으로 K3S가 설치됩니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003eLens\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://k8slens.dev/\"\u003eLens\u003c/a\u003e는 쿠버네티스 클러스터 관리를 위한 프로그램으로 공식 도큐먼트에는 Kubernetes IDE라고 되어 있습니다. 실제로 매우 편리한 여러가지 기능을 제공합니다. 대표적으로 쿠버네티스 클러스터의 상태를 알 수 있는 멋진 대시보드를 제공합니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e물론 Lens같은 GUI 도구 대신 kubectl이라는 커맨드라인 도구를 통해서 클러스터를 관리할 수도 있습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ekubeconfig\u003c/h2\u003e\n\u003cp\u003eLens든 kubectl이든 쿠버네티스의 apiserver에 접속하여 작업을 수행하려면 \u003ccode\u003ekubeconfig\u003c/code\u003e 파일이 필요합니다. \u003ccode\u003ekubeconfig\u003c/code\u003e 파일은 쿠버네티스 클러스터에 접속할 수 있는 인증 정보를 담고 있습니다. 물론 실제 파일 이름이 \u003ccode\u003ekubeconfig\u003c/code\u003e인 것은 아니며 그냥 쿠버네티스 인증을 위한 yaml파일을 그렇게 부르는 것입니다.\u003c/p\u003e\n\u003cp\u003eK3S의 경우 kubeconfig 파일은 \u003ccode\u003e/etc/rancher/k3s/k3s.yaml\u003c/code\u003e 경로에 있으며, 다음과 같이 생겼습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ev1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eclusters:\u003c/span\u003e\n\u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecluster:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ecertificate-authority-data:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e보안상\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e생략\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eserver:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ehttps://127.0.0.1:6443\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edefault\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003econtexts:\u003c/span\u003e\n\u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtext:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ecluster:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edefault\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003euser:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edefault\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edefault\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ecurrent-context:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edefault\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eConfig\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003epreferences:\u003c/span\u003e {}\n\u003cspan class=\"hljs-attr\"\u003eusers:\u003c/span\u003e\n\u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edefault\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003euser:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eclient-certificate-data:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e보안상\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e생략\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eclient-key-data:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e보안상\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e생략\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ekubectl을 사용하는 경우에는 이 파일을 다음과 같이 커맨드라인 인자로 넘겨주면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ekubectl --kubeconfig /etc/rancher/k3s/k3s.yaml get nodes\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e매번 이렇게 인자로 넘겨주는 것은 매우 번거로운 일이므로 다음과 같이 환경 변수로 설정해줄 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e KUBECONFIG=/etc/rancher/k3s/k3s.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eLens 연동하기\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/a7292d4847704c6cee1373298dbb8269.png\" alt=\"image-20210626034050664\"\u003e\u003c/p\u003e\n\u003cp\u003eLens를 실행시켜 보면 위 이미지와 같이 오른쪽 아래에 새 클러스터를 추가할 수 있는 버튼이 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/090b6fad0b4e8acff453f06d87393649.png\" alt=\"image-20210626034135662\"\u003e\u003c/p\u003e\n\u003cp\u003e버튼을 눌러 보면 이와 같이 \u003ccode\u003ekubeconfig\u003c/code\u003e파일을 선택하거나 텍스트 형식으로 붙여넣을 수 있는 옵션이 있습니다. 여기서 텍스트 형식을 선택하여 \u003ccode\u003ekubeconfig\u003c/code\u003e파일의 내용을 붙여넣어줍니다.\u003c/p\u003e\n\u003cp\u003e그런데 위의 \u003ccode\u003ekubeconfig\u003c/code\u003e 파일을 보면 \u003ccode\u003eserver\u003c/code\u003e 부분이 \u003ccode\u003e127.0.0.1\u003c/code\u003e로 되어 있습니다. 그러므로 이 \u003ccode\u003ekubeconfig\u003c/code\u003e파일을 통해서는 \u003cstrong\u003e오직 마스터 노드에서만 클러스터에 접속할 수 있습니다\u003c/strong\u003e. 우리는 Lens를 쿠버네티스 클러스터에 포함되지 않은 다른 컴퓨터에서 동작시킬 것이므로 \u003cstrong\u003e이 부분을 마스터 노드의 주소로 바꾸어 주어야 합니다\u003c/strong\u003e. 저는 로컬 네트워크상에서 접속하였으므로 저 부분을 저번 포스팅에서 설정한 바와 같이 \u003ccode\u003e172.30.1.100\u003c/code\u003e으로 바꿔 주었습니다.\u003c/p\u003e\n\u003cp\u003e저는 처음에 Lens를 통해 접속할 때 이 간단한 것을 몰라서 다섯 시간도 넘게 헤맸습니다. 저는 \u003ccode\u003ekubeconfig\u003c/code\u003e파일은 권한이 포함된 중요한 파일이니까 수정하면 안 되는 줄 알고 SSH 프록시부터 해서 갖은 시도를 다 해 봤는데 잘 안 됐었습니다...\u003c/p\u003e\n\u003cp\u003e그러면 아래와 같이 쿠버네티스 클러스터에 접속할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/1836dba3a603e9d35a4cdff11d6a52f4.png\" alt=\"image-20210626034446233\"\u003e\u003c/p\u003e\n\u003ch2\u003ePrometheus 설치\u003c/h2\u003e\n\u003cp\u003e그런데 아마 이 과정을 똑같이 따라오신 분들은 위 이미지와 같은 그래프들이 표시되지 않고 대신 에러 메시지가 표시될 것입니다. 왜냐하면 저 수치들은 Prometheus라는 패키지로부터 제공되는 것인데, 아직 해당 패키지를 클러스터에 설치하지 않았으므로 수치를 받아올 수가 없기 때문입니다. 그 경우 클러스터 아이콘을 우클릭하여 설정 페이지로 들어간 후 Metrics Stack 섹션의 Install 버튼을 눌러 주면 관련 패키지들이 자동으로 설치됩니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e패키지라는 표현이 올바른지 잘 모르겠습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/b6ef7d6f7d4c37fd08e0ddf5c42449b2.png\" alt=\"image-20210626034754935\"\u003e\u003c/p\u003e\n\u003ch3\u003eHelm\u003c/h3\u003e\n\u003cp\u003e그런데 저는 알 수 없는 이유로 이게 제대로 설치가 안 됐어서 helm을 통해 수동으로 Prometheus를 설치해줬습니다. helm 이란 npm이나 pip과 같이 패키지 및 종속성들을 자동으로 설치할 수 있도록 해 주는 관리자입니다. helm 역시 클러스터 내부에 뭔가 설치를 해야 하므로 서버와 클라이언트 구조로 되어 있습니다. 사용자가 커맨드라인에서 사용하는 클라이언트 부분을 helm이라 하며 클러스터 내에서 클라이언트로부터 요청을 받아 실제로 작업을 수행하는 부분을 tiller라 합니다. Tiller는 이미 K3S 내부에 설치되어있기 때문에 helm만 설치해주면 됩니다. 아래 설치 메뉴얼을 따라, master node에 helm을 설치해줍니다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://helm.sh/docs/intro/install/\"\u003ehttps://helm.sh/docs/intro/install/\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003eNamespace\u003c/h3\u003e\n\u003cp\u003e쿠버네티스는 여러 서비스들을 논리적으로 격리하기 위해 namespace라는 개념을 제공합니다. 모니터링 관련된 것들을 따로 관리하기 위해 아래와 같이 monitor namespace를 생성해줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ekubectl create ns monitor\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eHelm chart\u003c/h3\u003e\n\u003cp\u003e이제 아래와 같이 helm chart를 사용하여 Prometheus 설치를 진행해줍니다. 사실 저도 helm을 오늘 처음 써 봐서, helm chart가 뭔지 아직도 잘 모르겠습니다. 아마 \u003ccode\u003epackage.json\u003c/code\u003e처럼 뭔가 패키지랑 그 종속성들을 다 정리해놓은 거라고 생각 중입니다.\u003c/p\u003e\n\u003cp\u003e먼저 helm 리포를 추가해줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ehelm repo add stable https://charts.helm.sh/stable\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 Prometheus 설치를 진행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ehelm install stable/prometheus-operator --generate-name --\u003cspan class=\"hljs-built_in\"\u003eset\u003c/span\u003e prometheusOperator.createCustomResource=\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e --namespace monitor\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이후 다음 명령어를 통해 제대로 설치되었는지 확인해볼 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ekubectl --namespace monitor get pods -l \u003cspan class=\"hljs-string\"\u003e\u0026quot;release=prometheus-operator-1624614050\u0026quot;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래와 같이 뜨면 정상입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eNAME                                                            READY   STATUS    RESTARTS   AGE\nprometheus-operator-162461-operator-6664cc9bd6-trfp7            2/2     Running   0          9h\nprometheus-operator-1624614050-prometheus-node-exporter-bd74t   1/1     Running   0          9h\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e위에서 1624614050는 설치된 버전에 따라 다를 수 있습니다. 본인이 설치한 버전에 맞는 숫자로 바꿔주시면 됩니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e마지막으로 아래와 같이 port forwarding을 추가하여 프로메테우스를 확인해볼 수 있습니다. 이는 클러스터 내부에서 외부로 포트포워딩을 해 주는 과정입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ekubectl port-forward  --namespace monitor $(kubectl get pod --namespace monitor --selector app=prometheus --output=jsonpath=\u003cspan class=\"hljs-string\"\u003e\u0026quot;{.items..metadata.name}\u0026quot;\u003c/span\u003e) 9090\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이때 주의할 점은 이렇게 포트포워딩을 했다 하더라도 이는 오직 마스터 노드에서 \u003ccode\u003elocalhost\u003c/code\u003e로만 접근이 가능하고 \u003ccode\u003e172.30.1.100\u003c/code\u003e 과 같은 \u003cstrong\u003e로컬호스트가 아닌 아이피로는 접근이 불가능\u003c/strong\u003e하다는 점입니다. 그러므로 이렇게 클러스터 내부 → master node로 포트포워딩을 한 후 다시 이를 SSH를 통해 master node → 사용 중인 컴퓨터로 proxy하고, 이후 사용 중인 컴퓨터의 브라우저에서 localhost로 접속해야만 합니다.\u003c/p\u003e\n\u003cp\u003eVSCode를 사용하여 master node에 접근 중이라면 아래와 같이 이 과정을 쉽게 수행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/83cdaeadc2fdbb443f3c7af23156f8f6.png\" alt=\"image-20210626041417125\"\u003e\u003c/p\u003e\n\u003cp\u003e이후 브라우저를 통해 접속해보면 아래와 같이 접속이 잘 이뤄집니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/8b3fb103c4485a8313a6e237302fc41e.png\" alt=\"image-20210626041704593\"\u003e\u003c/p\u003e\n\u003ch2\u003eLens와 Prometheus 연동\u003c/h2\u003e\n\u003cp\u003e마지막으로, Lens의 설정 페이지에서 아래와 같이 Prometheus를 설정해줍니다.\u003c/p\u003e\n\u003cp\u003e아마 초기에는 installation method가 Autodetect로 되어 있고 service address가 보이지 않을 텐데 installation method를 Prometheus Operator로 설정해주면 service address를 입력할 수 있는 칸이 표시됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/784940cb4afaf721ee9d8d960786404e.png\" alt=\"image-20210626042443126\"\u003e\u003c/p\u003e\n\u003cp\u003e그러면 \u003cstrong\u003eLens 연동하기\u003c/strong\u003e 섹션처럼 메인 화면에서 각종 metric들을 확인할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eGrafana\u003c/h1\u003e\n\u003cp\u003e그리고 위 방법으로 Prometheus를 설치하면 Grafana가 따라옵니다. Grafana는 오픈 소스 데이터 분석 및 시각화 툴로 이 경우 Prometheus로부터 데이터를 받아 이쁘게 시각화해줍니다. Grafana 역시 다음과 같이 포트포워딩을 해준 후 이를 다시 로컬로 proxy해주어야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ekubectl port-forward --namespace monitor $(kubectl get pods -n monitor --selector app.kubernetes.io/name=grafana --output=jsonpath=\u003cspan class=\"hljs-string\"\u003e\u0026quot;{.items..metadata.name}\u0026quot;\u003c/span\u003e) 3000\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이후 브라우저에서 3000번으로 접근하면 아래와 같은 로그인 화면을 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/554ffd52c3123f62d03b3d49784004ef.png\" alt=\"image-20210626042113074\"\u003e\u003c/p\u003e\n\u003cp\u003e아이디와 패스워드를 \u003ccode\u003eadmin\u003c/code\u003e, \u003ccode\u003eprom-operator\u003c/code\u003e를 입력해줍니다. 그러면 이와 같이 Prometheus로부터 수집된 다양한 metric들을 시각화하여 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/8072b312d72e7110622640a501444016.png\" alt=\"image-20210626042247059\"\u003e\u003c/p\u003e\n\u003ch1\u003e참고문헌\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://www.dcasati.net/posts/installing-prometheus-on-kubernetes-v1.16.9/\"\u003ehttp://www.dcasati.net/posts/installing-prometheus-on-kubernetes-v1.16.9/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Grafana\"\u003ehttps://en.wikipedia.org/wiki/Grafana\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/\"\u003ehttps://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kubernetes.io/docs/concepts/overview/components/\"\u003ehttps://kubernetes.io/docs/concepts/overview/components/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://stackoverflow.com/questions/50352621/where-is-kube-apiserver-located\"\u003ehttps://stackoverflow.com/questions/50352621/where-is-kube-apiserver-located\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kubernetes.io/ko/docs/concepts/overview/components/\"\u003ehttps://kubernetes.io/ko/docs/concepts/overview/components/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://rancher.com/docs/rke/latest/en/kubeconfig/\"\u003ehttps://rancher.com/docs/rke/latest/en/kubeconfig/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://k3s.io/\"\u003ehttps://k3s.io/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.k8slens.dev/main/\"\u003ehttps://docs.k8slens.dev/main/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://rancher.com/docs/k3s/latest/en/cluster-access/\"\u003ehttps://rancher.com/docs/k3s/latest/en/cluster-access/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://bcho.tistory.com/1270?category=731548\"\u003ehttps://bcho.tistory.com/1270?category=731548\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kubernetes.io/docs/tasks/extend-kubernetes/http-proxy-access-api/\"\u003ehttps://kubernetes.io/docs/tasks/extend-kubernetes/http-proxy-access-api/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kubernetes.io/ko/docs/tasks/access-application-cluster/access-cluster\"\u003ehttps://kubernetes.io/ko/docs/tasks/access-application-cluster/access-cluster/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래는 본 포스트에 작성하지는 않았지만, Web Dashboard를 띄우기 위해 찾아 본 내용입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://jogeum.net/22\"\u003ehttps://jogeum.net/22\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kubernetes.io/ko/docs/tasks/access-application-cluster/web-ui-dashboard/\"\u003ehttps://kubernetes.io/ko/docs/tasks/access-application-cluster/web-ui-dashboard/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eTMI\u003c/h1\u003e\n\u003cp\u003e온갖 시행착오의 흔적들... 25일 새벽 2시부터 26일 새벽 4시(현재)까지 거의 450개 사이트에 방문... 여태 프로젝트들을 진행하면서 이렇게 많은 삽질을 했던 적이 없는 것 같아서 기념 삼아 남겨둡니다...\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/eafed43b22e7bd184a88382e50b0ff04.png\" alt=\"image-20210626043921889\"\u003e\u003c/p\u003e\n","imageMapping":{"imgs/favicon.png":"/imgs/6a347940f064146525be36b805414901.png","imgs/image-20210626034050664.png":"/imgs/a7292d4847704c6cee1373298dbb8269.png","imgs/image-20210626034135662.png":"/imgs/090b6fad0b4e8acff453f06d87393649.png","imgs/image-20210626034446233.png":"/imgs/1836dba3a603e9d35a4cdff11d6a52f4.png","imgs/image-20210626034754935.png":"/imgs/b6ef7d6f7d4c37fd08e0ddf5c42449b2.png","imgs/image-20210626041417125.png":"/imgs/83cdaeadc2fdbb443f3c7af23156f8f6.png","imgs/image-20210626041704593.png":"/imgs/8b3fb103c4485a8313a6e237302fc41e.png","imgs/image-20210626042443126.png":"/imgs/784940cb4afaf721ee9d8d960786404e.png","imgs/image-20210626042113074.png":"/imgs/554ffd52c3123f62d03b3d49784004ef.png","imgs/image-20210626042247059.png":"/imgs/8072b312d72e7110622640a501444016.png","imgs/image-20210626043921889.png":"/imgs/eafed43b22e7bd184a88382e50b0ff04.png"},"name":"2021-06-25-k8s-2"},"postsInSameCategory":[{"name":"2021-09-18-k8s-5","title":"쿠버네티스 클러스터 구축[5] - Multi-Node","date":"2021-09-18T01:01:29.384Z","category":"kubernetes"},{"name":"2021-09-05-k8s-4","title":"쿠버네티스 클러스터 구축[4] - WildCard TLS with Let'sEncrypt","date":"2021-09-05T00:03:01.289Z","category":"kubernetes"},{"name":"2021-09-01-k8s-3","title":"쿠버네티스 클러스터 구축[3] - Traefik","date":"2021-09-01T23:01:24.540Z","category":"kubernetes"},{"name":"2021-06-25-k8s-2","title":"쿠버네티스 클러스터 구축[2] - Lens","date":"2021-06-25T19:42:33.030Z","category":"kubernetes"},{"name":"2021-06-25-k8s-1","title":"쿠버네티스 클러스터 구축[1] - 가상 머신","date":"2021-06-25T17:10:36.838Z","category":"kubernetes"}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2021-06-25-k8s-2"},"buildId":"bg3GNayTREst1g1Voz8hR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>