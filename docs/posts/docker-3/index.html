<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/fcd26abcfb6841ad.css" as="style"/><link rel="stylesheet" href="/_next/static/css/fcd26abcfb6841ad.css" data-n-g=""/><link rel="preload" href="/_next/static/css/afa765f830d46ca8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/afa765f830d46ca8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-1cd5204319a0e744.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b091615f8a2f8bcf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-5c46775951523a08.js" defer=""></script><script src="/_next/static/cXe2IjfX_e2kh88S90gVa/_buildManifest.js" defer=""></script><script src="/_next/static/cXe2IjfX_e2kh88S90gVa/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="header_header__n6agz"><h1>[UNKNOWN-PGR]</h1><div><a class="header_nav__JpY1D" href="/">MAIN</a><a class="header_nav__JpY1D" href="/about/">ABOUT</a></div></div><main class="layout_main__j5lor"><div><h1 class="post_title__aQveY">Docker 공부해보기[3]</h1><main class="post_main__mmVmG"><p>이번 포스팅에서는 도커 컴포즈에 대해 간단히 다뤄보겠습니다.</p>
<p>이번에 한 머신에서 여러 서비스를 같이 돌릴 일이 있어 사용하게 됐습니다. 처음에는 그냥 각 서버 프로세스의 포트 번호만 다르게 해서 사용하다가, 갈수록 관리가 귀찮아지기에 아예 도커라이즈를 해 버렸는데요. 해 보니 너무나 편리해서 이걸 글로 잘 정리해두고자 포스팅을 해봅니다.</p>
<h1>도커 컴포즈란?</h1>
<blockquote>
<p>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see <a href="https://docs.docker.com/compose/#features">the list of features</a>.</p>
</blockquote>
<p>도커 공식 설명에 따르면, 도커 컴포즈란 multi-container docker application, 즉 컨테이너 여러 개를 사용하는 어플리케이션을 구동하기 위한 솔루션입니다. 예를 들어 어떤 서비스가 frontend서버와 api서버로 나뉘어 구동되고 있는 경우가 해당될 수 있겠습니다. 이러한 도커 컴포즈는 <code>YAML</code>형식의 파일을 통해 정의할 수 있으며, 서비스 전체를 <code>docker-compose up</code>이라는 커맨드 하나만으로 구동할 수 있습니다.</p>
<h1>사용 예시</h1>
<p>백문이 불여일견이라고, 직접 예시를 보면 더욱 좋을 것 같습니다. 아래는 제가 어떤 서비스를 돌리기 위해 사용하고 있는 <code>docker-compose.yml</code>파일입니다.</p>
<pre><code class="language-yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span>
<span class="hljs-attr">services:</span>

  <span class="hljs-attr">nginx:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">jwilder/nginx-proxy</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/tmp/docker.sock:ro</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">80</span><span class="hljs-string">:80</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">443</span><span class="hljs-string">:443</span>

  <span class="hljs-attr">service1:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">halverneus/static-file-server:latest</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">VIRTUAL_HOST=service1.mydomain.com</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">FOLDER=/app</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/srv/server-service1:/app</span>
    <span class="hljs-attr">expose:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span>

 <span class="hljs-attr">service2:</span>
     <span class="hljs-attr">image:</span> <span class="hljs-string">unknownpgr/service2:latest</span>
     <span class="hljs-attr">environment:</span>
       <span class="hljs-bullet">-</span> <span class="hljs-string">VIRTUAL_HOST=service2.mydomain.com</span>
       <span class="hljs-bullet">-</span> <span class="hljs-string">FOLDER=/app</span>
     <span class="hljs-attr">volumes:</span>
       <span class="hljs-bullet">-</span> <span class="hljs-string">/srv/server-service2:/app</span>
       <span class="hljs-bullet">-</span> <span class="hljs-string">/var/log:/app/log</span>
     <span class="hljs-attr">expose:</span>
       <span class="hljs-bullet">-</span> <span class="hljs-number">80</span>
     <span class="hljs-attr">entrypoint:</span> [<span class="hljs-string">&#x27;node&#x27;</span>,<span class="hljs-string">&#x27;/app/index.js&#x27;</span>]
</code></pre>
<p>먼저 제일 위에 있는 version:'3'은 그냥 도커 컴포즈의 버전입니다. 도커 컴포즈는 2021년 1월 현재 3.8버전까지 출시되어 있는데, 버전별로 사용가능한 기능이 약간씩 차이가 있어 명시해줄 필요가 있습니다.</p>
<h2>옵션들</h2>
<p>그 아래 <code>services</code> 항목부터가 본격적으로 컨테이너를 정의하는 부분입니다. <code>services</code>의 각 요소 <code>nginx</code>, <code>service1</code>, <code>service2</code>는 각각이 하나의 컨테이너입니다. 그 아래 세부 요소들이 각 컨테이너의 속성을 결정합니다.</p>
<ul>
<li>각 컨테이너의 <code>image</code>는 어떤 도커 이미지를 사용할 것인지를 지정하며, <code>docker run</code>을 할 때와 동일하게 먼저 로컬에서 이미지를 찾아본 후 docker hub를 탐색합니다.</li>
<li><code>environment</code>는 각 도커 이미지에 주어질 환경 변수입니다. 제가 설정한 환경 변수에 대해서는 아래에서 설명하겠습니다.</li>
<li><code>volumes</code>는 <code>docker run</code>의 <code>-v</code>옵션과 동일한 것으로, 호스트 디렉토리를 컨테이너 내부 디렉토리에 마운트합니다. <code>host:container</code>순서이므로, <code>service1</code>의 경우 호스트의 <code>/srv/server-service1</code>디렉토리를 컨테이너 내부의 <code>/app</code>디렉토리에 마운트하겠다는 의미가 됩니다.</li>
<li><code>ports</code>는 컨테이너 내부의 포트와 컨테이너 외부의 포트를 연결합니다. 이것 역시 <code>host:container</code>순서로, 예를 들어 <code>80:123</code>이라고 하면 컨테이너 내부의 <code>123</code>번 포트를 호스트의 <code>80</code>번 포트에 연결한다는 의미입니다.</li>
<li><code>expose</code>는 컨테이너 내부의 포트를 네트워크에 공개하겠다는 의미입니다. <em>그런데</em> docker compose를 사용하면 기본적으로 모든 컨테이너가 같은 네트워크에 연결되므로 이 명령어는 실제로는 아무런 의미가 없습니다. 그러나 이 명령어는 일종의 flag로 유용하게 사용됩니다. 아래에서 설명합니다.</li>
<li><code>entrypoint</code>는 도커 이미지가 띄워졌을 경우 수행될 <em>딱 하나의 명령어</em>입니다. 만약 여러 개의 명령어를 실행하고 싶다면 쉘 스크립트를 실행하도록 해야 합니다.</li>
<li>위 파일에서는 보이지 않지만, <code>command</code>라는 항목도 자주 사용됩니다. <code>command</code>는 <code>entrypoint</code>에 지정된 명령어에 따라 붙는 인자같은 것입니다. 예를 들어 <code>entrypoint</code>가 <code>echo</code>이고 <code>command</code>가 <code>hello world</code>라면 컨테이너가 실행될 경우 <code>echo hello world</code>가 실행됩니다. <code>command</code>와 <code>entrypoint</code>는 기능적으로는 차이가 없습니다만, <code>command</code>의 경우 덮어쓰는 것이 가능합니다. 그래서 보통 <code>entrypoint</code>로 명령어를 지정하고, <code>command</code>로 기본 옵션을 줍니다. 그러면 실행 시 <code>command</code>옵션만 주면 명령어는 그대로 두고 <code>command</code>부분만 덮어쓸 수 있어 편리합니다.</li>
</ul>
<h2>설명</h2>
<p>위 이미지에서는 <code>nginx</code>컨테이너가 제일 흥미롭습니다. 이 서비스를 구동하는 서버는 wildcard domain을 사용하는데, 이는 할당받은 도메인 앞에 어떤 서브도메인이 오더라도 전부 해당 서버로 라우팅해주는 기능입니다. 예를 들어 위 서비스의 경우 <code>mydomain.com</code>을 할당받은 경우로 <code>service1.mydomain.com</code>, <code>service2.mydomain.com</code>, <code>asdf.fdsa.mydomain.com</code>, <code>helloworld.mydomain.com</code>등 그 어떤 서브도메인을 입력하더라도 반드시 이 서버로 라우팅됩니다. 그러면 서버에서는 비록  같은 포트로 요청이 들어왔을지라도 요청한 도메인을 보고 서로 다른 서비스로 연결해줄 수 있습니다. 이러한 기술을 reverse proxy라 합니다.</p>
<p><code>nginx</code>는 이런 reverse proxy를 쉽게 구현할 수 있는 기능을 제공합니다. 그리고 <code>nginx-proxy</code> 컨테이너는 이 쉬운 구현을 더 쉽게 구현할 수 있는 방법을 제공합니다. 이 컨테이너는, 간략히 설명하자면, 같은 네트워크에 연결된 도커 컨테이너들을 훑어봅니다. 그리고 그중 <code>expose</code>를 설정했으면서 <code>VIRTUAL_HOST</code> 환경 변수를 가진 컨테이너를 찾습니다. 그리고 그 컨테이너의 <code>VIRTUAL_HOST</code>에 해당하는 도메인으로 요청이 들어올 경우 그 컨테이너로 포워딩해줍니다. 위 예시에서 아래의 두 컨테이너가 <code>VIRTUAL_HOST</code>환경변수와 쓸데없어 보이는 <code>expose</code>를 설정한 이유가 여기에 있습니다.</p>
<h2>결과</h2>
<p>결과적으로 각종 서비스를 한 서버에서 부담없이 돌릴 수 있게 되었습니다. 포트 번호도 신경쓸 필요가 없고, 좋은 점이 한두 가지가 아니네요. 특히 서비스를 재시작할 필요가 있을 때 고민없이 그냥 하면 된다는 점이 참 큰 장점인 것 같습니다.</p>
</main><h1>Posts in <!-- -->docker<!-- --> cateogry</h1><ul><li class="post_listSelected__vtK9Y"><a href="/posts/docker-3/">Docker 공부해보기[3]</a></li><li class="post_list__OlrZL"><a href="/posts/docker-2/">Docker 공부해보기[2]</a></li><li class="post_list__OlrZL"><a href="/posts/docker-1/">Docker 공부해보기[1]</a></li></ul></div></main><footer class="footer_footer__E_Uzl">© 2020 Copyright : Unknownpgr</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Docker 공부해보기[3]","category":"docker","date":"2021-01-09T08:47:20.287Z","html":"\u003cp\u003e이번 포스팅에서는 도커 컴포즈에 대해 간단히 다뤄보겠습니다.\u003c/p\u003e\n\u003cp\u003e이번에 한 머신에서 여러 서비스를 같이 돌릴 일이 있어 사용하게 됐습니다. 처음에는 그냥 각 서버 프로세스의 포트 번호만 다르게 해서 사용하다가, 갈수록 관리가 귀찮아지기에 아예 도커라이즈를 해 버렸는데요. 해 보니 너무나 편리해서 이걸 글로 잘 정리해두고자 포스팅을 해봅니다.\u003c/p\u003e\n\u003ch1\u003e도커 컴포즈란?\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCompose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see \u003ca href=\"https://docs.docker.com/compose/#features\"\u003ethe list of features\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e도커 공식 설명에 따르면, 도커 컴포즈란 multi-container docker application, 즉 컨테이너 여러 개를 사용하는 어플리케이션을 구동하기 위한 솔루션입니다. 예를 들어 어떤 서비스가 frontend서버와 api서버로 나뉘어 구동되고 있는 경우가 해당될 수 있겠습니다. 이러한 도커 컴포즈는 \u003ccode\u003eYAML\u003c/code\u003e형식의 파일을 통해 정의할 수 있으며, 서비스 전체를 \u003ccode\u003edocker-compose up\u003c/code\u003e이라는 커맨드 하나만으로 구동할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e사용 예시\u003c/h1\u003e\n\u003cp\u003e백문이 불여일견이라고, 직접 예시를 보면 더욱 좋을 것 같습니다. 아래는 제가 어떤 서비스를 돌리기 위해 사용하고 있는 \u003ccode\u003edocker-compose.yml\u003c/code\u003e파일입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eversion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;3\u0026#x27;\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eservices:\u003c/span\u003e\n\n  \u003cspan class=\"hljs-attr\"\u003enginx:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eimage:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ejwilder/nginx-proxy\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003evolumes:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e/var/run/docker.sock:/tmp/docker.sock:ro\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eports:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e:80\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e443\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e:443\u003c/span\u003e\n\n  \u003cspan class=\"hljs-attr\"\u003eservice1:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eimage:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ehalverneus/static-file-server:latest\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eenvironment:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eVIRTUAL_HOST=service1.mydomain.com\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eFOLDER=/app\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003evolumes:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e/srv/server-service1:/app\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eexpose:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e\n\n \u003cspan class=\"hljs-attr\"\u003eservice2:\u003c/span\u003e\n     \u003cspan class=\"hljs-attr\"\u003eimage:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eunknownpgr/service2:latest\u003c/span\u003e\n     \u003cspan class=\"hljs-attr\"\u003eenvironment:\u003c/span\u003e\n       \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eVIRTUAL_HOST=service2.mydomain.com\u003c/span\u003e\n       \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eFOLDER=/app\u003c/span\u003e\n     \u003cspan class=\"hljs-attr\"\u003evolumes:\u003c/span\u003e\n       \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e/srv/server-service2:/app\u003c/span\u003e\n       \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e/var/log:/app/log\u003c/span\u003e\n     \u003cspan class=\"hljs-attr\"\u003eexpose:\u003c/span\u003e\n       \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e\n     \u003cspan class=\"hljs-attr\"\u003eentrypoint:\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\u0026#x27;node\u0026#x27;\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\u0026#x27;/app/index.js\u0026#x27;\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저 제일 위에 있는 version:'3'은 그냥 도커 컴포즈의 버전입니다. 도커 컴포즈는 2021년 1월 현재 3.8버전까지 출시되어 있는데, 버전별로 사용가능한 기능이 약간씩 차이가 있어 명시해줄 필요가 있습니다.\u003c/p\u003e\n\u003ch2\u003e옵션들\u003c/h2\u003e\n\u003cp\u003e그 아래 \u003ccode\u003eservices\u003c/code\u003e 항목부터가 본격적으로 컨테이너를 정의하는 부분입니다. \u003ccode\u003eservices\u003c/code\u003e의 각 요소 \u003ccode\u003enginx\u003c/code\u003e, \u003ccode\u003eservice1\u003c/code\u003e, \u003ccode\u003eservice2\u003c/code\u003e는 각각이 하나의 컨테이너입니다. 그 아래 세부 요소들이 각 컨테이너의 속성을 결정합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e각 컨테이너의 \u003ccode\u003eimage\u003c/code\u003e는 어떤 도커 이미지를 사용할 것인지를 지정하며, \u003ccode\u003edocker run\u003c/code\u003e을 할 때와 동일하게 먼저 로컬에서 이미지를 찾아본 후 docker hub를 탐색합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eenvironment\u003c/code\u003e는 각 도커 이미지에 주어질 환경 변수입니다. 제가 설정한 환경 변수에 대해서는 아래에서 설명하겠습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evolumes\u003c/code\u003e는 \u003ccode\u003edocker run\u003c/code\u003e의 \u003ccode\u003e-v\u003c/code\u003e옵션과 동일한 것으로, 호스트 디렉토리를 컨테이너 내부 디렉토리에 마운트합니다. \u003ccode\u003ehost:container\u003c/code\u003e순서이므로, \u003ccode\u003eservice1\u003c/code\u003e의 경우 호스트의 \u003ccode\u003e/srv/server-service1\u003c/code\u003e디렉토리를 컨테이너 내부의 \u003ccode\u003e/app\u003c/code\u003e디렉토리에 마운트하겠다는 의미가 됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eports\u003c/code\u003e는 컨테이너 내부의 포트와 컨테이너 외부의 포트를 연결합니다. 이것 역시 \u003ccode\u003ehost:container\u003c/code\u003e순서로, 예를 들어 \u003ccode\u003e80:123\u003c/code\u003e이라고 하면 컨테이너 내부의 \u003ccode\u003e123\u003c/code\u003e번 포트를 호스트의 \u003ccode\u003e80\u003c/code\u003e번 포트에 연결한다는 의미입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eexpose\u003c/code\u003e는 컨테이너 내부의 포트를 네트워크에 공개하겠다는 의미입니다. \u003cem\u003e그런데\u003c/em\u003e docker compose를 사용하면 기본적으로 모든 컨테이너가 같은 네트워크에 연결되므로 이 명령어는 실제로는 아무런 의미가 없습니다. 그러나 이 명령어는 일종의 flag로 유용하게 사용됩니다. 아래에서 설명합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eentrypoint\u003c/code\u003e는 도커 이미지가 띄워졌을 경우 수행될 \u003cem\u003e딱 하나의 명령어\u003c/em\u003e입니다. 만약 여러 개의 명령어를 실행하고 싶다면 쉘 스크립트를 실행하도록 해야 합니다.\u003c/li\u003e\n\u003cli\u003e위 파일에서는 보이지 않지만, \u003ccode\u003ecommand\u003c/code\u003e라는 항목도 자주 사용됩니다. \u003ccode\u003ecommand\u003c/code\u003e는 \u003ccode\u003eentrypoint\u003c/code\u003e에 지정된 명령어에 따라 붙는 인자같은 것입니다. 예를 들어 \u003ccode\u003eentrypoint\u003c/code\u003e가 \u003ccode\u003eecho\u003c/code\u003e이고 \u003ccode\u003ecommand\u003c/code\u003e가 \u003ccode\u003ehello world\u003c/code\u003e라면 컨테이너가 실행될 경우 \u003ccode\u003eecho hello world\u003c/code\u003e가 실행됩니다. \u003ccode\u003ecommand\u003c/code\u003e와 \u003ccode\u003eentrypoint\u003c/code\u003e는 기능적으로는 차이가 없습니다만, \u003ccode\u003ecommand\u003c/code\u003e의 경우 덮어쓰는 것이 가능합니다. 그래서 보통 \u003ccode\u003eentrypoint\u003c/code\u003e로 명령어를 지정하고, \u003ccode\u003ecommand\u003c/code\u003e로 기본 옵션을 줍니다. 그러면 실행 시 \u003ccode\u003ecommand\u003c/code\u003e옵션만 주면 명령어는 그대로 두고 \u003ccode\u003ecommand\u003c/code\u003e부분만 덮어쓸 수 있어 편리합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e설명\u003c/h2\u003e\n\u003cp\u003e위 이미지에서는 \u003ccode\u003enginx\u003c/code\u003e컨테이너가 제일 흥미롭습니다. 이 서비스를 구동하는 서버는 wildcard domain을 사용하는데, 이는 할당받은 도메인 앞에 어떤 서브도메인이 오더라도 전부 해당 서버로 라우팅해주는 기능입니다. 예를 들어 위 서비스의 경우 \u003ccode\u003emydomain.com\u003c/code\u003e을 할당받은 경우로 \u003ccode\u003eservice1.mydomain.com\u003c/code\u003e, \u003ccode\u003eservice2.mydomain.com\u003c/code\u003e, \u003ccode\u003easdf.fdsa.mydomain.com\u003c/code\u003e, \u003ccode\u003ehelloworld.mydomain.com\u003c/code\u003e등 그 어떤 서브도메인을 입력하더라도 반드시 이 서버로 라우팅됩니다. 그러면 서버에서는 비록  같은 포트로 요청이 들어왔을지라도 요청한 도메인을 보고 서로 다른 서비스로 연결해줄 수 있습니다. 이러한 기술을 reverse proxy라 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enginx\u003c/code\u003e는 이런 reverse proxy를 쉽게 구현할 수 있는 기능을 제공합니다. 그리고 \u003ccode\u003enginx-proxy\u003c/code\u003e 컨테이너는 이 쉬운 구현을 더 쉽게 구현할 수 있는 방법을 제공합니다. 이 컨테이너는, 간략히 설명하자면, 같은 네트워크에 연결된 도커 컨테이너들을 훑어봅니다. 그리고 그중 \u003ccode\u003eexpose\u003c/code\u003e를 설정했으면서 \u003ccode\u003eVIRTUAL_HOST\u003c/code\u003e 환경 변수를 가진 컨테이너를 찾습니다. 그리고 그 컨테이너의 \u003ccode\u003eVIRTUAL_HOST\u003c/code\u003e에 해당하는 도메인으로 요청이 들어올 경우 그 컨테이너로 포워딩해줍니다. 위 예시에서 아래의 두 컨테이너가 \u003ccode\u003eVIRTUAL_HOST\u003c/code\u003e환경변수와 쓸데없어 보이는 \u003ccode\u003eexpose\u003c/code\u003e를 설정한 이유가 여기에 있습니다.\u003c/p\u003e\n\u003ch2\u003e결과\u003c/h2\u003e\n\u003cp\u003e결과적으로 각종 서비스를 한 서버에서 부담없이 돌릴 수 있게 되었습니다. 포트 번호도 신경쓸 필요가 없고, 좋은 점이 한두 가지가 아니네요. 특히 서비스를 재시작할 필요가 있을 때 고민없이 그냥 하면 된다는 점이 참 큰 장점인 것 같습니다.\u003c/p\u003e\n","name":"docker-3"},"postsInSameCategory":[{"title":"Docker 공부해보기[3]","category":"docker","date":"2021-01-09T08:47:20.287Z","name":"docker-3"},{"title":"Docker 공부해보기[2]","category":"docker","date":"2020-08-08T10:39:45.846Z","name":"docker-2"},{"title":"Docker 공부해보기[1]","category":"docker","date":"2020-08-08T08:30:40.846Z","name":"docker-1"}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"docker-3"},"buildId":"cXe2IjfX_e2kh88S90gVa","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>