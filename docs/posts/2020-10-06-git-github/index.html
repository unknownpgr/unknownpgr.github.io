<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="description" content="Unknownpgr&#x27;s Blog"/><link rel="icon" href="/favicon.png"/><meta property="og:title" content="Unknownpgr&#x27;s Blog"/><meta property="og:url" content="https://unknownpgr.com"/><meta property="og:image" content="/logo.png"/><title>Unknownpgr : Git / GitHub[1] - Git 기초</title><meta property="og:title" content="Unknownpgr: Git / GitHub[1] - Git 기초"/><meta name="next-head-count" content="9"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/2e1e96656eb72d38.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2e1e96656eb72d38.css" data-n-g=""/><link rel="preload" href="/_next/static/css/bb77c4673c8d1507.css" as="style"/><link rel="stylesheet" href="/_next/static/css/bb77c4673c8d1507.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-1cd5204319a0e744.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b2167bfc37ff4f0b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-ef770e12683a69af.js" defer=""></script><script src="/_next/static/bg3GNayTREst1g1Voz8hR/_buildManifest.js" defer=""></script><script src="/_next/static/bg3GNayTREst1g1Voz8hR/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="nav_nav__XkaAa"><a class="nav_logo__drPJg" href="/">[UNKNOWN-PGR]</a><a class="nav_link__KHlEJ" href="/">Home</a><a class="nav_link__KHlEJ" href="/categories/">Categories</a><a class="nav_link__KHlEJ" href="/about/">About</a></nav><main class="layout_main__j5lor"><div><h1 class="post_title__aQveY">Git / GitHub[1] - Git 기초</h1><div class="post_info__7zaFc"><i>git<!-- --> / <!-- -->2020-10-06T03:16:55.258Z</i></div><main class="post_main__mmVmG"><p>깃(Git)과 깃허브(GitHub)는 프로그래밍을 하는 사람이라면 거의 반드시 사용하는 툴입니다. 근래에는 취업 시 포트폴리오로 깃허브 계정을 제출하는 경우도 많아서, 저는 친구들이나 후배들에게 깃과 깃허브를 쓰기를 권장합니다.</p>
<p>그러나 인터넷을 찾아 보면 깃과 깃허브에 대해 쉽게 설명해놓은 사이트들이 잘 나오지 않았습니다. 그래서 다른 사람에게 깃에 대해 알려줄 때 좀 더 쉽게 알려주고자, 블로그에 글로 정리해두고자 합니다.</p>
<h1>🐙🧾Git은 왜 필요한가?</h1>
<p>결론부터 말하자면, <u>Git은 프로젝트(내부의 파일들)의 버전을 관리해주는 프로그램</u>입니다.</p>
<p>보통 프로젝트를 진행할 때, 파일들의 특정 버전을 저장해두고 싶은 때가 있습니다. 예를 들자면,</p>
<ul>
<li>프로그램을 하나 만들었더니 정상적으로 잘 동작합니다.</li>
<li>그런데 이때 새로운 기능을 추가하고 싶은데, 이 기능을 추가하다가 기존의 내용을 망쳐버릴 수도 있습니다.</li>
<li>그래서 이 버전을 다른 곳에 저장해뒀다가, 혹시라도 실패하면 가져와서 복구합니다.</li>
</ul>
<p>또는 이런 경우도 있습니다.</p>
<ul>
<li>프로젝트 진행 과정을 기록해두고 싶습니다.</li>
<li>그래서 예를 들자면, 일주일에 한 번씩 사본을 만들어 저장해둡니다.</li>
</ul>
<p>이때 사람들은 아래와 같이 파일 이름을 바꾸어서 관리하곤 합니다.</p>
<p><img src="/imgs/89e0419143d90fd743da69b39954f1d5" alt="img"></p>
<p>(이 이미지를 <a href="https://bbs.ruliweb.com/community/board/300712/read/19635391">퍼온 곳</a>을 보면, 이런 작업과 관련된 온갖 고충을 다 볼 수 있습니다...)</p>
<p>바로 이럴 때 Git이 필요합니다. 깃은 이런 버전 작업을 매우 쉽게 관리할 수 있도록 도와줍니다.</p>
<h1>🖨그냥 파일을 복사하면 안 되는가?</h1>
<p>파일을 그대로 복사하는 방식에는 약간 문제가 있습니다.</p>
<ul>
<li>
<p>대부분의 파일들이 수천 줄의 텍스트로 이루어졌고, 여러 개의 파일들을 동시에 수정하기 때문에 눈으로 보아서는 <u>무엇이 달라졌는지 알기가 아주 힘듭니다.</u> 디자인에서는 큰 차이가 없다면 별 문제가 없을 수 있지만, 프로그래밍에서는 단 한 글자만 바꾸더라도 프로젝트 전체가 전혀 작동하지 않을 수도 있습니다. (e.g. 세미콜론을 빼 먹는다던가...)</p>
</li>
<li>
<p>버전을 많이 만들면 많이 만들수록 <u>용량이 매우 빠르게 커집니다.</u> 예를 들어 200MB짜리 프로젝트를 다섯 번만 백업하더라도 벌써 1GB가까운 크기가 됩니다.</p>
</li>
<li>
<p>한 명의 사람이 파일 하나를 완전히 맡아 진행하는 디자인과 다르게, 프로그래머는 <u>협업을 하는 경우</u>가 많습니다. 그런 경우 상당히 일이 복잡해집니다.</p>
<ul>
<li>원본 버전에서 <code>개발자 A</code>가 파일 <code>a,b,c</code>를 수정해서 버전 <code>A1</code>을 만들었습니다.</li>
<li><code>개발자 B</code>는 파일 <code>b,c,d</code>를 수정해서 버전 <code>B1</code>을 만들었습니다. 심지어 <code>b</code>와 <code>c</code>는 <code>개발자 A,B</code>모두 동시에 수정한 파일들입니다.</li>
<li>이제 이걸 하나의 파이널 버전으로 합쳐야 하는데...음...</li>
</ul>
<p>사실 이런 경우야 <code>개발자 A,B</code>가 모여서 하루 날 잡고 합치면 됩니다.</p>
<ul>
<li>그런데 만약 개발자가 30명이나 되고, 파일이 2만개정도 된다면?</li>
<li>모든 개발자가 원본으로부터 개발을 시작한 게 아니라, <code>개발자 A</code>가 만든 <code>A1</code>버전으로부터 <code>개발자 B</code>가 <code>B1</code> 버전을 만들고, <code>B1</code>으로부터 <code>개발자 C</code>가 <code>C1</code>을 만들고, <code>A1</code>과 <code>C1</code>을 합친 후 <code>개발자 B</code>가 <code>B2</code>를 다시 만들고, 그것을 다시 <code>A1</code>에 합치고....와 같이 된다면?</li>
<li>그 와중에 프로젝트 전체 크기가 10GB나 된다면? 그래서 프로젝트를 다른 사람 컴퓨터로 복사하기만 해도 오랜 시간이 걸린다면?</li>
</ul>
</li>
</ul>
<p>프로젝트가 커질수록 이런 문제들이 발생하면서, 정작 버전 관리가 개발하는 것보다 더 힘들어집니다. 이렇게 기존 방법들의 문제점을 나열한 이유는, <u>Git이 바로 이런 문제점을 해결하기 위해서 존재</u>하기 때문입니다. 깃에는 branch 등 복잡한 기능들이 많이 있습니다. 그런 기능들이 필요한 배경을 먼저 알고 공부하면 그런 기능을 익히기 더 쉬울 것입니다.</p>
<h1>⚙ Git은 어떻게 동작하는가?</h1>
<p>먼저 Git이 설치되어있다는 가정 하에 실제로 설명드리겠습니다. <a href="https://coding-factory.tistory.com/245">코딩팩토리 블로그 글</a>을 보시면 설명이 잘 되어 있습니다.</p>
<h2>리포지토리 만들기</h2>
<p>앞서 깃은 프로젝트 버전을 관리해주는 프로그램이라고 설명했었습니다. 그러려면 각 버전들이 어딘가에 저장이 돼야 할 텐데요. 그 <u>버전들이 저장되는 곳을 <code>Repository(리포지토리, 저장소)</code>라고 부릅니다.</u> 이제 아래와 같이 프로젝트 폴더를 하나 만들고, 이 프로젝트에 리포지토리를 만들어보겠습니다.</p>
<p><img src="/imgs/cc72ac8caf0eae03750bd3a75c2ee04a.png" alt="image-20201006093218292"></p>
<p>프로젝트 폴더에서 커맨드라인 창을 열어줍니다. 파워쉘도 괜찮습니다. 파워쉘을 열기 위해서는 <code>Shift</code>키를 누른 채로 우클릭을 하면 메뉴에 파워쉘 열기 버튼이 있을 것입니다.</p>
<p>이후 열린 커맨드라인에서 <code>git init</code> 커맨드를 입력해줍니다. 그러면 아래와 같이 깃 리포지토리가 초기화되었다는 메시지가 뜹니다.</p>
<p><img src="/imgs/d57b8d39b7eaa285bb9c01a637f0ec5f.png" alt="image-20201006093451001"></p>
<p>이제 깃을 사용할 준비가 다 되었습니다.</p>
<p>그런데 프로젝트 폴더를 보시면 아무 것도 변한 게 없습니다. 분명히 리포지토리를 생성했다고 했는데, 어떻게 된 걸까요?</p>
<p>이는 숨김 파일을 보이도록 해 보면 알 수 있습니다.</p>
<p><img src="/imgs/c403e143e7c9e2d7b013cc7204957650.png" alt="image-20201006094604073"></p>
<p>위와 같이 <code>.git</code>이라는 숨겨진 디렉토리가 보입니다. 이 숨겨진 디렉토리 안에 깃 설정 정보, 각 버전들 등 여러 데이터가 들어 있습니다. 물론 저 폴더 안에 단순히 프로젝트 전체의 사본이 날짜별로 들어있거나 한 것은 아닙니다. 이는 아래 Git Workflow 섹션에서 설명하겠습니다.</p>
<h2>파일 상태</h2>
<p>Git은 파일들을 아래 이미지에서 보이는 세 가지 단계로 관리합니다. (정확히는 <code>파일</code>을 관리하는 것이 아니라 <code>변경사항</code>을 관리하는 것입니다. 그러나 이 글은 기초적인 개념을 소개하는 글이므로 이는 생략하겠습니다.)</p>
<p><img src="/imgs/e480e48c33006c77bba0c62453ce0934.png" alt="Diagram of git stages"></p>
<p><code>Working Directory</code>는 우리가 작업하고 있는 디렉토리를 말합니다. 그냥 프로젝트 폴더입니다.</p>
<p><code>Repository</code>는 앞서 보았듯이 버전들이 저장되는 장소입니다.</p>
<p><code>Staging Area</code>는 약간 헷갈리는 개념입니다. 간단히는 <code>Working Directory</code>와 <code>Repository</code> 사이에 있는 임시 저장 공간이라고 생각하시면 됩니다. 좀 차이가 있기는 합니다만, 블로그에 글을 작성할 때, 작성을 완료해서 포스팅하기 전에 임시 저장 단계가 있습니다. 그런 거라고 생각하시면 됩니다.</p>
<p>(사실 <code>Staging Area</code>는 버전 관리에서 꼭 필요한 것은 아니라서, Git외의 다른 버전 관리 시스템에서는 이 기능이 없는 경우도 있습니다.)</p>
<p>포스트 임시 저장과 <code>Staging Area</code>의 차이는, 포스트는 임시 저장 없이 바로 포스팅할 수 있지만 깃에서는 반드시 임시저장을 해야 하고, <u>임시저장을 한 내용만 새로운 버전으로 만들 수 있다는 것입니다.</u></p>
<h3>Working Directory</h3>
<p>그러면 프로젝트에서 내 파일들이 어떤 단계에 있는지 확인해보겠습니다. 커맨드라인에 <code>git status</code>를 입력하면 다음과 같이 파일의 상태가 나옵니다.</p>
<p><img src="/imgs/1d8825abfc5b01de109e8f78fa941755.png" alt="image-20201006095639331"></p>
<p>파일이 <code>Untracked files</code>라고 되어 있는데, <code>Untracked</code> 혹은 <code>Modified</code>, <code>Deleted</code>는 임시 저장해둔 <code>Staging Area</code>의 내용과 <code>Working Directory</code>의 내용이 다르다는 것을 알려줍니다.</p>
<ul>
<li>우리는 아직 <code>Staging Area</code>에 아무것도 저장을 하지 않았기 때문에 임시 저장소에는 <code>MyTextFile.txt</code>자체가 없습니다. 그럴 경우 <code>untracked</code>가 표시됩니다.</li>
<li>만약  <code>Staging Area</code>에 파일이 있기는 한데, 그 내용이 다를 경우는 <code>modified</code>가 표시됩니다.</li>
<li><code>Staging Area</code>에는 파일이 있는데 <code>Working Directory</code>에는 파일이 없다면 <code>deleted</code>가 표시됩니다.</li>
</ul>
<h3>Staging Area</h3>
<p><code>MyTextFile.txt</code>파일을 임시저장하려면 <code>git add MyTextfile.txt</code>과 같이 <code>git add</code>이후에 원하는 파일 이름을 입력하면 됩니다. 만약 프로젝트 폴더 안에 있는 모든 파일들을 전부 임시저장하려면 <code>git add .</code>과 같이 파일 이름 대신 점을 쓰면 됩니다. 보통 파일을 일일이 저장하는 것은 매우 귀찮기 때문에, 특별한 일이 없으면 후자를 사용합니다.</p>
<p>이후 <code>git status</code>를 입력하여 파일의 상태를 확인해보면 <code>Changes to be committed</code>섹션으로 파일이 이동해있습니다. 이는 파일이 <code>Staging Area</code>에 임시 저장되었다는 의미입니다. 여기에서는 파일 앞에 <code>new file</code>이라고 표시됩니다. 이것 역시 아까와 유사하게 <code>Repository</code>와 <code>Staging Area</code>의 내용이 다르다는 것을 알려줍니다.</p>
<ul>
<li>우리는 임시저장만 하고 어떤 버전도 생성하지 않았기 때문에 <code>Repository</code>에는 <code>MyTextFile.txt</code>가 없습니다. 그럴 경우 <code>new file</code>이라고 뜹니다.</li>
<li>아까와 비슷하게 <code>Repository</code>에 파일이 있기는 한데 <code>Staging Area</code>와 내용이 다를 경우 <code>modified</code>가 표시됩니다.</li>
<li><code>Repository</code>에는 파일이 있는데 <code>Staging Area</code>에는 없을 경우에는 <code>deleted</code>라고 표시됩니다.</li>
</ul>
<p><img src="/imgs/4db365307fbb03084bf0cedf9ce902e7.png" alt="image-20201006101816218"></p>
<p>이제 파일들을 임시저장했기 때문에, 드디어 새로운 버전을 만들 수 있습니다.</p>
<h3>Repository</h3>
<p>여태까지 우리가 만들었던 리포지토리는 비어있던 상태였습니다. 이제 리포지토리에 새로운 버전을 추가해보겠습니다. 버전을 만드는 작업을 <code>Commit(커밋)</code>이라고 합니다.</p>
<p><code>git commit -m &quot;Initial commit&quot;</code> 명령어를 입력해줍니다. 뒤에 <code>Initial commit</code>부분은 각 버전에 붙는 설명인데, 이를 커밋 메시지라 합니다. 보통 이 버전이 이전 버전에서 무엇을 수정한 것인지를 써 줍니다. 우리는 맨 처음 버전을 만드는 것이고, 이전 버전이 없기 때문에 저렇게 써 주었습니다. 예를 들어 새로운 기능을 추가했다면 <code>Add new feature ~~</code>과 같이 커밋 메시지를 쓸 수 있습니다.</p>
<p>그러면 아래와 같이 이 버전에서 어떤 일이 이루어졌는지를 알려주는 로그가 뜹니다.</p>
<p><img src="/imgs/e8f016466d6e7752724ecf723b635fa8.png" alt="image-20201006103007848"></p>
<p>메시지의 내용은 그냥 그렇구나~하고 넘기시면 됩니다. 아직 <code>브랜치</code>나 <code>변경 사항</code>에 대한 내용을 다루지 않았기 때문입니다.</p>
<p>어쨌든 이제 새로운 버전을 만들었기 때문에, 언제든 이 버전으로 다시 돌아오거나, 이 버전과 다른 버전을 비교할 수 있습니다. 새로운 버전을 추가하고 싶으면 아래 과정을 반복하면 됩니다.</p>
<ol>
<li>파일을 추가하거나 내용을 변경하는 등 여러 작업 수행</li>
<li><code>git add . </code>명령어를 통해 <code>Staging Area</code>로 임시저장</li>
<li><code>git commit -m &quot;Some message&quot;</code>명령어를 통해 새로운 커밋(버전) 생성</li>
</ol>
<p>그래서 보통 깃을 다룰 때에는 <code>버전</code>이라는 말보다는 <code>커밋</code>이라는 말을 자주 사용합니다. *변경 사항을 커밋해서...*처럼 새로운 버전을 만들었다는 의미의 동사로 사용하기도 하고, *이전 커밋을 보면...*처럼 버전이라는 의미의 명사로 사용하기도 합니다. 앞으로는 버전이라는 말 대신 커밋이라는 말을 사용하도록 하겠습니다.</p>
<h2>예시</h2>
<p>다음과 같은 과정을 수행해보겠습니다.</p>
<ol>
<li>새로운 파일 추가</li>
<li>git add . / git commit하여 새로운 커밋 생성</li>
<li>파일의 내용을 수정</li>
<li>git add .</li>
<li>파일을 삭제</li>
<li>git status</li>
</ol>
<p>그러면 아래와 같이 표시됩니다.</p>
<p><img src="/imgs/5107e4730a1abd8249a198115e58ce0f.png" alt="image-20201006113153727"></p>
<ul>
<li>3번 단계에서 파일을 수정한 후 <code>git add</code>를 수행하여 임시저장을 했습니다. 그러므로 <code>Changes to be committed</code> 섹션에는 <code>Repository</code>와 <code>Staging Area</code>에서 파일의 내용에 차이가 있으므로 <code>modified</code>가 표시됩니다.</li>
<li>5번 단계에서 파일을 삭제했지만, <code>git add</code>를 수행하지는 않았습니다. 그러므로 <code>Staging Area</code>에는 여전히 파일이 있으나 <code>Working Directory</code>에는 파일이 없습니다. 따라서 아래쪽 섹션에는 <code>deleted</code>가 표시됩니다.</li>
</ul>
<h2>Git Workflow</h2>
<p>그런데 맨 처음에 설명할 때, 사본을 만들 때의 단점 중 하나가 용량이 매우 커진다는 점이었습니다. 그리고 Git이 이런 문제를 해결했다고도 언급했는데, 어떻게 사본을 많이 만들면서도 용량을 적게 쓸 수 있을까요?</p>
<p>이는 Git이 내부적으로는 <code>commit</code>을 할 때 모든 내용을 전부 다 저장하는 것이 아니라, <u>변경된 내용이 무엇인지만 저장</u>하기 때문입니다.</p>
<ul>
<li>100M나 되는 매우 큰 텍스트 파일이 있다고 가정해봅시다.</li>
<li>이때 이 파일의 123번째 줄이 <code>ASDF</code>였는데 이를 <code>ㅁㄴㅇㄹ</code>로 바꾸었습니다.</li>
<li>그러면 Git은 새로운 커밋을 만들 때에는 <code>123번째 줄이 ASDF에서 ㅁㄴㅇㄹ로 바뀌었음</code> 이라는 정보만 저장합니다.</li>
</ul>
<p>이와 같이 Git의 각 커밋은 바로 이전 커밋으로부터 어떤 차이가 있는지만을 저장하고 있습니다. 위 리포지토리 만들기 섹션에서 <code>.git</code>폴더 안에 프로젝트의 사본이 들어있는 것은 아니라고 말했습니다. 그게 바로 이런 이유에서입니다.</p>
<p>물론 그렇다고 해서 옛날 버전으로 돌아가기 위해서 각 커밋을 하나하나 취소해야 한다거나 하지는 않습니다. 우리가 사용할 때에는 마치 프로젝트 전체가 백업된 것처럼 사용하면 됩니다.</p>
<h3>Git Diff</h3>
<p>추가로, 두 커밋 사이에 어떤 변화가 생겼나 확인하는 방법을 알려드리겠습니다.</p>
<p>먼저 <code>git log</code>를 사용하면 아래와 같이 어떤 커밋들이 있었는지 그 리스트를 볼 수 있습니다.</p>
<p><img src="/imgs/200f0d7430f28b48bd53ad3e44afb810.png" alt="image-20201006110420405"></p>
<p>각 커밋은 위에 보이는 <code>91156f75...</code>와 같은 고유 번호가 있습니다.</p>
<p>이제 <code>git diff 커밋1고유번호 커밋2고유번호</code>를 입력하면 두 커밋의 차이를 볼 수 있습니다. 물론 저 긴 문자들을 다 입력할 필요는 없고 맨 앞의 네다섯 글자 정도만 입력해주면 됩니다.</p>
<p><img src="/imgs/0b9827cb08286961d9103f2a7938e4c1.png" alt="image-20201006110755380"></p>
<p>만약 그냥 <code>git diff</code>를 입력하면 현재 <code>Working Directory</code>의 내용과 가장 최근 커밋을 비교하여 보여줍니다.</p>
<p><img src="/imgs/2ada38dba9ea957ba579e9f319fa4721.png" alt="image-20201006110859176"></p>
<h1>다음엔?</h1>
<p>순서는 좀 다를 수 있지만 아래와 같은 내용을 포스팅해보려 합니다.</p>
<ul>
<li>GitHub란?</li>
<li>Branch란?</li>
<li>공동 작업하기</li>
</ul>
<p>물론 되돌리기(Revert), Checkout 등 깃의 중요한 기능을 전혀 다루지 않았습니다. 그러나 그런 것들은 깃의 근본적인 원리만 이해했다면 다른 사람들이 설명해둔 내용을 보고 쉽게 이해할 수 있습니다. 반대로 깃의 원리를 이해하지 못하고 기능만 알고 사용한다면, 깃을 비효율적으로 사용하게 될 뿐만 아니라 오류가 나는 일(보통 커밋이 꼬인다고 함)이 많아집니다. (경험담)</p>
<p>개인적으로는 <a href="https://git-scm.com/book/ko/v2">pro Git book 한국어판</a>이 목차별로 정리가 잘 되어 있어 좋은 것 같습니다.</p>
<h1>요약</h1>
<h2>깃으로 새로운 버전(커밋)만드는 방법</h2>
<ol>
<li>커맨드라인에 <code>git init</code> 입력하여 초기화</li>
<li>원하는 작업 수행</li>
<li><code>git add .</code>입력하여 임시저장</li>
<li><code>git commit -m &quot;커밋 메시지&quot;</code>입력하여 커밋.</li>
</ol>
<h2>깃 / 커밋의 이해</h2>
<ul>
<li>깃은 버전 관리 시스템.</li>
<li>버전을 만드는 과정, 또는 그렇게 만들어진 각 버전을 커밋이라 부름.</li>
<li>커밋은 프로젝트의 모든 정보를 담고 있는 것이 아니라, 이전 커밋과의 차이점만을 담고 있음.</li>
<li>이 커밋들이 저장되는 장소를 리포지토리(Repository)라 부름. 약간 다르기는 하지만, 대충 <code>.git</code>디렉토리 안에 있다고 생각하면 됨.</li>
</ul>
<h1>더 알아보기</h1>
<p>아래는 깃을 효율적으로 사용하기 위해 알면 좋은 것들입니다. 구체적인 사용법은 구글에 물어보시면 좋습니다.</p>
<ul>
<li><code>.gitignore</code> : 이 파일에 적힌 파일이나 폴더는 데스노트처럼, 깃이 아예 없는 것처럼 관리합니다. 굳이 저장할 필요 없는 파일들(e.g. 임시파일/로그파일 등)을 여기 적어두면 좋습니다.</li>
<li><code>GitHub Desktop</code> : 깃헙에서는 깃을 GUI로 사용할 수 있는 프로그램을 제공합니다. 커맨드라인보다 사용하기가 훨씬 편리합니다.</li>
<li><code>VSCode에서 Git사용하기</code> : VS코드에서는 아예 내부적으로 깃을 관리할 수 있는 GUI를 제공합니다. 코딩하면서 깃도 관리할 수 있어서, 개인적으로는 <code>GitHub Desktop</code>보다 이것을 훨씬 더 많이 사용합니다.</li>
</ul>
</main><h1>Posts in <!-- -->git<!-- --> category</h1><ul><li class="post_listSelected__vtK9Y"><a href="/posts/2020-10-06-git-github/">Git / GitHub[1] - Git 기초</a></li></ul><div></div></div></main><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5695206410217978" data-ad-slot="9579212903" data-ad-format="auto" data-full-width-responsive="true"></ins><footer class="footer_footer__E_Uzl">© 2020 Copyright : Unknownpgr</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Git / GitHub[1] - Git 기초","category":"git","date":"2020-10-06T03:16:55.258Z","postStr":"---\ntitle: Git / GitHub[1] - Git 기초\ncategory: git\ndate: 2020-10-06T03:16:55.258Z\n\n---\n\n깃(Git)과 깃허브(GitHub)는 프로그래밍을 하는 사람이라면 거의 반드시 사용하는 툴입니다. 근래에는 취업 시 포트폴리오로 깃허브 계정을 제출하는 경우도 많아서, 저는 친구들이나 후배들에게 깃과 깃허브를 쓰기를 권장합니다.\n\n 그러나 인터넷을 찾아 보면 깃과 깃허브에 대해 쉽게 설명해놓은 사이트들이 잘 나오지 않았습니다. 그래서 다른 사람에게 깃에 대해 알려줄 때 좀 더 쉽게 알려주고자, 블로그에 글로 정리해두고자 합니다.\n\n# 🐙🧾Git은 왜 필요한가?\n\n결론부터 말하자면, \u003cu\u003eGit은 프로젝트(내부의 파일들)의 버전을 관리해주는 프로그램\u003c/u\u003e입니다.\n\n보통 프로젝트를 진행할 때, 파일들의 특정 버전을 저장해두고 싶은 때가 있습니다. 예를 들자면,\n\n- 프로그램을 하나 만들었더니 정상적으로 잘 동작합니다.\n- 그런데 이때 새로운 기능을 추가하고 싶은데, 이 기능을 추가하다가 기존의 내용을 망쳐버릴 수도 있습니다.\n- 그래서 이 버전을 다른 곳에 저장해뒀다가, 혹시라도 실패하면 가져와서 복구합니다.\n\n또는 이런 경우도 있습니다.\n\n- 프로젝트 진행 과정을 기록해두고 싶습니다.\n- 그래서 예를 들자면, 일주일에 한 번씩 사본을 만들어 저장해둡니다.\n\n이때 사람들은 아래와 같이 파일 이름을 바꾸어서 관리하곤 합니다.\n\n![img](52B979BD503F240029)\n\n(이 이미지를 [퍼온 곳](https://bbs.ruliweb.com/community/board/300712/read/19635391)을 보면, 이런 작업과 관련된 온갖 고충을 다 볼 수 있습니다...)\n\n바로 이럴 때 Git이 필요합니다. 깃은 이런 버전 작업을 매우 쉽게 관리할 수 있도록 도와줍니다.\n\n# 🖨그냥 파일을 복사하면 안 되는가?\n\n파일을 그대로 복사하는 방식에는 약간 문제가 있습니다.\n\n- 대부분의 파일들이 수천 줄의 텍스트로 이루어졌고, 여러 개의 파일들을 동시에 수정하기 때문에 눈으로 보아서는 \u003cu\u003e무엇이 달라졌는지 알기가 아주 힘듭니다.\u003c/u\u003e 디자인에서는 큰 차이가 없다면 별 문제가 없을 수 있지만, 프로그래밍에서는 단 한 글자만 바꾸더라도 프로젝트 전체가 전혀 작동하지 않을 수도 있습니다. (e.g. 세미콜론을 빼 먹는다던가...)\n\n- 버전을 많이 만들면 많이 만들수록 \u003cu\u003e용량이 매우 빠르게 커집니다.\u003c/u\u003e 예를 들어 200MB짜리 프로젝트를 다섯 번만 백업하더라도 벌써 1GB가까운 크기가 됩니다.\n\n- 한 명의 사람이 파일 하나를 완전히 맡아 진행하는 디자인과 다르게, 프로그래머는 \u003cu\u003e협업을 하는 경우\u003c/u\u003e가 많습니다. 그런 경우 상당히 일이 복잡해집니다.\n\n  - 원본 버전에서 `개발자 A`가 파일 `a,b,c`를 수정해서 버전 `A1`을 만들었습니다.\n  - `개발자 B`는 파일 `b,c,d`를 수정해서 버전 `B1`을 만들었습니다. 심지어 `b`와 `c`는 `개발자 A,B`모두 동시에 수정한 파일들입니다.\n  - 이제 이걸 하나의 파이널 버전으로 합쳐야 하는데...음...\n\n  사실 이런 경우야 `개발자 A,B`가 모여서 하루 날 잡고 합치면 됩니다.\n\n  - 그런데 만약 개발자가 30명이나 되고, 파일이 2만개정도 된다면?\n  - 모든 개발자가 원본으로부터 개발을 시작한 게 아니라, `개발자 A`가 만든 `A1`버전으로부터 `개발자 B`가 `B1` 버전을 만들고, `B1`으로부터 `개발자 C`가 `C1`을 만들고, `A1`과 `C1`을 합친 후 `개발자 B`가 `B2`를 다시 만들고, 그것을 다시 `A1`에 합치고....와 같이 된다면?\n  - 그 와중에 프로젝트 전체 크기가 10GB나 된다면? 그래서 프로젝트를 다른 사람 컴퓨터로 복사하기만 해도 오랜 시간이 걸린다면?\n\n프로젝트가 커질수록 이런 문제들이 발생하면서, 정작 버전 관리가 개발하는 것보다 더 힘들어집니다. 이렇게 기존 방법들의 문제점을 나열한 이유는, \u003cu\u003eGit이 바로 이런 문제점을 해결하기 위해서 존재\u003c/u\u003e하기 때문입니다. 깃에는 branch 등 복잡한 기능들이 많이 있습니다. 그런 기능들이 필요한 배경을 먼저 알고 공부하면 그런 기능을 익히기 더 쉬울 것입니다.\n\n# ⚙ Git은 어떻게 동작하는가?\n\n먼저 Git이 설치되어있다는 가정 하에 실제로 설명드리겠습니다. [코딩팩토리 블로그 글](https://coding-factory.tistory.com/245)을 보시면 설명이 잘 되어 있습니다.\n\n## 리포지토리 만들기\n\n앞서 깃은 프로젝트 버전을 관리해주는 프로그램이라고 설명했었습니다. 그러려면 각 버전들이 어딘가에 저장이 돼야 할 텐데요. 그 \u003cu\u003e버전들이 저장되는 곳을 `Repository(리포지토리, 저장소)`라고 부릅니다.\u003c/u\u003e 이제 아래와 같이 프로젝트 폴더를 하나 만들고, 이 프로젝트에 리포지토리를 만들어보겠습니다.\n\n![image-20201006093218292](image-20201006093218292.png)\n\n프로젝트 폴더에서 커맨드라인 창을 열어줍니다. 파워쉘도 괜찮습니다. 파워쉘을 열기 위해서는 `Shift`키를 누른 채로 우클릭을 하면 메뉴에 파워쉘 열기 버튼이 있을 것입니다.\n\n이후 열린 커맨드라인에서 `git init` 커맨드를 입력해줍니다. 그러면 아래와 같이 깃 리포지토리가 초기화되었다는 메시지가 뜹니다.\n\n![image-20201006093451001](image-20201006093451001.png)\n\n이제 깃을 사용할 준비가 다 되었습니다.\n\n그런데 프로젝트 폴더를 보시면 아무 것도 변한 게 없습니다. 분명히 리포지토리를 생성했다고 했는데, 어떻게 된 걸까요?\n\n이는 숨김 파일을 보이도록 해 보면 알 수 있습니다.\n\n![image-20201006094604073](image-20201006094604073.png)\n\n위와 같이 `.git`이라는 숨겨진 디렉토리가 보입니다. 이 숨겨진 디렉토리 안에 깃 설정 정보, 각 버전들 등 여러 데이터가 들어 있습니다. 물론 저 폴더 안에 단순히 프로젝트 전체의 사본이 날짜별로 들어있거나 한 것은 아닙니다. 이는 아래 Git Workflow 섹션에서 설명하겠습니다.\n\n## 파일 상태\n\nGit은 파일들을 아래 이미지에서 보이는 세 가지 단계로 관리합니다. (정확히는 `파일`을 관리하는 것이 아니라 `변경사항`을 관리하는 것입니다. 그러나 이 글은 기초적인 개념을 소개하는 글이므로 이는 생략하겠습니다.)\n\n![Diagram of git stages](vxepyz5hzx5ufmptc7gx.png)\n\n`Working Directory`는 우리가 작업하고 있는 디렉토리를 말합니다. 그냥 프로젝트 폴더입니다.\n\n`Repository`는 앞서 보았듯이 버전들이 저장되는 장소입니다.\n\n`Staging Area`는 약간 헷갈리는 개념입니다. 간단히는 `Working Directory`와 `Repository` 사이에 있는 임시 저장 공간이라고 생각하시면 됩니다. 좀 차이가 있기는 합니다만, 블로그에 글을 작성할 때, 작성을 완료해서 포스팅하기 전에 임시 저장 단계가 있습니다. 그런 거라고 생각하시면 됩니다.\n\n(사실 `Staging Area`는 버전 관리에서 꼭 필요한 것은 아니라서, Git외의 다른 버전 관리 시스템에서는 이 기능이 없는 경우도 있습니다.)\n\n포스트 임시 저장과 `Staging Area`의 차이는, 포스트는 임시 저장 없이 바로 포스팅할 수 있지만 깃에서는 반드시 임시저장을 해야 하고, \u003cu\u003e임시저장을 한 내용만 새로운 버전으로 만들 수 있다는 것입니다.\u003c/u\u003e\n\n### Working Directory\n\n그러면 프로젝트에서 내 파일들이 어떤 단계에 있는지 확인해보겠습니다. 커맨드라인에 `git status`를 입력하면 다음과 같이 파일의 상태가 나옵니다.\n\n![image-20201006095639331](image-20201006095639331.png)\n\n파일이 `Untracked files`라고 되어 있는데, `Untracked` 혹은 `Modified`, `Deleted`는 임시 저장해둔 `Staging Area`의 내용과 `Working Directory`의 내용이 다르다는 것을 알려줍니다.\n\n- 우리는 아직 `Staging Area`에 아무것도 저장을 하지 않았기 때문에 임시 저장소에는 `MyTextFile.txt`자체가 없습니다. 그럴 경우 `untracked`가 표시됩니다.\n- 만약  `Staging Area`에 파일이 있기는 한데, 그 내용이 다를 경우는 `modified`가 표시됩니다.\n-  `Staging Area`에는 파일이 있는데 `Working Directory`에는 파일이 없다면 `deleted`가 표시됩니다.\n\n### Staging Area\n\n`MyTextFile.txt`파일을 임시저장하려면 `git add MyTextfile.txt`과 같이 `git add`이후에 원하는 파일 이름을 입력하면 됩니다. 만약 프로젝트 폴더 안에 있는 모든 파일들을 전부 임시저장하려면 `git add .`과 같이 파일 이름 대신 점을 쓰면 됩니다. 보통 파일을 일일이 저장하는 것은 매우 귀찮기 때문에, 특별한 일이 없으면 후자를 사용합니다.\n\n이후 `git status`를 입력하여 파일의 상태를 확인해보면 `Changes to be committed`섹션으로 파일이 이동해있습니다. 이는 파일이 `Staging Area`에 임시 저장되었다는 의미입니다. 여기에서는 파일 앞에 `new file`이라고 표시됩니다. 이것 역시 아까와 유사하게 `Repository`와 `Staging Area`의 내용이 다르다는 것을 알려줍니다.\n\n- 우리는 임시저장만 하고 어떤 버전도 생성하지 않았기 때문에 `Repository`에는 `MyTextFile.txt`가 없습니다. 그럴 경우 `new file`이라고 뜹니다.\n- 아까와 비슷하게 `Repository`에 파일이 있기는 한데 `Staging Area`와 내용이 다를 경우 `modified`가 표시됩니다.\n- `Repository`에는 파일이 있는데 `Staging Area`에는 없을 경우에는 `deleted`라고 표시됩니다.\n\n![image-20201006101816218](image-20201006101816218.png)\n\n이제 파일들을 임시저장했기 때문에, 드디어 새로운 버전을 만들 수 있습니다.\n\n### Repository\n\n여태까지 우리가 만들었던 리포지토리는 비어있던 상태였습니다. 이제 리포지토리에 새로운 버전을 추가해보겠습니다. 버전을 만드는 작업을 `Commit(커밋)`이라고 합니다.\n\n`git commit -m \"Initial commit\"` 명령어를 입력해줍니다. 뒤에 `Initial commit`부분은 각 버전에 붙는 설명인데, 이를 커밋 메시지라 합니다. 보통 이 버전이 이전 버전에서 무엇을 수정한 것인지를 써 줍니다. 우리는 맨 처음 버전을 만드는 것이고, 이전 버전이 없기 때문에 저렇게 써 주었습니다. 예를 들어 새로운 기능을 추가했다면 `Add new feature ~~`과 같이 커밋 메시지를 쓸 수 있습니다.\n\n그러면 아래와 같이 이 버전에서 어떤 일이 이루어졌는지를 알려주는 로그가 뜹니다.\n\n![image-20201006103007848](image-20201006103007848.png)\n\n메시지의 내용은 그냥 그렇구나~하고 넘기시면 됩니다. 아직 `브랜치`나 `변경 사항`에 대한 내용을 다루지 않았기 때문입니다.\n\n어쨌든 이제 새로운 버전을 만들었기 때문에, 언제든 이 버전으로 다시 돌아오거나, 이 버전과 다른 버전을 비교할 수 있습니다. 새로운 버전을 추가하고 싶으면 아래 과정을 반복하면 됩니다.\n\n1. 파일을 추가하거나 내용을 변경하는 등 여러 작업 수행\n2. `git add . `명령어를 통해 `Staging Area`로 임시저장\n3. `git commit -m \"Some message\"`명령어를 통해 새로운 커밋(버전) 생성\n\n그래서 보통 깃을 다룰 때에는 `버전`이라는 말보다는 `커밋`이라는 말을 자주 사용합니다. *변경 사항을 커밋해서...*처럼 새로운 버전을 만들었다는 의미의 동사로 사용하기도 하고, *이전 커밋을 보면...*처럼 버전이라는 의미의 명사로 사용하기도 합니다. 앞으로는 버전이라는 말 대신 커밋이라는 말을 사용하도록 하겠습니다.\n\n## 예시\n\n다음과 같은 과정을 수행해보겠습니다.\n\n1. 새로운 파일 추가\n2. git add . / git commit하여 새로운 커밋 생성\n3. 파일의 내용을 수정\n4. git add .\n5. 파일을 삭제\n6. git status\n\n그러면 아래와 같이 표시됩니다.\n\n![image-20201006113153727](image-20201006113153727.png)\n\n- 3번 단계에서 파일을 수정한 후 `git add`를 수행하여 임시저장을 했습니다. 그러므로 `Changes to be committed` 섹션에는 `Repository`와 `Staging Area`에서 파일의 내용에 차이가 있으므로 `modified`가 표시됩니다.\n- 5번 단계에서 파일을 삭제했지만, `git add`를 수행하지는 않았습니다. 그러므로 `Staging Area`에는 여전히 파일이 있으나 `Working Directory`에는 파일이 없습니다. 따라서 아래쪽 섹션에는 `deleted`가 표시됩니다.\n\n## Git Workflow\n\n그런데 맨 처음에 설명할 때, 사본을 만들 때의 단점 중 하나가 용량이 매우 커진다는 점이었습니다. 그리고 Git이 이런 문제를 해결했다고도 언급했는데, 어떻게 사본을 많이 만들면서도 용량을 적게 쓸 수 있을까요?\n\n이는 Git이 내부적으로는 `commit`을 할 때 모든 내용을 전부 다 저장하는 것이 아니라, \u003cu\u003e변경된 내용이 무엇인지만 저장\u003c/u\u003e하기 때문입니다.\n\n- 100M나 되는 매우 큰 텍스트 파일이 있다고 가정해봅시다.\n- 이때 이 파일의 123번째 줄이 `ASDF`였는데 이를 `ㅁㄴㅇㄹ`로 바꾸었습니다.\n- 그러면 Git은 새로운 커밋을 만들 때에는 `123번째 줄이 ASDF에서 ㅁㄴㅇㄹ로 바뀌었음` 이라는 정보만 저장합니다.\n\n이와 같이 Git의 각 커밋은 바로 이전 커밋으로부터 어떤 차이가 있는지만을 저장하고 있습니다. 위 리포지토리 만들기 섹션에서 `.git`폴더 안에 프로젝트의 사본이 들어있는 것은 아니라고 말했습니다. 그게 바로 이런 이유에서입니다.\n\n물론 그렇다고 해서 옛날 버전으로 돌아가기 위해서 각 커밋을 하나하나 취소해야 한다거나 하지는 않습니다. 우리가 사용할 때에는 마치 프로젝트 전체가 백업된 것처럼 사용하면 됩니다.\n\n### Git Diff\n\n추가로, 두 커밋 사이에 어떤 변화가 생겼나 확인하는 방법을 알려드리겠습니다.\n\n먼저 `git log`를 사용하면 아래와 같이 어떤 커밋들이 있었는지 그 리스트를 볼 수 있습니다.\n\n![image-20201006110420405](image-20201006110420405.png)\n\n각 커밋은 위에 보이는 `91156f75...`와 같은 고유 번호가 있습니다.\n\n이제 `git diff 커밋1고유번호 커밋2고유번호`를 입력하면 두 커밋의 차이를 볼 수 있습니다. 물론 저 긴 문자들을 다 입력할 필요는 없고 맨 앞의 네다섯 글자 정도만 입력해주면 됩니다.\n\n![image-20201006110755380](image-20201006110755380.png)\n\n만약 그냥 `git diff`를 입력하면 현재 `Working Directory`의 내용과 가장 최근 커밋을 비교하여 보여줍니다.\n\n![image-20201006110859176](image-20201006110859176.png)\n\n# 다음엔?\n\n순서는 좀 다를 수 있지만 아래와 같은 내용을 포스팅해보려 합니다.\n\n- GitHub란?\n- Branch란?\n- 공동 작업하기\n\n물론 되돌리기(Revert), Checkout 등 깃의 중요한 기능을 전혀 다루지 않았습니다. 그러나 그런 것들은 깃의 근본적인 원리만 이해했다면 다른 사람들이 설명해둔 내용을 보고 쉽게 이해할 수 있습니다. 반대로 깃의 원리를 이해하지 못하고 기능만 알고 사용한다면, 깃을 비효율적으로 사용하게 될 뿐만 아니라 오류가 나는 일(보통 커밋이 꼬인다고 함)이 많아집니다. (경험담)\n\n개인적으로는 [pro Git book 한국어판](https://git-scm.com/book/ko/v2)이 목차별로 정리가 잘 되어 있어 좋은 것 같습니다.\n\n# 요약\n\n## 깃으로 새로운 버전(커밋)만드는 방법\n\n1. 커맨드라인에 `git init` 입력하여 초기화\n2. 원하는 작업 수행\n3. `git add .`입력하여 임시저장\n4. `git commit -m \"커밋 메시지\"`입력하여 커밋.\n\n## 깃 / 커밋의 이해\n\n- 깃은 버전 관리 시스템.\n- 버전을 만드는 과정, 또는 그렇게 만들어진 각 버전을 커밋이라 부름.\n- 커밋은 프로젝트의 모든 정보를 담고 있는 것이 아니라, 이전 커밋과의 차이점만을 담고 있음.\n- 이 커밋들이 저장되는 장소를 리포지토리(Repository)라 부름. 약간 다르기는 하지만, 대충 `.git`디렉토리 안에 있다고 생각하면 됨.\n\n# 더 알아보기\n\n아래는 깃을 효율적으로 사용하기 위해 알면 좋은 것들입니다. 구체적인 사용법은 구글에 물어보시면 좋습니다.\n\n- `.gitignore` : 이 파일에 적힌 파일이나 폴더는 데스노트처럼, 깃이 아예 없는 것처럼 관리합니다. 굳이 저장할 필요 없는 파일들(e.g. 임시파일/로그파일 등)을 여기 적어두면 좋습니다.\n- `GitHub Desktop` : 깃헙에서는 깃을 GUI로 사용할 수 있는 프로그램을 제공합니다. 커맨드라인보다 사용하기가 훨씬 편리합니다.\n- `VSCode에서 Git사용하기` : VS코드에서는 아예 내부적으로 깃을 관리할 수 있는 GUI를 제공합니다. 코딩하면서 깃도 관리할 수 있어서, 개인적으로는 `GitHub Desktop`보다 이것을 훨씬 더 많이 사용합니다.","html":"\u003cp\u003e깃(Git)과 깃허브(GitHub)는 프로그래밍을 하는 사람이라면 거의 반드시 사용하는 툴입니다. 근래에는 취업 시 포트폴리오로 깃허브 계정을 제출하는 경우도 많아서, 저는 친구들이나 후배들에게 깃과 깃허브를 쓰기를 권장합니다.\u003c/p\u003e\n\u003cp\u003e그러나 인터넷을 찾아 보면 깃과 깃허브에 대해 쉽게 설명해놓은 사이트들이 잘 나오지 않았습니다. 그래서 다른 사람에게 깃에 대해 알려줄 때 좀 더 쉽게 알려주고자, 블로그에 글로 정리해두고자 합니다.\u003c/p\u003e\n\u003ch1\u003e🐙🧾Git은 왜 필요한가?\u003c/h1\u003e\n\u003cp\u003e결론부터 말하자면, \u003cu\u003eGit은 프로젝트(내부의 파일들)의 버전을 관리해주는 프로그램\u003c/u\u003e입니다.\u003c/p\u003e\n\u003cp\u003e보통 프로젝트를 진행할 때, 파일들의 특정 버전을 저장해두고 싶은 때가 있습니다. 예를 들자면,\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e프로그램을 하나 만들었더니 정상적으로 잘 동작합니다.\u003c/li\u003e\n\u003cli\u003e그런데 이때 새로운 기능을 추가하고 싶은데, 이 기능을 추가하다가 기존의 내용을 망쳐버릴 수도 있습니다.\u003c/li\u003e\n\u003cli\u003e그래서 이 버전을 다른 곳에 저장해뒀다가, 혹시라도 실패하면 가져와서 복구합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또는 이런 경우도 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e프로젝트 진행 과정을 기록해두고 싶습니다.\u003c/li\u003e\n\u003cli\u003e그래서 예를 들자면, 일주일에 한 번씩 사본을 만들어 저장해둡니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이때 사람들은 아래와 같이 파일 이름을 바꾸어서 관리하곤 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/89e0419143d90fd743da69b39954f1d5\" alt=\"img\"\u003e\u003c/p\u003e\n\u003cp\u003e(이 이미지를 \u003ca href=\"https://bbs.ruliweb.com/community/board/300712/read/19635391\"\u003e퍼온 곳\u003c/a\u003e을 보면, 이런 작업과 관련된 온갖 고충을 다 볼 수 있습니다...)\u003c/p\u003e\n\u003cp\u003e바로 이럴 때 Git이 필요합니다. 깃은 이런 버전 작업을 매우 쉽게 관리할 수 있도록 도와줍니다.\u003c/p\u003e\n\u003ch1\u003e🖨그냥 파일을 복사하면 안 되는가?\u003c/h1\u003e\n\u003cp\u003e파일을 그대로 복사하는 방식에는 약간 문제가 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e대부분의 파일들이 수천 줄의 텍스트로 이루어졌고, 여러 개의 파일들을 동시에 수정하기 때문에 눈으로 보아서는 \u003cu\u003e무엇이 달라졌는지 알기가 아주 힘듭니다.\u003c/u\u003e 디자인에서는 큰 차이가 없다면 별 문제가 없을 수 있지만, 프로그래밍에서는 단 한 글자만 바꾸더라도 프로젝트 전체가 전혀 작동하지 않을 수도 있습니다. (e.g. 세미콜론을 빼 먹는다던가...)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e버전을 많이 만들면 많이 만들수록 \u003cu\u003e용량이 매우 빠르게 커집니다.\u003c/u\u003e 예를 들어 200MB짜리 프로젝트를 다섯 번만 백업하더라도 벌써 1GB가까운 크기가 됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e한 명의 사람이 파일 하나를 완전히 맡아 진행하는 디자인과 다르게, 프로그래머는 \u003cu\u003e협업을 하는 경우\u003c/u\u003e가 많습니다. 그런 경우 상당히 일이 복잡해집니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e원본 버전에서 \u003ccode\u003e개발자 A\u003c/code\u003e가 파일 \u003ccode\u003ea,b,c\u003c/code\u003e를 수정해서 버전 \u003ccode\u003eA1\u003c/code\u003e을 만들었습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e개발자 B\u003c/code\u003e는 파일 \u003ccode\u003eb,c,d\u003c/code\u003e를 수정해서 버전 \u003ccode\u003eB1\u003c/code\u003e을 만들었습니다. 심지어 \u003ccode\u003eb\u003c/code\u003e와 \u003ccode\u003ec\u003c/code\u003e는 \u003ccode\u003e개발자 A,B\u003c/code\u003e모두 동시에 수정한 파일들입니다.\u003c/li\u003e\n\u003cli\u003e이제 이걸 하나의 파이널 버전으로 합쳐야 하는데...음...\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e사실 이런 경우야 \u003ccode\u003e개발자 A,B\u003c/code\u003e가 모여서 하루 날 잡고 합치면 됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e그런데 만약 개발자가 30명이나 되고, 파일이 2만개정도 된다면?\u003c/li\u003e\n\u003cli\u003e모든 개발자가 원본으로부터 개발을 시작한 게 아니라, \u003ccode\u003e개발자 A\u003c/code\u003e가 만든 \u003ccode\u003eA1\u003c/code\u003e버전으로부터 \u003ccode\u003e개발자 B\u003c/code\u003e가 \u003ccode\u003eB1\u003c/code\u003e 버전을 만들고, \u003ccode\u003eB1\u003c/code\u003e으로부터 \u003ccode\u003e개발자 C\u003c/code\u003e가 \u003ccode\u003eC1\u003c/code\u003e을 만들고, \u003ccode\u003eA1\u003c/code\u003e과 \u003ccode\u003eC1\u003c/code\u003e을 합친 후 \u003ccode\u003e개발자 B\u003c/code\u003e가 \u003ccode\u003eB2\u003c/code\u003e를 다시 만들고, 그것을 다시 \u003ccode\u003eA1\u003c/code\u003e에 합치고....와 같이 된다면?\u003c/li\u003e\n\u003cli\u003e그 와중에 프로젝트 전체 크기가 10GB나 된다면? 그래서 프로젝트를 다른 사람 컴퓨터로 복사하기만 해도 오랜 시간이 걸린다면?\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e프로젝트가 커질수록 이런 문제들이 발생하면서, 정작 버전 관리가 개발하는 것보다 더 힘들어집니다. 이렇게 기존 방법들의 문제점을 나열한 이유는, \u003cu\u003eGit이 바로 이런 문제점을 해결하기 위해서 존재\u003c/u\u003e하기 때문입니다. 깃에는 branch 등 복잡한 기능들이 많이 있습니다. 그런 기능들이 필요한 배경을 먼저 알고 공부하면 그런 기능을 익히기 더 쉬울 것입니다.\u003c/p\u003e\n\u003ch1\u003e⚙ Git은 어떻게 동작하는가?\u003c/h1\u003e\n\u003cp\u003e먼저 Git이 설치되어있다는 가정 하에 실제로 설명드리겠습니다. \u003ca href=\"https://coding-factory.tistory.com/245\"\u003e코딩팩토리 블로그 글\u003c/a\u003e을 보시면 설명이 잘 되어 있습니다.\u003c/p\u003e\n\u003ch2\u003e리포지토리 만들기\u003c/h2\u003e\n\u003cp\u003e앞서 깃은 프로젝트 버전을 관리해주는 프로그램이라고 설명했었습니다. 그러려면 각 버전들이 어딘가에 저장이 돼야 할 텐데요. 그 \u003cu\u003e버전들이 저장되는 곳을 \u003ccode\u003eRepository(리포지토리, 저장소)\u003c/code\u003e라고 부릅니다.\u003c/u\u003e 이제 아래와 같이 프로젝트 폴더를 하나 만들고, 이 프로젝트에 리포지토리를 만들어보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/cc72ac8caf0eae03750bd3a75c2ee04a.png\" alt=\"image-20201006093218292\"\u003e\u003c/p\u003e\n\u003cp\u003e프로젝트 폴더에서 커맨드라인 창을 열어줍니다. 파워쉘도 괜찮습니다. 파워쉘을 열기 위해서는 \u003ccode\u003eShift\u003c/code\u003e키를 누른 채로 우클릭을 하면 메뉴에 파워쉘 열기 버튼이 있을 것입니다.\u003c/p\u003e\n\u003cp\u003e이후 열린 커맨드라인에서 \u003ccode\u003egit init\u003c/code\u003e 커맨드를 입력해줍니다. 그러면 아래와 같이 깃 리포지토리가 초기화되었다는 메시지가 뜹니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/d57b8d39b7eaa285bb9c01a637f0ec5f.png\" alt=\"image-20201006093451001\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 깃을 사용할 준비가 다 되었습니다.\u003c/p\u003e\n\u003cp\u003e그런데 프로젝트 폴더를 보시면 아무 것도 변한 게 없습니다. 분명히 리포지토리를 생성했다고 했는데, 어떻게 된 걸까요?\u003c/p\u003e\n\u003cp\u003e이는 숨김 파일을 보이도록 해 보면 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/c403e143e7c9e2d7b013cc7204957650.png\" alt=\"image-20201006094604073\"\u003e\u003c/p\u003e\n\u003cp\u003e위와 같이 \u003ccode\u003e.git\u003c/code\u003e이라는 숨겨진 디렉토리가 보입니다. 이 숨겨진 디렉토리 안에 깃 설정 정보, 각 버전들 등 여러 데이터가 들어 있습니다. 물론 저 폴더 안에 단순히 프로젝트 전체의 사본이 날짜별로 들어있거나 한 것은 아닙니다. 이는 아래 Git Workflow 섹션에서 설명하겠습니다.\u003c/p\u003e\n\u003ch2\u003e파일 상태\u003c/h2\u003e\n\u003cp\u003eGit은 파일들을 아래 이미지에서 보이는 세 가지 단계로 관리합니다. (정확히는 \u003ccode\u003e파일\u003c/code\u003e을 관리하는 것이 아니라 \u003ccode\u003e변경사항\u003c/code\u003e을 관리하는 것입니다. 그러나 이 글은 기초적인 개념을 소개하는 글이므로 이는 생략하겠습니다.)\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/e480e48c33006c77bba0c62453ce0934.png\" alt=\"Diagram of git stages\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eWorking Directory\u003c/code\u003e는 우리가 작업하고 있는 디렉토리를 말합니다. 그냥 프로젝트 폴더입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eRepository\u003c/code\u003e는 앞서 보았듯이 버전들이 저장되는 장소입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eStaging Area\u003c/code\u003e는 약간 헷갈리는 개념입니다. 간단히는 \u003ccode\u003eWorking Directory\u003c/code\u003e와 \u003ccode\u003eRepository\u003c/code\u003e 사이에 있는 임시 저장 공간이라고 생각하시면 됩니다. 좀 차이가 있기는 합니다만, 블로그에 글을 작성할 때, 작성을 완료해서 포스팅하기 전에 임시 저장 단계가 있습니다. 그런 거라고 생각하시면 됩니다.\u003c/p\u003e\n\u003cp\u003e(사실 \u003ccode\u003eStaging Area\u003c/code\u003e는 버전 관리에서 꼭 필요한 것은 아니라서, Git외의 다른 버전 관리 시스템에서는 이 기능이 없는 경우도 있습니다.)\u003c/p\u003e\n\u003cp\u003e포스트 임시 저장과 \u003ccode\u003eStaging Area\u003c/code\u003e의 차이는, 포스트는 임시 저장 없이 바로 포스팅할 수 있지만 깃에서는 반드시 임시저장을 해야 하고, \u003cu\u003e임시저장을 한 내용만 새로운 버전으로 만들 수 있다는 것입니다.\u003c/u\u003e\u003c/p\u003e\n\u003ch3\u003eWorking Directory\u003c/h3\u003e\n\u003cp\u003e그러면 프로젝트에서 내 파일들이 어떤 단계에 있는지 확인해보겠습니다. 커맨드라인에 \u003ccode\u003egit status\u003c/code\u003e를 입력하면 다음과 같이 파일의 상태가 나옵니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/1d8825abfc5b01de109e8f78fa941755.png\" alt=\"image-20201006095639331\"\u003e\u003c/p\u003e\n\u003cp\u003e파일이 \u003ccode\u003eUntracked files\u003c/code\u003e라고 되어 있는데, \u003ccode\u003eUntracked\u003c/code\u003e 혹은 \u003ccode\u003eModified\u003c/code\u003e, \u003ccode\u003eDeleted\u003c/code\u003e는 임시 저장해둔 \u003ccode\u003eStaging Area\u003c/code\u003e의 내용과 \u003ccode\u003eWorking Directory\u003c/code\u003e의 내용이 다르다는 것을 알려줍니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e우리는 아직 \u003ccode\u003eStaging Area\u003c/code\u003e에 아무것도 저장을 하지 않았기 때문에 임시 저장소에는 \u003ccode\u003eMyTextFile.txt\u003c/code\u003e자체가 없습니다. 그럴 경우 \u003ccode\u003euntracked\u003c/code\u003e가 표시됩니다.\u003c/li\u003e\n\u003cli\u003e만약  \u003ccode\u003eStaging Area\u003c/code\u003e에 파일이 있기는 한데, 그 내용이 다를 경우는 \u003ccode\u003emodified\u003c/code\u003e가 표시됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eStaging Area\u003c/code\u003e에는 파일이 있는데 \u003ccode\u003eWorking Directory\u003c/code\u003e에는 파일이 없다면 \u003ccode\u003edeleted\u003c/code\u003e가 표시됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStaging Area\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eMyTextFile.txt\u003c/code\u003e파일을 임시저장하려면 \u003ccode\u003egit add MyTextfile.txt\u003c/code\u003e과 같이 \u003ccode\u003egit add\u003c/code\u003e이후에 원하는 파일 이름을 입력하면 됩니다. 만약 프로젝트 폴더 안에 있는 모든 파일들을 전부 임시저장하려면 \u003ccode\u003egit add .\u003c/code\u003e과 같이 파일 이름 대신 점을 쓰면 됩니다. 보통 파일을 일일이 저장하는 것은 매우 귀찮기 때문에, 특별한 일이 없으면 후자를 사용합니다.\u003c/p\u003e\n\u003cp\u003e이후 \u003ccode\u003egit status\u003c/code\u003e를 입력하여 파일의 상태를 확인해보면 \u003ccode\u003eChanges to be committed\u003c/code\u003e섹션으로 파일이 이동해있습니다. 이는 파일이 \u003ccode\u003eStaging Area\u003c/code\u003e에 임시 저장되었다는 의미입니다. 여기에서는 파일 앞에 \u003ccode\u003enew file\u003c/code\u003e이라고 표시됩니다. 이것 역시 아까와 유사하게 \u003ccode\u003eRepository\u003c/code\u003e와 \u003ccode\u003eStaging Area\u003c/code\u003e의 내용이 다르다는 것을 알려줍니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e우리는 임시저장만 하고 어떤 버전도 생성하지 않았기 때문에 \u003ccode\u003eRepository\u003c/code\u003e에는 \u003ccode\u003eMyTextFile.txt\u003c/code\u003e가 없습니다. 그럴 경우 \u003ccode\u003enew file\u003c/code\u003e이라고 뜹니다.\u003c/li\u003e\n\u003cli\u003e아까와 비슷하게 \u003ccode\u003eRepository\u003c/code\u003e에 파일이 있기는 한데 \u003ccode\u003eStaging Area\u003c/code\u003e와 내용이 다를 경우 \u003ccode\u003emodified\u003c/code\u003e가 표시됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRepository\u003c/code\u003e에는 파일이 있는데 \u003ccode\u003eStaging Area\u003c/code\u003e에는 없을 경우에는 \u003ccode\u003edeleted\u003c/code\u003e라고 표시됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/4db365307fbb03084bf0cedf9ce902e7.png\" alt=\"image-20201006101816218\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 파일들을 임시저장했기 때문에, 드디어 새로운 버전을 만들 수 있습니다.\u003c/p\u003e\n\u003ch3\u003eRepository\u003c/h3\u003e\n\u003cp\u003e여태까지 우리가 만들었던 리포지토리는 비어있던 상태였습니다. 이제 리포지토리에 새로운 버전을 추가해보겠습니다. 버전을 만드는 작업을 \u003ccode\u003eCommit(커밋)\u003c/code\u003e이라고 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egit commit -m \u0026quot;Initial commit\u0026quot;\u003c/code\u003e 명령어를 입력해줍니다. 뒤에 \u003ccode\u003eInitial commit\u003c/code\u003e부분은 각 버전에 붙는 설명인데, 이를 커밋 메시지라 합니다. 보통 이 버전이 이전 버전에서 무엇을 수정한 것인지를 써 줍니다. 우리는 맨 처음 버전을 만드는 것이고, 이전 버전이 없기 때문에 저렇게 써 주었습니다. 예를 들어 새로운 기능을 추가했다면 \u003ccode\u003eAdd new feature ~~\u003c/code\u003e과 같이 커밋 메시지를 쓸 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러면 아래와 같이 이 버전에서 어떤 일이 이루어졌는지를 알려주는 로그가 뜹니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/e8f016466d6e7752724ecf723b635fa8.png\" alt=\"image-20201006103007848\"\u003e\u003c/p\u003e\n\u003cp\u003e메시지의 내용은 그냥 그렇구나~하고 넘기시면 됩니다. 아직 \u003ccode\u003e브랜치\u003c/code\u003e나 \u003ccode\u003e변경 사항\u003c/code\u003e에 대한 내용을 다루지 않았기 때문입니다.\u003c/p\u003e\n\u003cp\u003e어쨌든 이제 새로운 버전을 만들었기 때문에, 언제든 이 버전으로 다시 돌아오거나, 이 버전과 다른 버전을 비교할 수 있습니다. 새로운 버전을 추가하고 싶으면 아래 과정을 반복하면 됩니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e파일을 추가하거나 내용을 변경하는 등 여러 작업 수행\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egit add . \u003c/code\u003e명령어를 통해 \u003ccode\u003eStaging Area\u003c/code\u003e로 임시저장\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egit commit -m \u0026quot;Some message\u0026quot;\u003c/code\u003e명령어를 통해 새로운 커밋(버전) 생성\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e그래서 보통 깃을 다룰 때에는 \u003ccode\u003e버전\u003c/code\u003e이라는 말보다는 \u003ccode\u003e커밋\u003c/code\u003e이라는 말을 자주 사용합니다. *변경 사항을 커밋해서...*처럼 새로운 버전을 만들었다는 의미의 동사로 사용하기도 하고, *이전 커밋을 보면...*처럼 버전이라는 의미의 명사로 사용하기도 합니다. 앞으로는 버전이라는 말 대신 커밋이라는 말을 사용하도록 하겠습니다.\u003c/p\u003e\n\u003ch2\u003e예시\u003c/h2\u003e\n\u003cp\u003e다음과 같은 과정을 수행해보겠습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e새로운 파일 추가\u003c/li\u003e\n\u003cli\u003egit add . / git commit하여 새로운 커밋 생성\u003c/li\u003e\n\u003cli\u003e파일의 내용을 수정\u003c/li\u003e\n\u003cli\u003egit add .\u003c/li\u003e\n\u003cli\u003e파일을 삭제\u003c/li\u003e\n\u003cli\u003egit status\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e그러면 아래와 같이 표시됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/5107e4730a1abd8249a198115e58ce0f.png\" alt=\"image-20201006113153727\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e3번 단계에서 파일을 수정한 후 \u003ccode\u003egit add\u003c/code\u003e를 수행하여 임시저장을 했습니다. 그러므로 \u003ccode\u003eChanges to be committed\u003c/code\u003e 섹션에는 \u003ccode\u003eRepository\u003c/code\u003e와 \u003ccode\u003eStaging Area\u003c/code\u003e에서 파일의 내용에 차이가 있으므로 \u003ccode\u003emodified\u003c/code\u003e가 표시됩니다.\u003c/li\u003e\n\u003cli\u003e5번 단계에서 파일을 삭제했지만, \u003ccode\u003egit add\u003c/code\u003e를 수행하지는 않았습니다. 그러므로 \u003ccode\u003eStaging Area\u003c/code\u003e에는 여전히 파일이 있으나 \u003ccode\u003eWorking Directory\u003c/code\u003e에는 파일이 없습니다. 따라서 아래쪽 섹션에는 \u003ccode\u003edeleted\u003c/code\u003e가 표시됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eGit Workflow\u003c/h2\u003e\n\u003cp\u003e그런데 맨 처음에 설명할 때, 사본을 만들 때의 단점 중 하나가 용량이 매우 커진다는 점이었습니다. 그리고 Git이 이런 문제를 해결했다고도 언급했는데, 어떻게 사본을 많이 만들면서도 용량을 적게 쓸 수 있을까요?\u003c/p\u003e\n\u003cp\u003e이는 Git이 내부적으로는 \u003ccode\u003ecommit\u003c/code\u003e을 할 때 모든 내용을 전부 다 저장하는 것이 아니라, \u003cu\u003e변경된 내용이 무엇인지만 저장\u003c/u\u003e하기 때문입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e100M나 되는 매우 큰 텍스트 파일이 있다고 가정해봅시다.\u003c/li\u003e\n\u003cli\u003e이때 이 파일의 123번째 줄이 \u003ccode\u003eASDF\u003c/code\u003e였는데 이를 \u003ccode\u003eㅁㄴㅇㄹ\u003c/code\u003e로 바꾸었습니다.\u003c/li\u003e\n\u003cli\u003e그러면 Git은 새로운 커밋을 만들 때에는 \u003ccode\u003e123번째 줄이 ASDF에서 ㅁㄴㅇㄹ로 바뀌었음\u003c/code\u003e 이라는 정보만 저장합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이와 같이 Git의 각 커밋은 바로 이전 커밋으로부터 어떤 차이가 있는지만을 저장하고 있습니다. 위 리포지토리 만들기 섹션에서 \u003ccode\u003e.git\u003c/code\u003e폴더 안에 프로젝트의 사본이 들어있는 것은 아니라고 말했습니다. 그게 바로 이런 이유에서입니다.\u003c/p\u003e\n\u003cp\u003e물론 그렇다고 해서 옛날 버전으로 돌아가기 위해서 각 커밋을 하나하나 취소해야 한다거나 하지는 않습니다. 우리가 사용할 때에는 마치 프로젝트 전체가 백업된 것처럼 사용하면 됩니다.\u003c/p\u003e\n\u003ch3\u003eGit Diff\u003c/h3\u003e\n\u003cp\u003e추가로, 두 커밋 사이에 어떤 변화가 생겼나 확인하는 방법을 알려드리겠습니다.\u003c/p\u003e\n\u003cp\u003e먼저 \u003ccode\u003egit log\u003c/code\u003e를 사용하면 아래와 같이 어떤 커밋들이 있었는지 그 리스트를 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/200f0d7430f28b48bd53ad3e44afb810.png\" alt=\"image-20201006110420405\"\u003e\u003c/p\u003e\n\u003cp\u003e각 커밋은 위에 보이는 \u003ccode\u003e91156f75...\u003c/code\u003e와 같은 고유 번호가 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 \u003ccode\u003egit diff 커밋1고유번호 커밋2고유번호\u003c/code\u003e를 입력하면 두 커밋의 차이를 볼 수 있습니다. 물론 저 긴 문자들을 다 입력할 필요는 없고 맨 앞의 네다섯 글자 정도만 입력해주면 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/0b9827cb08286961d9103f2a7938e4c1.png\" alt=\"image-20201006110755380\"\u003e\u003c/p\u003e\n\u003cp\u003e만약 그냥 \u003ccode\u003egit diff\u003c/code\u003e를 입력하면 현재 \u003ccode\u003eWorking Directory\u003c/code\u003e의 내용과 가장 최근 커밋을 비교하여 보여줍니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/2ada38dba9ea957ba579e9f319fa4721.png\" alt=\"image-20201006110859176\"\u003e\u003c/p\u003e\n\u003ch1\u003e다음엔?\u003c/h1\u003e\n\u003cp\u003e순서는 좀 다를 수 있지만 아래와 같은 내용을 포스팅해보려 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGitHub란?\u003c/li\u003e\n\u003cli\u003eBranch란?\u003c/li\u003e\n\u003cli\u003e공동 작업하기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e물론 되돌리기(Revert), Checkout 등 깃의 중요한 기능을 전혀 다루지 않았습니다. 그러나 그런 것들은 깃의 근본적인 원리만 이해했다면 다른 사람들이 설명해둔 내용을 보고 쉽게 이해할 수 있습니다. 반대로 깃의 원리를 이해하지 못하고 기능만 알고 사용한다면, 깃을 비효율적으로 사용하게 될 뿐만 아니라 오류가 나는 일(보통 커밋이 꼬인다고 함)이 많아집니다. (경험담)\u003c/p\u003e\n\u003cp\u003e개인적으로는 \u003ca href=\"https://git-scm.com/book/ko/v2\"\u003epro Git book 한국어판\u003c/a\u003e이 목차별로 정리가 잘 되어 있어 좋은 것 같습니다.\u003c/p\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003ch2\u003e깃으로 새로운 버전(커밋)만드는 방법\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e커맨드라인에 \u003ccode\u003egit init\u003c/code\u003e 입력하여 초기화\u003c/li\u003e\n\u003cli\u003e원하는 작업 수행\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egit add .\u003c/code\u003e입력하여 임시저장\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egit commit -m \u0026quot;커밋 메시지\u0026quot;\u003c/code\u003e입력하여 커밋.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e깃 / 커밋의 이해\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e깃은 버전 관리 시스템.\u003c/li\u003e\n\u003cli\u003e버전을 만드는 과정, 또는 그렇게 만들어진 각 버전을 커밋이라 부름.\u003c/li\u003e\n\u003cli\u003e커밋은 프로젝트의 모든 정보를 담고 있는 것이 아니라, 이전 커밋과의 차이점만을 담고 있음.\u003c/li\u003e\n\u003cli\u003e이 커밋들이 저장되는 장소를 리포지토리(Repository)라 부름. 약간 다르기는 하지만, 대충 \u003ccode\u003e.git\u003c/code\u003e디렉토리 안에 있다고 생각하면 됨.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e더 알아보기\u003c/h1\u003e\n\u003cp\u003e아래는 깃을 효율적으로 사용하기 위해 알면 좋은 것들입니다. 구체적인 사용법은 구글에 물어보시면 좋습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e.gitignore\u003c/code\u003e : 이 파일에 적힌 파일이나 폴더는 데스노트처럼, 깃이 아예 없는 것처럼 관리합니다. 굳이 저장할 필요 없는 파일들(e.g. 임시파일/로그파일 등)을 여기 적어두면 좋습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGitHub Desktop\u003c/code\u003e : 깃헙에서는 깃을 GUI로 사용할 수 있는 프로그램을 제공합니다. 커맨드라인보다 사용하기가 훨씬 편리합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eVSCode에서 Git사용하기\u003c/code\u003e : VS코드에서는 아예 내부적으로 깃을 관리할 수 있는 GUI를 제공합니다. 코딩하면서 깃도 관리할 수 있어서, 개인적으로는 \u003ccode\u003eGitHub Desktop\u003c/code\u003e보다 이것을 훨씬 더 많이 사용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n","imageMapping":{"52B979BD503F240029":"/imgs/89e0419143d90fd743da69b39954f1d5","image-20201006093218292.png":"/imgs/cc72ac8caf0eae03750bd3a75c2ee04a.png","image-20201006093451001.png":"/imgs/d57b8d39b7eaa285bb9c01a637f0ec5f.png","image-20201006094604073.png":"/imgs/c403e143e7c9e2d7b013cc7204957650.png","vxepyz5hzx5ufmptc7gx.png":"/imgs/e480e48c33006c77bba0c62453ce0934.png","image-20201006095639331.png":"/imgs/1d8825abfc5b01de109e8f78fa941755.png","image-20201006101816218.png":"/imgs/4db365307fbb03084bf0cedf9ce902e7.png","image-20201006103007848.png":"/imgs/e8f016466d6e7752724ecf723b635fa8.png","image-20201006113153727.png":"/imgs/5107e4730a1abd8249a198115e58ce0f.png","image-20201006110420405.png":"/imgs/200f0d7430f28b48bd53ad3e44afb810.png","image-20201006110755380.png":"/imgs/0b9827cb08286961d9103f2a7938e4c1.png","image-20201006110859176.png":"/imgs/2ada38dba9ea957ba579e9f319fa4721.png"},"name":"2020-10-06-git-github"},"postsInSameCategory":[{"name":"2020-10-06-git-github","title":"Git / GitHub[1] - Git 기초","date":"2020-10-06T03:16:55.258Z","category":"git"}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2020-10-06-git-github"},"buildId":"bg3GNayTREst1g1Voz8hR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>