<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="description" content="Unknownpgr&#x27;s Blog"/><link rel="icon" href="/favicon.png"/><meta property="og:title" content="Unknownpgr&#x27;s Blog"/><meta property="og:url" content="https://unknownpgr.com"/><meta property="og:image" content="/logo.png"/><title>Unknownpgr : 블로그 개발을 시작하다👨‍💻[5] - SPA</title><meta property="og:title" content="Unknownpgr: 블로그 개발을 시작하다👨‍💻[5] - SPA"/><meta name="next-head-count" content="9"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/dd9689b07a67431e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/dd9689b07a67431e.css" data-n-g=""/><link rel="preload" href="/_next/static/css/14062eec27ee8c3f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/14062eec27ee8c3f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-1cd5204319a0e744.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b2167bfc37ff4f0b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-fe089d9906e2f51a.js" defer=""></script><script src="/_next/static/5acpRZgm_5FalkhKxD4A7/_buildManifest.js" defer=""></script><script src="/_next/static/5acpRZgm_5FalkhKxD4A7/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="nav_nav__XkaAa"><a class="nav_logo__drPJg" href="/">[UNKNOWN-PGR]</a><a class="nav_link__KHlEJ" href="/">Home</a><a class="nav_link__KHlEJ" href="/categories/">Categories</a><a class="nav_link__KHlEJ" href="/about/">About</a></nav><main class="layout_main__j5lor"><div><h1 class="post_title__aQveY">블로그 개발을 시작하다👨‍💻[5] - SPA</h1><main class="post_main__mmVmG"><p>이전 포스트에서 다뤘던 이모지 문제를 해결한 후, 더이상 문제될 것은 없다고 생각했었습니다. 그런데 프로그래밍이라는 것이 항상 그렇듯이, 언제나 새로운 문제가 생깁니다.</p>
<p><img src="/imgs/8c0b7e2cb9308f7cb1c516bd5c2a492c.jpg" alt="r/ProgrammerHumor - Debugging be like... 출처 : https://www.reddit.com/r/ProgrammerHumor/comments/9g4vml/debugging_be_like/"></p>
<p>바로 블로그를 Single Page Application으로 개발했다는 점입니다.</p>
<h1>SPA(Single Page Application)의 역사</h1>
<p>문제에 앞서, SPA가 무엇인지를 한번 알아봅시다.</p>
<h2>기존 웹페이지의 문제점</h2>
<p>SPA라는 개념이 생기기 전의 웹사이트에서는 새로운 내용을 보여주려면 <u>서버에서 매번 새로운 html파일을 로드</u>해야 했었습니다.  이런 경우, 단점이 몇 가지 생깁니다.</p>
<ul>
<li>페이지 전체를 새로고침해야 하므로, 페이지가 렌더링되는 동안 유저는 빈 화면을 보면서 기다려야 합니다.</li>
<li>Header나 Footer같이 실제로는 여러 페이지에 공통적으로 나오는 요소들도 매번 새롭게 다운로드 / 렌더링됩니다.</li>
<li>그러므로 웹페이지가 보여지는 데에 시간이 오래 걸립니다.</li>
<li>새로고침하는동안 페이지가 깜빡거리게 되므로, 미관상 좋지 않습니다.</li>
</ul>
<h2>SPA의 개념</h2>
<p>그래서 SPA라는 개념이 생겨났습니다. SPA는 Single Page Application의 약자로, 웹페이지를 매번 새롭게 로딩하는 것이 아니라 <u>JavaScript를 사용하여 필요한 부분만을 새로 로딩</u>하는 방식을 의미합니다.</p>
<ul>
<li>예를 들어, 제 블로그의 카테고리를 이동하면, 모든 구성요소를 새로 렌더링하는 것이 아니라 꼭 필요한 부분인 포스트 리스트만을 새로 렌더링합니다.</li>
<li><a href="https://reactrouter.com/native/example/Basic">React Router</a> 사이트에서, 왼쪽 Examples 섹션의 각 예제들을 눌러보시면 감이 더 잘 올 것 같습니다.</li>
</ul>
<p>따라서 웹페이지를 SPA로 구성하면, 다양한 화면을 보여주기 위해 단 하나의 html / js만 있으면 충분합니다. 웹페이지를 변경할 필요가 있을 때에는 필요한 부분만 바꾸면 되기 때문입니다.</p>
<h2>초기 SPA의 치명적 단점</h2>
<p>물론 SPA가 처음 등장했을 때부터 완벽하지는 않아서, 초기에는 단점이 몇 가지 있었습니다.</p>
<h3>특정 페이지로 이동 불가능</h3>
<p>예를 들어, <a href="http://www.koreacontents.or.kr/">한국콘텐츠학회</a>의 웹페이지는 SPA로 구성되어있습니다. (누가 만들었는지는 모르겠지만, SPA인 주제에 페이지를 이동할 때마다 새롭게 렌더링되는군요.🤔) 그러므로 이 사이트에서 특정 페이지로 이동한 후, URL을 복사하여 새 탭에서 열어보면 그냥 메인 페이지가 열립니다. 뿐만 아니라, 단순히 새로고침만 하더라도 메인 페이지로 이동해버립니다</p>
<h3>History 관리가 안 됨</h3>
<p>웹브라우저에서 뒤로가기 버튼을 누르면, 브라우저는 사용자를 직전의 URL로 이동시킵니다. 그런데 SPA는 URL변화가 없기 때문에, 한 사이트 내에서 뒤로가기 등이 전혀 작동하지 않았습니다.</p>
<h3>검색 안 됨(❗)</h3>
<p>그리고 궁극적으로, <strong>검색이 안 됩니다.</strong></p>
<p>보통 검색 엔진들은 사이트의 URL을 기준으로 페이지를 구분합니다. 그런데 SPA로 구성한 웹페이지의 경우, 내용이 아무리 많더라도 사이트의 URL은 단 하나밖에 없습니다. <code>index.html</code>파일 하나 내에서 모든 과정이 다 이루어지기 때문입니다. 그러므로 검색 엔진은 맨 처음에 로딩되는 딱 하나의 페이지만이 존재하는 것으로 인식합니다. 쇼핑몰, 블로그, 카페, 위키백과...등 각 페이지의 내용이 중요한 사이트의 경우, 검색이 안 되는 것은 치명적인 단점입니다.</p>
<h2>HTML5-History API의 등장</h2>
<p>이후 이런 문제점을 해결하는 여러 방법이 등장하였습니다.</p>
<h3>Hash</h3>
<p>그중 하나는 Hash입니다. <u>Hash란 한 페이지 내에서 특정 엘리먼트로 이동할 때 사용</u>하는 URL 형식으로, URL뒤에 <code>#ELEMENT_ID</code>와 같이 특정 엘리먼트의 ID를 추가하면 됩니다. 위키백과에서 쉽게 발견할 수 있습니다.</p>
<pre><code>https://en.wikipedia.org/wiki/Single-page_application#Technical_approaches
</code></pre>
<p>위 URL을 자세히 살펴보면 뒷부분에 <code>#</code>으로 시작하는 부분이 있습니다. 이것이 바로 Hash입니다. <a href="https://en.wikipedia.org/wiki/Single-page_application#Technical_approaches">위 URL</a>로 접속해보면 페이지의 맨 위로 이동하는 것이 아니라 <code>id</code>가 <code>Technical_approaches</code>인 엘리먼트가 있는 위치로 이동합니다. Hash는 한 사이트 내에서 엘리먼트의 위치를 가리키기 때문에, <code>&lt;a&gt;</code>태그나 JavaScript를 사용하여 URL의 Hash를 바꾸는 경우 URL은 변하지만 웹페이지가 새로 로딩되지는 않습니다. 그래서 어떤 라이브러리들의 경우 이를 이용하여 SPA를 구현했었습니다. (아마 <a href="https://angular.io/">Angular</a>가 이런 방식을 사용하는 것으로 압니다.)</p>
<p>물론 Hash도 완벽한 솔루션은 아니었습니다. 일단 위에서 언급한 첫 번째와 두 번째 문제는 해결되었지만, 어떤 검색 엔진들은 Hash를 무시해버리기 때문에 역시 검색이 잘 되지 않는 문제가 있었습니다.</p>
<p>그리고 이는 정석이 아니라 일종의 트릭이므로, URL이 보기에 어색해집니다.</p>
<pre><code>https://unknownpgr.github.io/#/posts/some-post
</code></pre>
<p>...아무래도 중간에 이상한 것이 끼이니, 영 어색합니다.</p>
<h3>HTML5 History API</h3>
<p>그러나 HTML5가 등장하면서, 모든 문제점이 한 번에 사라집니다.</p>
<p>HTML5의 기능 중에는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">History API</a>라는 것이 있습니다. 요약하자면 URL 및 History를 마음대로 조작할 수 있는 기능입니다. 이전에는 주소창의 URL을 바꾸려면 실제로 페이지를 이동해야만 했지만, 이제는 History API를 이용하여 페이지 이동 없이도 새로운 사이트를 방문한 것처럼 URL을 조작할 수 있게 되었습니다.</p>
<p>그리고 이를 이용하여 React의 Browser Router가 등장하였습니다. Browser Router란 새로운 페이지로 이동할 때 실제로는 페이지 라우팅이 전혀 일어나지 않지만 <u>URL을 바꾸어 페이지를 이동한 것처럼 보이게 하는 기술</u>입니다. <a href="https://reactrouter.com/">React Router</a>라는 라이브러리를 사용하여 이를 사용할 수 있습니다.</p>
<h1>GitHub Page의 역습</h1>
<p>그래서 저는 SPA로 블로그를 만드는 것에 아무런 문제가 없음을 믿어 의심치 않았습니다. 그런데 GitHub Page가 정적 웹서버를 사용하여 호스팅된다는 것이 문제였습니다.</p>
<p>예를 들어 <code>https://unknownpgr.github.io/posts/blog-dev-4</code>페이지의 경우, 실제로 저런 경로가 존재하는 것이 아닙니다. 실제로 존재하는 것은 <code>https://unknownpgr.github.io/index.html</code>파일밖에 없고, 위의 URL은 Browser Router를 통해 URL만을 바꾼 것입니다. 하지만 이런 사실을 전혀 모르는 GitHub Page의 정적 서버는 <code>https://unknownpgr.github.io/posts/blog-dev-4</code>라는 파일이 없다고 생각하여 저 경로로 접근하면 404를 반환합니다.</p>
<h2>해결 방법</h2>
<p>물론 하늘이 무너져도 솟아날 구멍은 있는 법이어서, 다행스럽게도 해결 방법이 있었습니다.</p>
<p>GitHub에서 루트 디렉토리에 <code>404.html</code>을 만들면 404 발생 시 GitHub Page의 기본 404 페이지 대신 저 페이지가 나옵니다. 이를 이용하여 404페이지에서 다시 메인 페이지(<code>/</code>)로 리다이렉트하되, GET parameter를 사용하여 원래 어떤 페이지가 요청되었는지를 반환하는 것입니다.</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 404.html --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
    <span class="hljs-keyword">const</span> url = <span class="hljs-string">`/?page=<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-variable language_">window</span>.location.pathname)}</span>`</span>;
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">replace</span>(url);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>이후, 메인 페이지에서는 <code>page</code> 파라매터를 검사, 만약 파라매터가 존재하면 Browser Router를 사용하여 해당 페이지로 리다이렉트시켜줍니다.</p>
<pre><code class="language-jsx"><span class="hljs-comment">// App.js</span>
...
<span class="hljs-keyword">let</span> param = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>);
<span class="hljs-keyword">let</span> redirect = <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">if</span> (param.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;page=&quot;</span>) &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">let</span> dest = <span class="hljs-built_in">decodeURIComponent</span>(param.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;page=&quot;</span>, <span class="hljs-string">&quot;&quot;</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Redirect to &quot;</span> + dest);
    <span class="hljs-keyword">if</span> (dest.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;/404.html&quot;</span>) &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Ignore redirect to 404 page.&quot;</span>);
	} <span class="hljs-keyword">else</span> redirect = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">{dest}</span> /&gt;</span></span>;
}
...
</code></pre>
<p>이런 방법을 통해 GitHub Page의 정적인 서버를 사용하면서도 SPA 블로그를 서비스할 수 있게 되었습니다.</p>
</main><h1>Posts in <!-- -->blog development<!-- --> category</h1><ul><li class="post_list__OlrZL"><a href="/posts/blog-dev-7/">블로그 개발을 시작하다👨‍💻[7] - Refactoring</a></li><li class="post_list__OlrZL"><a href="/posts/blog-dev-6/">블로그 개발을 시작하다👨‍💻[6] - SEO</a></li><li class="post_listSelected__vtK9Y"><a href="/posts/blog-dev-5/">블로그 개발을 시작하다👨‍💻[5] - SPA</a></li><li class="post_list__OlrZL"><a href="/posts/blog-dev-4/">블로그 개발을 시작하다👨‍💻[4] - Emoji / Image</a></li><li class="post_list__OlrZL"><a href="/posts/blog-dev-3/">블로그 개발을 시작하다👨‍💻[3] - CI 구현하기</a></li></ul><div></div></div></main><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5695206410217978" data-ad-slot="9579212903" data-ad-format="auto" data-full-width-responsive="true"></ins><footer class="footer_footer__E_Uzl">© 2020 Copyright : Unknownpgr</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"블로그 개발을 시작하다👨‍💻[5] - SPA","category":"blog development","date":"2020-08-06T22:06:33.625Z","html":"\u003cp\u003e이전 포스트에서 다뤘던 이모지 문제를 해결한 후, 더이상 문제될 것은 없다고 생각했었습니다. 그런데 프로그래밍이라는 것이 항상 그렇듯이, 언제나 새로운 문제가 생깁니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/8c0b7e2cb9308f7cb1c516bd5c2a492c.jpg\" alt=\"r/ProgrammerHumor - Debugging be like... 출처 : https://www.reddit.com/r/ProgrammerHumor/comments/9g4vml/debugging_be_like/\"\u003e\u003c/p\u003e\n\u003cp\u003e바로 블로그를 Single Page Application으로 개발했다는 점입니다.\u003c/p\u003e\n\u003ch1\u003eSPA(Single Page Application)의 역사\u003c/h1\u003e\n\u003cp\u003e문제에 앞서, SPA가 무엇인지를 한번 알아봅시다.\u003c/p\u003e\n\u003ch2\u003e기존 웹페이지의 문제점\u003c/h2\u003e\n\u003cp\u003eSPA라는 개념이 생기기 전의 웹사이트에서는 새로운 내용을 보여주려면 \u003cu\u003e서버에서 매번 새로운 html파일을 로드\u003c/u\u003e해야 했었습니다.  이런 경우, 단점이 몇 가지 생깁니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e페이지 전체를 새로고침해야 하므로, 페이지가 렌더링되는 동안 유저는 빈 화면을 보면서 기다려야 합니다.\u003c/li\u003e\n\u003cli\u003eHeader나 Footer같이 실제로는 여러 페이지에 공통적으로 나오는 요소들도 매번 새롭게 다운로드 / 렌더링됩니다.\u003c/li\u003e\n\u003cli\u003e그러므로 웹페이지가 보여지는 데에 시간이 오래 걸립니다.\u003c/li\u003e\n\u003cli\u003e새로고침하는동안 페이지가 깜빡거리게 되므로, 미관상 좋지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eSPA의 개념\u003c/h2\u003e\n\u003cp\u003e그래서 SPA라는 개념이 생겨났습니다. SPA는 Single Page Application의 약자로, 웹페이지를 매번 새롭게 로딩하는 것이 아니라 \u003cu\u003eJavaScript를 사용하여 필요한 부분만을 새로 로딩\u003c/u\u003e하는 방식을 의미합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e예를 들어, 제 블로그의 카테고리를 이동하면, 모든 구성요소를 새로 렌더링하는 것이 아니라 꼭 필요한 부분인 포스트 리스트만을 새로 렌더링합니다.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://reactrouter.com/native/example/Basic\"\u003eReact Router\u003c/a\u003e 사이트에서, 왼쪽 Examples 섹션의 각 예제들을 눌러보시면 감이 더 잘 올 것 같습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e따라서 웹페이지를 SPA로 구성하면, 다양한 화면을 보여주기 위해 단 하나의 html / js만 있으면 충분합니다. 웹페이지를 변경할 필요가 있을 때에는 필요한 부분만 바꾸면 되기 때문입니다.\u003c/p\u003e\n\u003ch2\u003e초기 SPA의 치명적 단점\u003c/h2\u003e\n\u003cp\u003e물론 SPA가 처음 등장했을 때부터 완벽하지는 않아서, 초기에는 단점이 몇 가지 있었습니다.\u003c/p\u003e\n\u003ch3\u003e특정 페이지로 이동 불가능\u003c/h3\u003e\n\u003cp\u003e예를 들어, \u003ca href=\"http://www.koreacontents.or.kr/\"\u003e한국콘텐츠학회\u003c/a\u003e의 웹페이지는 SPA로 구성되어있습니다. (누가 만들었는지는 모르겠지만, SPA인 주제에 페이지를 이동할 때마다 새롭게 렌더링되는군요.🤔) 그러므로 이 사이트에서 특정 페이지로 이동한 후, URL을 복사하여 새 탭에서 열어보면 그냥 메인 페이지가 열립니다. 뿐만 아니라, 단순히 새로고침만 하더라도 메인 페이지로 이동해버립니다\u003c/p\u003e\n\u003ch3\u003eHistory 관리가 안 됨\u003c/h3\u003e\n\u003cp\u003e웹브라우저에서 뒤로가기 버튼을 누르면, 브라우저는 사용자를 직전의 URL로 이동시킵니다. 그런데 SPA는 URL변화가 없기 때문에, 한 사이트 내에서 뒤로가기 등이 전혀 작동하지 않았습니다.\u003c/p\u003e\n\u003ch3\u003e검색 안 됨(❗)\u003c/h3\u003e\n\u003cp\u003e그리고 궁극적으로, \u003cstrong\u003e검색이 안 됩니다.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e보통 검색 엔진들은 사이트의 URL을 기준으로 페이지를 구분합니다. 그런데 SPA로 구성한 웹페이지의 경우, 내용이 아무리 많더라도 사이트의 URL은 단 하나밖에 없습니다. \u003ccode\u003eindex.html\u003c/code\u003e파일 하나 내에서 모든 과정이 다 이루어지기 때문입니다. 그러므로 검색 엔진은 맨 처음에 로딩되는 딱 하나의 페이지만이 존재하는 것으로 인식합니다. 쇼핑몰, 블로그, 카페, 위키백과...등 각 페이지의 내용이 중요한 사이트의 경우, 검색이 안 되는 것은 치명적인 단점입니다.\u003c/p\u003e\n\u003ch2\u003eHTML5-History API의 등장\u003c/h2\u003e\n\u003cp\u003e이후 이런 문제점을 해결하는 여러 방법이 등장하였습니다.\u003c/p\u003e\n\u003ch3\u003eHash\u003c/h3\u003e\n\u003cp\u003e그중 하나는 Hash입니다. \u003cu\u003eHash란 한 페이지 내에서 특정 엘리먼트로 이동할 때 사용\u003c/u\u003e하는 URL 형식으로, URL뒤에 \u003ccode\u003e#ELEMENT_ID\u003c/code\u003e와 같이 특정 엘리먼트의 ID를 추가하면 됩니다. 위키백과에서 쉽게 발견할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttps://en.wikipedia.org/wiki/Single-page_application#Technical_approaches\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 URL을 자세히 살펴보면 뒷부분에 \u003ccode\u003e#\u003c/code\u003e으로 시작하는 부분이 있습니다. 이것이 바로 Hash입니다. \u003ca href=\"https://en.wikipedia.org/wiki/Single-page_application#Technical_approaches\"\u003e위 URL\u003c/a\u003e로 접속해보면 페이지의 맨 위로 이동하는 것이 아니라 \u003ccode\u003eid\u003c/code\u003e가 \u003ccode\u003eTechnical_approaches\u003c/code\u003e인 엘리먼트가 있는 위치로 이동합니다. Hash는 한 사이트 내에서 엘리먼트의 위치를 가리키기 때문에, \u003ccode\u003e\u0026lt;a\u0026gt;\u003c/code\u003e태그나 JavaScript를 사용하여 URL의 Hash를 바꾸는 경우 URL은 변하지만 웹페이지가 새로 로딩되지는 않습니다. 그래서 어떤 라이브러리들의 경우 이를 이용하여 SPA를 구현했었습니다. (아마 \u003ca href=\"https://angular.io/\"\u003eAngular\u003c/a\u003e가 이런 방식을 사용하는 것으로 압니다.)\u003c/p\u003e\n\u003cp\u003e물론 Hash도 완벽한 솔루션은 아니었습니다. 일단 위에서 언급한 첫 번째와 두 번째 문제는 해결되었지만, 어떤 검색 엔진들은 Hash를 무시해버리기 때문에 역시 검색이 잘 되지 않는 문제가 있었습니다.\u003c/p\u003e\n\u003cp\u003e그리고 이는 정석이 아니라 일종의 트릭이므로, URL이 보기에 어색해집니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttps://unknownpgr.github.io/#/posts/some-post\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e...아무래도 중간에 이상한 것이 끼이니, 영 어색합니다.\u003c/p\u003e\n\u003ch3\u003eHTML5 History API\u003c/h3\u003e\n\u003cp\u003e그러나 HTML5가 등장하면서, 모든 문제점이 한 번에 사라집니다.\u003c/p\u003e\n\u003cp\u003eHTML5의 기능 중에는 \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API\"\u003eHistory API\u003c/a\u003e라는 것이 있습니다. 요약하자면 URL 및 History를 마음대로 조작할 수 있는 기능입니다. 이전에는 주소창의 URL을 바꾸려면 실제로 페이지를 이동해야만 했지만, 이제는 History API를 이용하여 페이지 이동 없이도 새로운 사이트를 방문한 것처럼 URL을 조작할 수 있게 되었습니다.\u003c/p\u003e\n\u003cp\u003e그리고 이를 이용하여 React의 Browser Router가 등장하였습니다. Browser Router란 새로운 페이지로 이동할 때 실제로는 페이지 라우팅이 전혀 일어나지 않지만 \u003cu\u003eURL을 바꾸어 페이지를 이동한 것처럼 보이게 하는 기술\u003c/u\u003e입니다. \u003ca href=\"https://reactrouter.com/\"\u003eReact Router\u003c/a\u003e라는 라이브러리를 사용하여 이를 사용할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eGitHub Page의 역습\u003c/h1\u003e\n\u003cp\u003e그래서 저는 SPA로 블로그를 만드는 것에 아무런 문제가 없음을 믿어 의심치 않았습니다. 그런데 GitHub Page가 정적 웹서버를 사용하여 호스팅된다는 것이 문제였습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어 \u003ccode\u003ehttps://unknownpgr.github.io/posts/blog-dev-4\u003c/code\u003e페이지의 경우, 실제로 저런 경로가 존재하는 것이 아닙니다. 실제로 존재하는 것은 \u003ccode\u003ehttps://unknownpgr.github.io/index.html\u003c/code\u003e파일밖에 없고, 위의 URL은 Browser Router를 통해 URL만을 바꾼 것입니다. 하지만 이런 사실을 전혀 모르는 GitHub Page의 정적 서버는 \u003ccode\u003ehttps://unknownpgr.github.io/posts/blog-dev-4\u003c/code\u003e라는 파일이 없다고 생각하여 저 경로로 접근하면 404를 반환합니다.\u003c/p\u003e\n\u003ch2\u003e해결 방법\u003c/h2\u003e\n\u003cp\u003e물론 하늘이 무너져도 솟아날 구멍은 있는 법이어서, 다행스럽게도 해결 방법이 있었습니다.\u003c/p\u003e\n\u003cp\u003eGitHub에서 루트 디렉토리에 \u003ccode\u003e404.html\u003c/code\u003e을 만들면 404 발생 시 GitHub Page의 기본 404 페이지 대신 저 페이지가 나옵니다. 이를 이용하여 404페이지에서 다시 메인 페이지(\u003ccode\u003e/\u003c/code\u003e)로 리다이렉트하되, GET parameter를 사용하여 원래 어떤 페이지가 요청되었는지를 반환하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- 404.html --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e url = \u003cspan class=\"hljs-string\"\u003e`/?page=\u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-built_in\"\u003eencodeURIComponent\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.location.pathname)}\u003c/span\u003e`\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elocation\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(url);\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이후, 메인 페이지에서는 \u003ccode\u003epage\u003c/code\u003e 파라매터를 검사, 만약 파라매터가 존재하면 Browser Router를 사용하여 해당 페이지로 리다이렉트시켜줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-comment\"\u003e// App.js\u003c/span\u003e\n...\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e param = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elocation\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esearch\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esubstr\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e redirect = \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (param.\u003cspan class=\"hljs-title function_\"\u003eindexOf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;page=\u0026quot;\u003c/span\u003e) \u0026gt;= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e dest = \u003cspan class=\"hljs-built_in\"\u003edecodeURIComponent\u003c/span\u003e(param.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;page=\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e));\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Redirect to \u0026quot;\u003c/span\u003e + dest);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dest.\u003cspan class=\"hljs-title function_\"\u003eindexOf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;/404.html\u0026quot;\u003c/span\u003e) \u0026gt;= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Ignore redirect to 404 page.\u0026quot;\u003c/span\u003e);\n\t} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e redirect = \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eRedirect\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eto\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{dest}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n}\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이런 방법을 통해 GitHub Page의 정적인 서버를 사용하면서도 SPA 블로그를 서비스할 수 있게 되었습니다.\u003c/p\u003e\n","name":"blog-dev-5"},"postsInSameCategory":[{"title":"블로그 개발을 시작하다👨‍💻[7] - Refactoring","category":"blog development","date":"2020-09-25T15:56:00.000Z","name":"blog-dev-7"},{"title":"블로그 개발을 시작하다👨‍💻[6] - SEO","category":"blog development","date":"2020-08-07T21:18:27.674Z","name":"blog-dev-6"},{"title":"블로그 개발을 시작하다👨‍💻[5] - SPA","category":"blog development","date":"2020-08-06T22:06:33.625Z","name":"blog-dev-5"},{"title":"블로그 개발을 시작하다👨‍💻[4] - Emoji / Image","category":"blog development","date":"2020-07-27T01:49:37.301Z","name":"blog-dev-4"},{"title":"블로그 개발을 시작하다👨‍💻[3] - CI 구현하기","category":"blog development","date":"2020-07-25T11:51:36.698Z","name":"blog-dev-3"}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"blog-dev-5"},"buildId":"5acpRZgm_5FalkhKxD4A7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>