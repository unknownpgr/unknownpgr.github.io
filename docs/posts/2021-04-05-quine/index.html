<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="description" content="Unknownpgr&#x27;s Blog"/><link rel="icon" href="/favicon.png"/><meta property="og:title" content="Unknownpgr&#x27;s Blog"/><meta property="og:url" content="https://unknownpgr.com"/><meta property="og:image" content="/logo.png"/><title>Unknownpgr : 콰인(Quine)</title><meta property="og:title" content="Unknownpgr: 콰인(Quine)"/><meta name="next-head-count" content="9"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/2e1e96656eb72d38.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2e1e96656eb72d38.css" data-n-g=""/><link rel="preload" href="/_next/static/css/14062eec27ee8c3f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/14062eec27ee8c3f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-1cd5204319a0e744.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b2167bfc37ff4f0b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-fe089d9906e2f51a.js" defer=""></script><script src="/_next/static/_WLwOjOFFlwORe1QuXStz/_buildManifest.js" defer=""></script><script src="/_next/static/_WLwOjOFFlwORe1QuXStz/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="nav_nav__XkaAa"><a class="nav_logo__drPJg" href="/">[UNKNOWN-PGR]</a><a class="nav_link__KHlEJ" href="/">Home</a><a class="nav_link__KHlEJ" href="/categories/">Categories</a><a class="nav_link__KHlEJ" href="/about/">About</a></nav><main class="layout_main__j5lor"><div><h1 class="post_title__aQveY">콰인(Quine)</h1><main class="post_main__mmVmG"><h1>소개</h1>
<p>인터넷을 돌아다니다가 뜬금없이 Quine이라는 것을 발견했습니다. 콰인이란 어떤 프로그램 소스 코드로, 실행시켰을 때 그 자신을 출력하는 것을 말합니다. 가장 자명한 콰인은 아무것도 없는 소스코드입니다. 아무것도 없는 소스코드는 아무것도 출력하지 않으므로, 자기 자신을 출력한다고 볼 수 있습니다. 당연하지만, <code>eval</code>, <code>exec</code>류의 <code>string</code> 실행 함수, <code>reflection</code>, 그냥 파일 읽기, 외부 라이브러리 등을 사용하면 안 됩니다.</p>
<h1>소스코드</h1>
<p>저는 아래와 같은 python 코드로 콰인을 작성했습니다.</p>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decode</span>(<span class="hljs-params">s</span>):
    s = s.replace(<span class="hljs-string">&quot;\\&quot;</span>, <span class="hljs-string">&quot;\\\\&quot;</span>)
    s = s.replace(<span class="hljs-string">&#x27;&quot;&#x27;</span>, <span class="hljs-string">&#x27;\\&quot;&#x27;</span>)
    s = s.replace(<span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&quot;\\&#x27;&quot;</span>)
    s = s.replace(<span class="hljs-string">&#x27;&#x27;&#x27;
&#x27;&#x27;&#x27;</span>, <span class="hljs-string">&#x27;\\n&#x27;</span>)
    <span class="hljs-keyword">return</span> s


<span class="hljs-keyword">def</span> <span class="hljs-title function_">self_print</span>(<span class="hljs-params">x</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;&#x27;&#x27;<span class="hljs-subst">{x}</span>

self_print(
    &quot;<span class="hljs-subst">{decode(x)}</span>&quot;)&#x27;&#x27;&#x27;</span>)


self_print(
    <span class="hljs-string">&quot;def decode(s):\n    s = s.replace(\&quot;\\\\\&quot;, \&quot;\\\\\\\\\&quot;)\n    s = s.replace(\&#x27;\&quot;\&#x27;, \&#x27;\\\\\&quot;\&#x27;)\n    s = s.replace(\&quot;\&#x27;\&quot;, \&quot;\\\\\&#x27;\&quot;)\n    s = s.replace(\&#x27;\&#x27;\&#x27;\n\&#x27;\&#x27;\&#x27;, \&#x27;\\\\n\&#x27;)\n    return s\n\n\ndef self_print(x):\n    print(f\&#x27;\&#x27;\&#x27;{x}\n\nself_print(\n    \&quot;{decode(x)}\&quot;)\&#x27;\&#x27;\&#x27;)&quot;</span>)

</code></pre>
<p>위 코드를 실행하면 자기 자신과 완벽히 똑같은 출력을 내보냅니다.</p>
<h2>논리적 도출</h2>
<p>저는 콰인을 구현하는 방법에 대해 한 번도 들어본 적이 없기 때문에 순수하게 바닥에서부터 출발했고, 따라서 다른 코드들과 방향성이 좀 다를 수 있습니다.</p>
<p>먼저 위 함수는 다음과 같은 아이디어에서 출발했습니다.</p>
<blockquote>
<p>만약 언어 자체에 self_print(x) 라는 함수가 있어서, 이 함수의 출력이</p>
<p>self_print(&quot;x&quot;)</p>
<p>라면 어떨까?</p>
</blockquote>
<p>만약 그렇다면 다음과 같은 코드는 콰인이 됩니다.</p>
<pre><code class="language-python">self_print(<span class="hljs-string">&quot;아무 문자열&quot;</span>)
</code></pre>
<p>그러나 당연하게도 파이썬에는 저런 함수가 없습니다. 그러므로 <code>self_print</code>함수를 직접 정의할 필요가 있습니다.</p>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">self_print</span>(<span class="hljs-params">x</span>):
	<span class="hljs-comment"># ~~~</span>

sef_print(<span class="hljs-string">&quot;아무 문자열&quot;</span>)
</code></pre>
<p>그런데 여기서 문제가 발생합니다. <code>self_print</code>함수의 정의 자체는 출력하지 않기 때문에, 이렇게 되면 콰인이 아니게 됩니다. 이것을 콰인으로 만드려면 출력에 <code>self_print</code>함수에 대한 정의 자체가 출력에 포함되어야 합니다. 그러기 위해서 두 가지 방법이 있습니다.</p>
<ol>
<li><code>self_print</code>함수 내부에 <code>self_print</code>함수를 정의하는 문자열을 넣는다.</li>
<li><code>self_print</code>함수 외부에 <code>self_print</code>함수를 정의하는 문자열을 넣는다.</li>
</ol>
<p>이중 1번은 생각해보면 불가능함을 알 수 있습니다. 왜냐하면 <code>self_print</code>함수를 정의하는 데 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>개의 문자가 필요하다고 하면, 이것을 따옴표로 감싸기만 해도 <code>n+2</code>개의 문자가 필요합니다. 그런데 이것이 다시 <code>self_print </code>함수의 정의에 포함되어야 하므로 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>2</mn><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n+2 &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 이 되어 모순이 발생하기 때문입니다.</p>
<p>따라서 <code>self_print</code> 함수 외부에 그런 문자열이 있어야 하며, 그것을 <code>self_print </code>내부로 전달해야 합니다. 그러기 위해서 자명히 <code>self_print</code>함수의 파라매터를 사용할 수 있습니다.</p>
<p>그러면 이제 이 함수에 대한 정의를 함수 안에서 알 수 있게 됩니다. 이것을 출력에 포함시키기만 하면 완성입니다. 즉, 다음과 같이 하면 됩니다.</p>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">self_print</span>(<span class="hljs-params">x</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;&#x27;&#x27;<span class="hljs-subst">{x}</span>

self_print(
    &quot;<span class="hljs-subst">{x}</span>&quot;)&#x27;&#x27;&#x27;</span>)
</code></pre>
<p>이렇게 하면 <code>self_print</code>의 인자로 <code>self_print</code>의 정의를 나타내는 문자열을 받았을 경우 콰인이 됩니다.</p>
<p>다만 이렇게 할 때 사소한 문제는 문자열 escape입니다. 큰따옴표로 선언된 문자열 리터럴 내부에 큰따옴표를 집어넣거나, 줄바꿈을 표현하려면 escape를 해야 합니다. 그런데 <code>print</code>를 사용하여 출력할 때에는 <code>escape</code> 문자가 전부 처리된 후 출력되기 때문에,  escape한 문자열을 다시 역-escape해주는 부분을 추가해야 합니다. 그 부분(위의 소스코드에서는 <code>decode</code>함수)위의 소스코드와 같은 결과를 얻게 됩니다.</p>
</main><h1>Posts in <!-- -->algorithm<!-- --> category</h1><ul><li class="post_listSelected__vtK9Y"><a href="/posts/2021-04-05-quine/">콰인(Quine)</a></li><li class="post_list__OlrZL"><a href="/posts/2021-01-19-algorithm-2/">알고리즘:부분문자열</a></li><li class="post_list__OlrZL"><a href="/posts/2021-01-17-algorithm-1/">알고리즘:N-queens problem</a></li></ul><div></div></div></main><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5695206410217978" data-ad-slot="9579212903" data-ad-format="auto" data-full-width-responsive="true"></ins><footer class="footer_footer__E_Uzl">© 2020 Copyright : Unknownpgr</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"콰인(Quine)","category":"algorithm","date":"2021-04-05T21:27:20.117Z","postStr":"---\ntitle: 콰인(Quine)\ncategory: algorithm\ndate: 2021-04-05T21:27:20.117Z\n\n---\n\n# 소개\n\n 인터넷을 돌아다니다가 뜬금없이 Quine이라는 것을 발견했습니다. 콰인이란 어떤 프로그램 소스 코드로, 실행시켰을 때 그 자신을 출력하는 것을 말합니다. 가장 자명한 콰인은 아무것도 없는 소스코드입니다. 아무것도 없는 소스코드는 아무것도 출력하지 않으므로, 자기 자신을 출력한다고 볼 수 있습니다. 당연하지만, `eval`, `exec`류의 `string` 실행 함수, `reflection`, 그냥 파일 읽기, 외부 라이브러리 등을 사용하면 안 됩니다.\n\n# 소스코드\n\n저는 아래와 같은 python 코드로 콰인을 작성했습니다.\n\n```python\ndef decode(s):\n    s = s.replace(\"\\\\\", \"\\\\\\\\\")\n    s = s.replace('\"', '\\\\\"')\n    s = s.replace(\"'\", \"\\\\'\")\n    s = s.replace('''\n''', '\\\\n')\n    return s\n\n\ndef self_print(x):\n    print(f'''{x}\n\nself_print(\n    \"{decode(x)}\")''')\n\n\nself_print(\n    \"def decode(s):\\n    s = s.replace(\\\"\\\\\\\\\\\", \\\"\\\\\\\\\\\\\\\\\\\")\\n    s = s.replace(\\'\\\"\\', \\'\\\\\\\\\\\"\\')\\n    s = s.replace(\\\"\\'\\\", \\\"\\\\\\\\\\'\\\")\\n    s = s.replace(\\'\\'\\'\\n\\'\\'\\', \\'\\\\\\\\n\\')\\n    return s\\n\\n\\ndef self_print(x):\\n    print(f\\'\\'\\'{x}\\n\\nself_print(\\n    \\\"{decode(x)}\\\")\\'\\'\\')\")\n\n```\n\n위 코드를 실행하면 자기 자신과 완벽히 똑같은 출력을 내보냅니다.\n\n## 논리적 도출\n\n저는 콰인을 구현하는 방법에 대해 한 번도 들어본 적이 없기 때문에 순수하게 바닥에서부터 출발했고, 따라서 다른 코드들과 방향성이 좀 다를 수 있습니다.\n\n먼저 위 함수는 다음과 같은 아이디어에서 출발했습니다.\n\n\u003e 만약 언어 자체에 self_print(x) 라는 함수가 있어서, 이 함수의 출력이\n\u003e\n\u003e self_print(\"x\")\n\u003e\n\u003e 라면 어떨까?\n\n만약 그렇다면 다음과 같은 코드는 콰인이 됩니다.\n\n```python\nself_print(\"아무 문자열\")\n```\n\n그러나 당연하게도 파이썬에는 저런 함수가 없습니다. 그러므로 `self_print`함수를 직접 정의할 필요가 있습니다.\n\n```python\ndef self_print(x):\n\t# ~~~\n\nsef_print(\"아무 문자열\")\n```\n\n그런데 여기서 문제가 발생합니다. `self_print`함수의 정의 자체는 출력하지 않기 때문에, 이렇게 되면 콰인이 아니게 됩니다. 이것을 콰인으로 만드려면 출력에 `self_print`함수에 대한 정의 자체가 출력에 포함되어야 합니다. 그러기 위해서 두 가지 방법이 있습니다.\n\n1. `self_print`함수 내부에 `self_print`함수를 정의하는 문자열을 넣는다.\n2. `self_print`함수 외부에 `self_print`함수를 정의하는 문자열을 넣는다.\n\n이중 1번은 생각해보면 불가능함을 알 수 있습니다. 왜냐하면 `self_print`함수를 정의하는 데 $n$개의 문자가 필요하다고 하면, 이것을 따옴표로 감싸기만 해도 `n+2`개의 문자가 필요합니다. 그런데 이것이 다시 `self_print `함수의 정의에 포함되어야 하므로 $n+2 \u003c n$ 이 되어 모순이 발생하기 때문입니다.\n\n 따라서 `self_print` 함수 외부에 그런 문자열이 있어야 하며, 그것을 `self_print `내부로 전달해야 합니다. 그러기 위해서 자명히 `self_print`함수의 파라매터를 사용할 수 있습니다.\n\n 그러면 이제 이 함수에 대한 정의를 함수 안에서 알 수 있게 됩니다. 이것을 출력에 포함시키기만 하면 완성입니다. 즉, 다음과 같이 하면 됩니다.\n\n```python\ndef self_print(x):\n    print(f'''{x}\n\nself_print(\n    \"{x}\")''')\n```\n\n이렇게 하면 `self_print`의 인자로 `self_print`의 정의를 나타내는 문자열을 받았을 경우 콰인이 됩니다.\n\n 다만 이렇게 할 때 사소한 문제는 문자열 escape입니다. 큰따옴표로 선언된 문자열 리터럴 내부에 큰따옴표를 집어넣거나, 줄바꿈을 표현하려면 escape를 해야 합니다. 그런데 `print`를 사용하여 출력할 때에는 `escape` 문자가 전부 처리된 후 출력되기 때문에,  escape한 문자열을 다시 역-escape해주는 부분을 추가해야 합니다. 그 부분(위의 소스코드에서는 `decode`함수)위의 소스코드와 같은 결과를 얻게 됩니다.","html":"\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e인터넷을 돌아다니다가 뜬금없이 Quine이라는 것을 발견했습니다. 콰인이란 어떤 프로그램 소스 코드로, 실행시켰을 때 그 자신을 출력하는 것을 말합니다. 가장 자명한 콰인은 아무것도 없는 소스코드입니다. 아무것도 없는 소스코드는 아무것도 출력하지 않으므로, 자기 자신을 출력한다고 볼 수 있습니다. 당연하지만, \u003ccode\u003eeval\u003c/code\u003e, \u003ccode\u003eexec\u003c/code\u003e류의 \u003ccode\u003estring\u003c/code\u003e 실행 함수, \u003ccode\u003ereflection\u003c/code\u003e, 그냥 파일 읽기, 외부 라이브러리 등을 사용하면 안 됩니다.\u003c/p\u003e\n\u003ch1\u003e소스코드\u003c/h1\u003e\n\u003cp\u003e저는 아래와 같은 python 코드로 콰인을 작성했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edecode\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003es\u003c/span\u003e):\n    s = s.replace(\u003cspan class=\"hljs-string\"\u003e\u0026quot;\\\\\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;\\\\\\\\\u0026quot;\u003c/span\u003e)\n    s = s.replace(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026quot;\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\\u0026quot;\u0026#x27;\u003c/span\u003e)\n    s = s.replace(\u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026#x27;\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;\\\\\u0026#x27;\u0026quot;\u003c/span\u003e)\n    s = s.replace(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u0026#x27;\n\u0026#x27;\u0026#x27;\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\n\u0026#x27;\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e s\n\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eself_print\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e):\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\u0026#x27;\u0026#x27;\u0026#x27;\u003cspan class=\"hljs-subst\"\u003e{x}\u003c/span\u003e\n\nself_print(\n    \u0026quot;\u003cspan class=\"hljs-subst\"\u003e{decode(x)}\u003c/span\u003e\u0026quot;)\u0026#x27;\u0026#x27;\u0026#x27;\u003c/span\u003e)\n\n\nself_print(\n    \u003cspan class=\"hljs-string\"\u003e\u0026quot;def decode(s):\\n    s = s.replace(\\\u0026quot;\\\\\\\\\\\u0026quot;, \\\u0026quot;\\\\\\\\\\\\\\\\\\\u0026quot;)\\n    s = s.replace(\\\u0026#x27;\\\u0026quot;\\\u0026#x27;, \\\u0026#x27;\\\\\\\\\\\u0026quot;\\\u0026#x27;)\\n    s = s.replace(\\\u0026quot;\\\u0026#x27;\\\u0026quot;, \\\u0026quot;\\\\\\\\\\\u0026#x27;\\\u0026quot;)\\n    s = s.replace(\\\u0026#x27;\\\u0026#x27;\\\u0026#x27;\\n\\\u0026#x27;\\\u0026#x27;\\\u0026#x27;, \\\u0026#x27;\\\\\\\\n\\\u0026#x27;)\\n    return s\\n\\n\\ndef self_print(x):\\n    print(f\\\u0026#x27;\\\u0026#x27;\\\u0026#x27;{x}\\n\\nself_print(\\n    \\\u0026quot;{decode(x)}\\\u0026quot;)\\\u0026#x27;\\\u0026#x27;\\\u0026#x27;)\u0026quot;\u003c/span\u003e)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드를 실행하면 자기 자신과 완벽히 똑같은 출력을 내보냅니다.\u003c/p\u003e\n\u003ch2\u003e논리적 도출\u003c/h2\u003e\n\u003cp\u003e저는 콰인을 구현하는 방법에 대해 한 번도 들어본 적이 없기 때문에 순수하게 바닥에서부터 출발했고, 따라서 다른 코드들과 방향성이 좀 다를 수 있습니다.\u003c/p\u003e\n\u003cp\u003e먼저 위 함수는 다음과 같은 아이디어에서 출발했습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e만약 언어 자체에 self_print(x) 라는 함수가 있어서, 이 함수의 출력이\u003c/p\u003e\n\u003cp\u003eself_print(\u0026quot;x\u0026quot;)\u003c/p\u003e\n\u003cp\u003e라면 어떨까?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e만약 그렇다면 다음과 같은 코드는 콰인이 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eself_print(\u003cspan class=\"hljs-string\"\u003e\u0026quot;아무 문자열\u0026quot;\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 당연하게도 파이썬에는 저런 함수가 없습니다. 그러므로 \u003ccode\u003eself_print\u003c/code\u003e함수를 직접 정의할 필요가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eself_print\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e):\n\t\u003cspan class=\"hljs-comment\"\u003e# ~~~\u003c/span\u003e\n\nsef_print(\u003cspan class=\"hljs-string\"\u003e\u0026quot;아무 문자열\u0026quot;\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런데 여기서 문제가 발생합니다. \u003ccode\u003eself_print\u003c/code\u003e함수의 정의 자체는 출력하지 않기 때문에, 이렇게 되면 콰인이 아니게 됩니다. 이것을 콰인으로 만드려면 출력에 \u003ccode\u003eself_print\u003c/code\u003e함수에 대한 정의 자체가 출력에 포함되어야 합니다. 그러기 위해서 두 가지 방법이 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eself_print\u003c/code\u003e함수 내부에 \u003ccode\u003eself_print\u003c/code\u003e함수를 정의하는 문자열을 넣는다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eself_print\u003c/code\u003e함수 외부에 \u003ccode\u003eself_print\u003c/code\u003e함수를 정의하는 문자열을 넣는다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이중 1번은 생각해보면 불가능함을 알 수 있습니다. 왜냐하면 \u003ccode\u003eself_print\u003c/code\u003e함수를 정의하는 데 \u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003en\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003en\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개의 문자가 필요하다고 하면, 이것을 따옴표로 감싸기만 해도 \u003ccode\u003en+2\u003c/code\u003e개의 문자가 필요합니다. 그런데 이것이 다시 \u003ccode\u003eself_print \u003c/code\u003e함수의 정의에 포함되어야 하므로 \u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmn\u003e2\u003c/mn\u003e\u003cmo\u003e\u0026lt;\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003en+2 \u0026lt; n\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e2\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e 이 되어 모순이 발생하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e따라서 \u003ccode\u003eself_print\u003c/code\u003e 함수 외부에 그런 문자열이 있어야 하며, 그것을 \u003ccode\u003eself_print \u003c/code\u003e내부로 전달해야 합니다. 그러기 위해서 자명히 \u003ccode\u003eself_print\u003c/code\u003e함수의 파라매터를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러면 이제 이 함수에 대한 정의를 함수 안에서 알 수 있게 됩니다. 이것을 출력에 포함시키기만 하면 완성입니다. 즉, 다음과 같이 하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eself_print\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e):\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\u0026#x27;\u0026#x27;\u0026#x27;\u003cspan class=\"hljs-subst\"\u003e{x}\u003c/span\u003e\n\nself_print(\n    \u0026quot;\u003cspan class=\"hljs-subst\"\u003e{x}\u003c/span\u003e\u0026quot;)\u0026#x27;\u0026#x27;\u0026#x27;\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 \u003ccode\u003eself_print\u003c/code\u003e의 인자로 \u003ccode\u003eself_print\u003c/code\u003e의 정의를 나타내는 문자열을 받았을 경우 콰인이 됩니다.\u003c/p\u003e\n\u003cp\u003e다만 이렇게 할 때 사소한 문제는 문자열 escape입니다. 큰따옴표로 선언된 문자열 리터럴 내부에 큰따옴표를 집어넣거나, 줄바꿈을 표현하려면 escape를 해야 합니다. 그런데 \u003ccode\u003eprint\u003c/code\u003e를 사용하여 출력할 때에는 \u003ccode\u003eescape\u003c/code\u003e 문자가 전부 처리된 후 출력되기 때문에,  escape한 문자열을 다시 역-escape해주는 부분을 추가해야 합니다. 그 부분(위의 소스코드에서는 \u003ccode\u003edecode\u003c/code\u003e함수)위의 소스코드와 같은 결과를 얻게 됩니다.\u003c/p\u003e\n","imageMapping":{},"name":"2021-04-05-quine"},"postsInSameCategory":[{"name":"2021-04-05-quine","title":"콰인(Quine)","date":"2021-04-05T21:27:20.117Z","category":"algorithm"},{"name":"2021-01-19-algorithm-2","title":"알고리즘:부분문자열","date":"2021-01-19T14:25:47.455Z","category":"algorithm"},{"name":"2021-01-17-algorithm-1","title":"알고리즘:N-queens problem","date":"2021-01-17T17:26:17.050Z","category":"algorithm"}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2021-04-05-quine"},"buildId":"_WLwOjOFFlwORe1QuXStz","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>