<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="description" content="Unknownpgr&#x27;s Blog"/><link rel="icon" href="/favicon.png"/><meta property="og:title" content="Unknownpgr&#x27;s Blog"/><meta property="og:url" content="https://unknownpgr.com"/><meta property="og:image" content="/logo.png"/><title>Unknownpgr : 유용한 SSH/SCP 명령어</title><meta property="og:title" content="Unknownpgr: 유용한 SSH/SCP 명령어"/><meta name="next-head-count" content="9"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/2e1e96656eb72d38.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2e1e96656eb72d38.css" data-n-g=""/><link rel="preload" href="/_next/static/css/14062eec27ee8c3f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/14062eec27ee8c3f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-1cd5204319a0e744.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b2167bfc37ff4f0b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-fe089d9906e2f51a.js" defer=""></script><script src="/_next/static/9oj6AxLy2jV-3nD3luYn1/_buildManifest.js" defer=""></script><script src="/_next/static/9oj6AxLy2jV-3nD3luYn1/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="nav_nav__XkaAa"><a class="nav_logo__drPJg" href="/">[UNKNOWN-PGR]</a><a class="nav_link__KHlEJ" href="/">Home</a><a class="nav_link__KHlEJ" href="/categories/">Categories</a><a class="nav_link__KHlEJ" href="/about/">About</a></nav><main class="layout_main__j5lor"><div><h1 class="post_title__aQveY">유용한 SSH/SCP 명령어</h1><main class="post_main__mmVmG"><p>SSH / SCP 명령어는 주로 원격 서버에서 작업할 때 많이 쓰입니다. 알아 두면 유용한 명령어를 몇 개 정리해봤습니다.</p>
<ul>
<li>아래에서 <code>로컬 머신</code>이라 함은 커맨드를 실행하는 바로 그 컴퓨터를 말하는 것입니다.</li>
<li>아래에서 <code>원격 서버</code>라 함은 내가 <code>로컬 머신</code>을 거쳐 제어하고자 하는 다른 컴퓨터를 말하는 것입니다.</li>
</ul>
<h3>원격 서버에 접속</h3>
<pre><code class="language-bash">ssh [username]@[hostname] -p [sshport]
ssh unknownpgr@my-webserver.server.io -p 1234
</code></pre>
<h3>원격 서버에서 특정 명령어 실행</h3>
<pre><code class="language-bash">ssh [username]@[hostname] -p [sshport] <span class="hljs-built_in">command</span>
ssh unknownpgr@192.168.0.2 -p 22 make
</code></pre>
<p>이렇게 하면 원격 서버에서 해당 커맨드가 실행된다.</p>
<h3>원격 서버의 특정 포트와 포트포워딩</h3>
<p>아래 예제들을 보면 <code>-N</code> 옵션이 붙어있는 것을 알 수 있는데, <code>-N</code> 옵션은 배쉬 셸을 띄우지 않는 옵션이다. 포트포워딩처럼 굳이 배쉬 셸을 쓸 필요 없을 때 유용하다.</p>
<pre><code class="language-bash">ssh -N -L [localport]:[destserver]:[destport] [jumpserver]
ssh -N -L 9876:inta.server.com:80 public.server.com
</code></pre>
<p>아래의 예시를 실행하면 <code>localhost</code>의 <code>9876</code>포트를 <code>public.server.com</code>서버를 거쳐 <code>inta.server.com</code>서버의 <code>80</code>번 포트와 연결한다. 이는 보안 연결이 필요한 경우에 사용하면 좋다. 예를 들어, <a href="https://github.com/cdr/code-server">code-server</a>에서도 다음과 같은 커맨드를 이용하여 code-server에 접속하는 것을 권장한다.</p>
<pre><code class="language-bash">ssh -N -L 8080:127.0.0.1:8080 &lt;instance-ip&gt; <span class="hljs-comment">#이렇게 한 후 브라우저에서 localhost:8080으로 접속한다.</span>
</code></pre>
<h3>원격 서버에서 로컬 머신으로 포트포워딩</h3>
<pre><code class="language-bash">ssh -R [remoteport]:[host]:[hostport] [remote]
ssh -R 8080:localhost:5000 remote.server.com
ssh -R 8080:www.google.com:80 remote.server.com
</code></pre>
<p>이 옵션은 좀 난해하다. 정확하게는 다음과 같이 작동한다.</p>
<blockquote>
<p><code>remote</code> 서버의 <code>remoteport</code>포트가 로컬 머신을 거쳐서 <code>host</code>서버의 <code>hostport</code>로 연결되게 한다.</p>
</blockquote>
<p>그러므로 두 번째 예시는 <code>remote.server.com</code>의 8080포트가 로컬 머신의 5000포트에 연결되도록 하며, 세 번째 예시는 <code>remote.server.com</code>의 8080번 포트가 로컬 머신을 거쳐서 <code>www.google.com</code>의 80번 포트에 연결되도록 한다. 따로 옵션을 주면 다양한 인터페이스에서 연결을 받을 수 있지만, 기본은 로컬호스트이다. 즉, 내가 웹브라우저로 <code>remote.server.com:8080</code>에 접속하면 접속이 되지 않지만, 원격 서버에서 <code>curl localhost:8080</code>으로 접속해보면 로컬 머신을 거쳐 원하는 목적 서버로 연결이 된다.</p>
<h3>로컬 머신에서 원격 서버로 파일 전송하기</h3>
<pre><code class="language-bash">scp [local-file-path] [username]@[host]:[remote-file-path]
scp ~/file.txt unknownpgr@remote.server.com:<span class="hljs-string">&quot;~/remote-path&quot;</span>
</code></pre>
<p>로컬 머신의 <code>local-file-path</code>에 있는 파일을 <code>host</code> 원격 서버의 <code>remote-file-path</code>디렉토리에 집어넣는다. 두번째 예시를 실행하면 로컬 머신의 <code>~/file.txt</code>파일이 <code>remote.server.com</code>서버의 <code>~/remote-path</code>디렉토리에 저장된다.</p>
<h3>로컬 머신에서 원격 서버로 디렉토리 전송하기</h3>
<pre><code class="language-bash">scp -r [local-folder] [user]@[host]:[remote-dir]
</code></pre>
<p>위와 거의 똑같지만, 단일 파일이 아니라 디렉토리째로 복사한다.</p>
<h3>원격 서버에서 로컬 머신으로 파일 전송하기</h3>
<pre><code class="language-bash">scp [user]@[host]:[remote-file] [local-dir]
</code></pre>
<p>이것 역시 로컬 머신에서 원격 서버로 전송하는 것과 완전히 똑같고, 순서만 바뀌었다. <code>host</code>원격 서버의 <code>remote-file</code>을 로컬 머신의 <code>local-dir</code>에 옮긴다. 마찬가지로 <code>-r</code>옵션을 주면 디렉토리째로 옮길 수 있다.</p>
</main><h1>Posts in <!-- -->tips<!-- --> category</h1><ul><li class="post_list__OlrZL"><a href="/posts/2022-12-22-programmer/">어떻게 개발자가 되는가?</a></li><li class="post_list__OlrZL"><a href="/posts/2021-01-13-code-2/">유용한 파일 관련 명령어</a></li><li class="post_listSelected__vtK9Y"><a href="/posts/2020-08-08-code-1/">유용한 SSH/SCP 명령어</a></li></ul><div></div></div></main><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5695206410217978" data-ad-slot="9579212903" data-ad-format="auto" data-full-width-responsive="true"></ins><footer class="footer_footer__E_Uzl">© 2020 Copyright : Unknownpgr</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"유용한 SSH/SCP 명령어","category":"tips","date":"2020-08-08T12:31:29.912Z","postStr":"---\ntitle: 유용한 SSH/SCP 명령어\ncategory: tips\ndate: 2020-08-08T12:31:29.912Z\n\n---\n\nSSH / SCP 명령어는 주로 원격 서버에서 작업할 때 많이 쓰입니다. 알아 두면 유용한 명령어를 몇 개 정리해봤습니다.\n\n- 아래에서 `로컬 머신`이라 함은 커맨드를 실행하는 바로 그 컴퓨터를 말하는 것입니다.\n- 아래에서 `원격 서버`라 함은 내가 `로컬 머신`을 거쳐 제어하고자 하는 다른 컴퓨터를 말하는 것입니다.\n\n### 원격 서버에 접속\n\n```bash\nssh [username]@[hostname] -p [sshport]\nssh unknownpgr@my-webserver.server.io -p 1234\n```\n\n### 원격 서버에서 특정 명령어 실행\n\n```bash\nssh [username]@[hostname] -p [sshport] command\nssh unknownpgr@192.168.0.2 -p 22 make\n```\n\n이렇게 하면 원격 서버에서 해당 커맨드가 실행된다.\n\n### 원격 서버의 특정 포트와 포트포워딩\n아래 예제들을 보면 `-N` 옵션이 붙어있는 것을 알 수 있는데, `-N` 옵션은 배쉬 셸을 띄우지 않는 옵션이다. 포트포워딩처럼 굳이 배쉬 셸을 쓸 필요 없을 때 유용하다.\n\n```bash\nssh -N -L [localport]:[destserver]:[destport] [jumpserver]\nssh -N -L 9876:inta.server.com:80 public.server.com\n```\n\n아래의 예시를 실행하면 `localhost`의 `9876`포트를 `public.server.com`서버를 거쳐 `inta.server.com`서버의 `80`번 포트와 연결한다. 이는 보안 연결이 필요한 경우에 사용하면 좋다. 예를 들어, [code-server](https://github.com/cdr/code-server)에서도 다음과 같은 커맨드를 이용하여 code-server에 접속하는 것을 권장한다.\n\n```bash\nssh -N -L 8080:127.0.0.1:8080 \u003cinstance-ip\u003e #이렇게 한 후 브라우저에서 localhost:8080으로 접속한다.\n```\n\n### 원격 서버에서 로컬 머신으로 포트포워딩\n\n```bash\nssh -R [remoteport]:[host]:[hostport] [remote]\nssh -R 8080:localhost:5000 remote.server.com\nssh -R 8080:www.google.com:80 remote.server.com\n```\n\n이 옵션은 좀 난해하다. 정확하게는 다음과 같이 작동한다.\n\n\u003e `remote` 서버의 `remoteport`포트가 로컬 머신을 거쳐서 `host`서버의 `hostport`로 연결되게 한다.\n\n그러므로 두 번째 예시는 `remote.server.com`의 8080포트가 로컬 머신의 5000포트에 연결되도록 하며, 세 번째 예시는 `remote.server.com`의 8080번 포트가 로컬 머신을 거쳐서 `www.google.com`의 80번 포트에 연결되도록 한다. 따로 옵션을 주면 다양한 인터페이스에서 연결을 받을 수 있지만, 기본은 로컬호스트이다. 즉, 내가 웹브라우저로 `remote.server.com:8080`에 접속하면 접속이 되지 않지만, 원격 서버에서 `curl localhost:8080`으로 접속해보면 로컬 머신을 거쳐 원하는 목적 서버로 연결이 된다.\n\n### 로컬 머신에서 원격 서버로 파일 전송하기\n\n```bash\nscp [local-file-path] [username]@[host]:[remote-file-path]\nscp ~/file.txt unknownpgr@remote.server.com:\"~/remote-path\"\n```\n\n로컬 머신의 `local-file-path`에 있는 파일을 `host` 원격 서버의 `remote-file-path`디렉토리에 집어넣는다. 두번째 예시를 실행하면 로컬 머신의 `~/file.txt`파일이 `remote.server.com`서버의 `~/remote-path`디렉토리에 저장된다.\n\n### 로컬 머신에서 원격 서버로 디렉토리 전송하기\n\n```bash\nscp -r [local-folder] [user]@[host]:[remote-dir]\n```\n\n위와 거의 똑같지만, 단일 파일이 아니라 디렉토리째로 복사한다.\n\n### 원격 서버에서 로컬 머신으로 파일 전송하기\n\n```bash\nscp [user]@[host]:[remote-file] [local-dir]\n```\n\n이것 역시 로컬 머신에서 원격 서버로 전송하는 것과 완전히 똑같고, 순서만 바뀌었다. `host`원격 서버의 `remote-file`을 로컬 머신의 `local-dir`에 옮긴다. 마찬가지로 `-r`옵션을 주면 디렉토리째로 옮길 수 있다.","html":"\u003cp\u003eSSH / SCP 명령어는 주로 원격 서버에서 작업할 때 많이 쓰입니다. 알아 두면 유용한 명령어를 몇 개 정리해봤습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e아래에서 \u003ccode\u003e로컬 머신\u003c/code\u003e이라 함은 커맨드를 실행하는 바로 그 컴퓨터를 말하는 것입니다.\u003c/li\u003e\n\u003cli\u003e아래에서 \u003ccode\u003e원격 서버\u003c/code\u003e라 함은 내가 \u003ccode\u003e로컬 머신\u003c/code\u003e을 거쳐 제어하고자 하는 다른 컴퓨터를 말하는 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e원격 서버에 접속\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003essh [username]@[hostname] -p [sshport]\nssh unknownpgr@my-webserver.server.io -p 1234\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e원격 서버에서 특정 명령어 실행\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003essh [username]@[hostname] -p [sshport] \u003cspan class=\"hljs-built_in\"\u003ecommand\u003c/span\u003e\nssh unknownpgr@192.168.0.2 -p 22 make\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 원격 서버에서 해당 커맨드가 실행된다.\u003c/p\u003e\n\u003ch3\u003e원격 서버의 특정 포트와 포트포워딩\u003c/h3\u003e\n\u003cp\u003e아래 예제들을 보면 \u003ccode\u003e-N\u003c/code\u003e 옵션이 붙어있는 것을 알 수 있는데, \u003ccode\u003e-N\u003c/code\u003e 옵션은 배쉬 셸을 띄우지 않는 옵션이다. 포트포워딩처럼 굳이 배쉬 셸을 쓸 필요 없을 때 유용하다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003essh -N -L [localport]:[destserver]:[destport] [jumpserver]\nssh -N -L 9876:inta.server.com:80 public.server.com\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래의 예시를 실행하면 \u003ccode\u003elocalhost\u003c/code\u003e의 \u003ccode\u003e9876\u003c/code\u003e포트를 \u003ccode\u003epublic.server.com\u003c/code\u003e서버를 거쳐 \u003ccode\u003einta.server.com\u003c/code\u003e서버의 \u003ccode\u003e80\u003c/code\u003e번 포트와 연결한다. 이는 보안 연결이 필요한 경우에 사용하면 좋다. 예를 들어, \u003ca href=\"https://github.com/cdr/code-server\"\u003ecode-server\u003c/a\u003e에서도 다음과 같은 커맨드를 이용하여 code-server에 접속하는 것을 권장한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003essh -N -L 8080:127.0.0.1:8080 \u0026lt;instance-ip\u0026gt; \u003cspan class=\"hljs-comment\"\u003e#이렇게 한 후 브라우저에서 localhost:8080으로 접속한다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e원격 서버에서 로컬 머신으로 포트포워딩\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003essh -R [remoteport]:[host]:[hostport] [remote]\nssh -R 8080:localhost:5000 remote.server.com\nssh -R 8080:www.google.com:80 remote.server.com\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 옵션은 좀 난해하다. 정확하게는 다음과 같이 작동한다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eremote\u003c/code\u003e 서버의 \u003ccode\u003eremoteport\u003c/code\u003e포트가 로컬 머신을 거쳐서 \u003ccode\u003ehost\u003c/code\u003e서버의 \u003ccode\u003ehostport\u003c/code\u003e로 연결되게 한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e그러므로 두 번째 예시는 \u003ccode\u003eremote.server.com\u003c/code\u003e의 8080포트가 로컬 머신의 5000포트에 연결되도록 하며, 세 번째 예시는 \u003ccode\u003eremote.server.com\u003c/code\u003e의 8080번 포트가 로컬 머신을 거쳐서 \u003ccode\u003ewww.google.com\u003c/code\u003e의 80번 포트에 연결되도록 한다. 따로 옵션을 주면 다양한 인터페이스에서 연결을 받을 수 있지만, 기본은 로컬호스트이다. 즉, 내가 웹브라우저로 \u003ccode\u003eremote.server.com:8080\u003c/code\u003e에 접속하면 접속이 되지 않지만, 원격 서버에서 \u003ccode\u003ecurl localhost:8080\u003c/code\u003e으로 접속해보면 로컬 머신을 거쳐 원하는 목적 서버로 연결이 된다.\u003c/p\u003e\n\u003ch3\u003e로컬 머신에서 원격 서버로 파일 전송하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003escp [local-file-path] [username]@[host]:[remote-file-path]\nscp ~/file.txt unknownpgr@remote.server.com:\u003cspan class=\"hljs-string\"\u003e\u0026quot;~/remote-path\u0026quot;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e로컬 머신의 \u003ccode\u003elocal-file-path\u003c/code\u003e에 있는 파일을 \u003ccode\u003ehost\u003c/code\u003e 원격 서버의 \u003ccode\u003eremote-file-path\u003c/code\u003e디렉토리에 집어넣는다. 두번째 예시를 실행하면 로컬 머신의 \u003ccode\u003e~/file.txt\u003c/code\u003e파일이 \u003ccode\u003eremote.server.com\u003c/code\u003e서버의 \u003ccode\u003e~/remote-path\u003c/code\u003e디렉토리에 저장된다.\u003c/p\u003e\n\u003ch3\u003e로컬 머신에서 원격 서버로 디렉토리 전송하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003escp -r [local-folder] [user]@[host]:[remote-dir]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 거의 똑같지만, 단일 파일이 아니라 디렉토리째로 복사한다.\u003c/p\u003e\n\u003ch3\u003e원격 서버에서 로컬 머신으로 파일 전송하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003escp [user]@[host]:[remote-file] [local-dir]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것 역시 로컬 머신에서 원격 서버로 전송하는 것과 완전히 똑같고, 순서만 바뀌었다. \u003ccode\u003ehost\u003c/code\u003e원격 서버의 \u003ccode\u003eremote-file\u003c/code\u003e을 로컬 머신의 \u003ccode\u003elocal-dir\u003c/code\u003e에 옮긴다. 마찬가지로 \u003ccode\u003e-r\u003c/code\u003e옵션을 주면 디렉토리째로 옮길 수 있다.\u003c/p\u003e\n","imageMapping":{},"markdownFile":"1.md","name":"2020-08-08-code-1"},"postsInSameCategory":[{"name":"2022-12-22-programmer","title":"어떻게 개발자가 되는가?","date":"2022-12-22T14:13:19.220Z","category":"tips"},{"name":"2021-01-13-code-2","title":"유용한 파일 관련 명령어","date":"2021-01-13T06:19:32.212Z","category":"tips"},{"name":"2020-08-08-code-1","title":"유용한 SSH/SCP 명령어","date":"2020-08-08T12:31:29.912Z","category":"tips"}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2020-08-08-code-1"},"buildId":"9oj6AxLy2jV-3nD3luYn1","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>