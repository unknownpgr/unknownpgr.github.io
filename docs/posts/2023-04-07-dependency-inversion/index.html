<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="description" content="Unknownpgr&#x27;s Blog"/><link rel="icon" href="/favicon.png"/><meta property="og:title" content="Unknownpgr&#x27;s Blog"/><meta property="og:url" content="https://unknownpgr.com"/><meta property="og:image" content="/logo.png"/><title>Unknownpgr : Dependency Inversion</title><meta property="og:title" content="Unknownpgr: Dependency Inversion"/><meta name="next-head-count" content="9"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/2e1e96656eb72d38.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2e1e96656eb72d38.css" data-n-g=""/><link rel="preload" href="/_next/static/css/bb77c4673c8d1507.css" as="style"/><link rel="stylesheet" href="/_next/static/css/bb77c4673c8d1507.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-1cd5204319a0e744.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b2167bfc37ff4f0b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-ef770e12683a69af.js" defer=""></script><script src="/_next/static/usFFC4NPqMDnEnf-cuZwC/_buildManifest.js" defer=""></script><script src="/_next/static/usFFC4NPqMDnEnf-cuZwC/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="nav_nav__XkaAa"><a class="nav_logo__drPJg" href="/">[UNKNOWN-PGR]</a><a class="nav_link__KHlEJ" href="/">Home</a><a class="nav_link__KHlEJ" href="/categories/">Categories</a><a class="nav_link__KHlEJ" href="/about/">About</a></nav><main class="layout_main__j5lor"><div><h1 class="post_title__aQveY">Dependency Inversion</h1><div class="post_info__7zaFc"><i>development<!-- --> / <!-- -->2023-04-07T14:12:02.717Z</i></div><main class="post_main__mmVmG"><p>이번에 '클린 아키텍처' 책을 읽었습니다. 그러면서 의존성 역전이 왜 중요하고 어떤 목적을 가지는지 깨닫게 됐습니다. 그래서 이를 간단히 정리해두려고 합니다.</p>
<h2>의존성 역전(Dependency Inversion)이란?</h2>
<p>의존성 역전은 소프트웨어 설계 원칙 중 하나이며 다음과 같이 정의됩니다.</p>
<blockquote>
<p>상위 수준의 컴포넌트는 하위 수준의 컴포넌트에 의존하면 안된다.</p>
</blockquote>
<p>먼저 이 글에서 컴포넌트라는 말은 한 가지 기능을 수행하는 클래스나 함수들의 모임을 의미합니다. 즉, 모듈이나 패키지와 상통하는 의미로 사용하겠습니다.</p>
<p>상위 수준의 컴포넌트는 순수 논리, 비즈니스 로직에 가까운 컴포넌트를 말하며 하위 수준의 컴포넌트란 구체적인 기술, 예컨대 데이터베이스, 파일 시스템, 웹 서버 등을 말합니다. 의존이란 말 그대로 코드 상에서 그 컴포넌트를 참조하는 것을 말합니다.</p>
<p>이러한 원칙이 '의존성 역전'이라 불리는 이유는 보통 상위 컴포넌트가 하위 컴포넌트를 사용하므로 <em>제어 흐름은 상위 컴포넌트에서 하위 컴포넌트로 향하는 반면</em> 의존성은 반대로 하위 컴포넌트에서 상위 컴포넌트로 향하기 때문입니다.</p>
<p>여기서 중요한 것은 '제어 흐름'과 '의존성' 이 서로 같은 방향을 가리키는 것이 자연스럽지만 오히려 의존성이 제어 흐름과 반대로 되어야 한다는 것입니다.</p>
<h2>의존성 역전의 목적</h2>
<p>의존성 역전이 필요한 가장 중요한 이유는 코드의 유지보수성을 높이기 위함입니다.</p>
<p>의존성 역전이 코드의 유지보수성을 높이는 이유는 간단합니다.</p>
<ol>
<li>변경이 쉬운 / 빈번한 컴포넌트에 변경하기 어려운 컴포넌트가 의존하는 경우</li>
<li>변경하기 쉬운 컴포넌트의 수정이 어려운 컴포넌트의 수정을 수반하므로</li>
<li>대단히 작업량이 많아지기 때문입니다.</li>
</ol>
<p>특히 어떤 컴포넌트가 변경이 어려운 이유는 보통 다른 많은 컴포넌트들이 거기에 의존하기 때문입니다. 그렇기 때문에 작은 업데이트를 위해 코드베이스 전체를 수정하게 될 수도 있습니다.</p>
<p>예를 들어 어떤 시스템에서 유저에게 알림을 보내는 것이 대단히 중심적이고 이곳저곳에서 자주 사용되는 기능이라고 가정해보겠습니다. 이 시스템은 문자 메시지를 사용하므로 개발자는 <code>SmsSender</code>라는 클래스를 만들어 기능을 구현했습니다. 이 기능은 수백 군데에서 사용되었습니다.</p>
<p>그런데 갑자기 회사 대표가 알림 시스템에 메일을 추가하기로 결정했습니다.</p>
<blockquote>
<p>개발자: 어...</p>
</blockquote>
<p>이 경우 '알림 보내기' 라는 변경이 어렵고 (많은 곳에서 사용되므로) 논리적인, 즉 고수준의 기능이 '문자 메시지 보내기' 라는 변경하기 쉽고 저수준인 기능에 의존하였으므로 이러한 문제가 발생했습니다.</p>
<p>만약 알림 보내기 기능은 문자 메시지와 완전히 독립적으로 존재하고 반대로 문자 메시지를 보내는 기능이 알림 기능에 의존하였다면 이메일을 보내는 가능을 추가하거나 문자 메시지를 보내는 기능을 이메일까지 함께 보내도록 업데이트만 하면 되었을 것입니다.</p>
<h2>의존성 역전의 구현</h2>
<p>의존성 역전을 구현하는 다양한 방법이 있습니다. 객체지향 프로그래밍에서는 인터페이스를 사용하여 이를 구현할 수 있습니다. 이에 앞서, 먼저 기존의 구조를 분석해보겠습니다.</p>
<blockquote>
<p>아래 다이어그램에서 의존성은 점선, 제어 흐름은 실선으로 표시하였습니다.</p>
</blockquote>
<p><img src="/imgs/7cd9b36b60fc73fe0a82a8a4a58d2ed7.svg"></p>
<p>위 예시의 경우, 비즈니스 로직을 담당하는 컴포넌트에서 직접 <code>SmsSender</code>를 참조하고 있습니다. 그러므로 제어 흐름과 의존성이 같은 방향을 향합니다. 그러나 의존성 역전을 적용하면 오히려 <code>SmsSender</code>에서 비즈니스 로직 컴포넌트를 참조해야 합니다.</p>
<p>이를 위해서</p>
<ul>
<li>비즈니스 로직 컴포넌트에 <code>AlertSender</code>라는 인터페이스, 혹은 추상 클래스를 추가합니다.</li>
<li>그리고 알림을 보내는 로직에서는 <code>AlertSender</code>를 사용하여 알림을 보냅니다.</li>
<li>그리고 <code>SmsSender</code>가 <code>AlertSender</code>를 상속하도록 만듭니다.</li>
</ul>
<p><img src="/imgs/3fa976b432689e4403845e5b5ee2add0.svg"></p>
<p>이렇게 하면 비즈니스 로직 컴포넌트는 자기 자신에게 포함된 <code>AlertSender</code>만을 참조하므로 외부 의존성이 없습니다. 그러나 반대로 <code>SmsSender</code>는 비즈니스 로직 컴포넌트에 의존성을 가집니다.
그러므로 제어 흐름은 비즈니스 로직 컴포넌트에서 <code>SmsSender</code>쪽으로 향하지만 의존성은 반대로 <code>SmsSender</code>에서 비즈니스 로직 컴포넌트로 향합니다.</p>
<p>이 경우 메일을 사용하는 새로운 알림 방식을 아래와 같이 구현할 수 있습니다. 이중 어떤 방법을 선택하든 비즈니스 로직에는 전혀 변함이 없습니다.</p>
<p><img src="/imgs/e6dd3b2dc78c8cff35a48a06f1d0900e.svg"></p>
<p>물론 아래와 같이 두 가지 방법을 모두 적용하도록 알림을 보내는 컴포넌트를 수정할 수 있습니다. 그러나 어떻게 되었든 그 수정은 비즈니스 로직에 전혀 영향을 미치지 않습니다.</p>
<p><img src="/imgs/120228f8662885591752d6093862bf7e.svg"></p>
<p>이로부터 자연스럽게 Open-Closed 원칙도 달성됩니다.</p>
<h2>의존성 주입 (Dependency Injection)</h2>
<p>이 경우 한 가지 문제가 생깁니다. 비즈니스 로직 컴포넌트는 어떤 식으로든 <code>SmsSender</code>의 객체를 받아야 합니다. 그런데 비즈니스 로직 컴포넌트에서는 <code>SmsSender</code>에 대한 의존성이 전혀 없으므로 이를 생성할 수 없습니다.
따라서 외부에서 <code>SmsSender</code> 객체를 생성한 후 비즈니스 로직 컴포넌트에 주입해주어야 합니다. 이를 의존성 주입이라 합니다.</p>
<p><img src="/imgs/45b8703b557bd0d5a56bd21a9415bb40.svg"></p>
<p>의존성 주입을 하는 가장 간단한 방법은 그냥 메인 메소드에서 <code>SmsSender</code>의 객체를 실제로 생성하고 비즈니스 로직 컴포넌트에 주입하는 것입니다. BusinessLogic 컴포넌트는 이를 setter 함수 혹은 생성자 파라매터로 주입받을 수 있습니다.</p>
<blockquote>
<p>그러므로 메인 메소드는 모든 클래스에 의존성을 가지는 가장 '더러운' 메소드가 됩니다. 그러나 메인 메소드에 의존성을 가지는 그 어떤 메소드, 클래스도 존재하지 않으므로 메인 메소드는 대단히 수정하기 쉽습니다. 따라서 메인 메소드에 의존성을 전부 몰아주어도 문제가 되지 않습니다.</p>
</blockquote>
<p>그러나 컴포넌트가 많아지면 이를 직접 수행하기가 번거로울 수 있습니다. 그래서 이 작업을 자동화해주는 것이 <code>Spring Framework</code>나 <code>TypeDi</code>같은 프레임워크입니다.</p>
<blockquote>
<p>Spring framework에서 Auto wired annotation을 쓰게 되면 코드가 스프링 프레임워크 자체(injector)와 강하게 결합하여 스프링 프레임워크 없이 클래스의 사용이 불가능합니다. 이로부터 독립적인 테스트 실행 등이 어려워지므로 사용을 지양해야 합니다. 특히 private field에 auto wired annotation을 사용하면 이는 Spring framework없이는 사용이 불가능하게 되며 겉으로 드러나지 않는 숨겨진 의존성을 만들게 됩니다.</p>
</blockquote>
<h2>DI가 필요없는 의존 관계</h2>
<p>당연히 모든 의존 관계에서 제어 흐름과 의존성이 반대여야 하는 것은 아닙니다. 제어 흐름과 의존성이 같아도 전혀 문제가 없는 부분이 있는데, 당연하게도 하위 컴포넌트가 원래부터 상위 컴포넌트를 의존하는 경우입니다. 이는 인터럽트 핸들러, main 함수, 웹 서비스의 entrypoint를 포함한 제어 진입점과 주 서비스 로직 사이에 있는 컴포넌트들에게 해당됩니다. 이러한 컴포넌트들은 제어 흐름 자체가 하위 컴포넌트에서 상위 컴포넌트로 향하므로 그 방향을 바꾸면 안 됩니다.</p>
<h2>결론</h2>
<ul>
<li>Open-Closed원칙에 따라 유지보수하기 쉬운 소프트웨어 아키텍쳐를 구성하기 위해 Dependency Inversion이 요구됩니다.</li>
<li>제어 흐름은 고수준의 추상화된 컴포넌트에서 저수준의 상세 컴포넌트로 흐르지만 고수준의 컴포넌트는 수정이 어렵고 저수준의 컴포넌트는 수정이 쉬운데 의존성과 제어 흐름이 같은 방향이면 저수준 컴포넌트의 수정이 고수준 컴포넌트의 수정을 동반하여 유지보수가 어려워집니다.</li>
<li>그러므로 인터페이스 등을 통한 Dependency Inversion을 구현, 고수준 컴포넌트가 저수준 컴포넌트에 영향을 받는 것을 막습니다.</li>
<li>이때 고수준 컴포넌트는 저수준 컴포넌트의 객체를 생성할 방법이 없으므로 외부에서 객체를 생성하여 넣어 주는 것이 Dependency Injection입니다.</li>
<li>이를 자동화한 것이 Spring, TypeDi 등의 프레임워크입니다.</li>
</ul>
</main><h1>Posts in <!-- -->development<!-- --> category</h1><ul><li class="post_list__OlrZL"><a href="/posts/2023-08-16-the-form-refactoring/">The-Form Refactoring</a></li><li class="post_list__OlrZL"><a href="/posts/2023-04-10-reality-of-clean-architecture/">Reality of Clean Architecture</a></li><li class="post_listSelected__vtK9Y"><a href="/posts/2023-04-07-dependency-inversion/">Dependency Inversion</a></li><li class="post_list__OlrZL"><a href="/posts/2022-11-28-opensource/">Git-Key, 오픈소스 프로젝트</a></li><li class="post_list__OlrZL"><a href="/posts/2022-02-14-soma/">소프트웨어 마에스트로 회고</a></li></ul><div></div></div></main><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5695206410217978" data-ad-slot="9579212903" data-ad-format="auto" data-full-width-responsive="true"></ins><footer class="footer_footer__E_Uzl">© 2020 Copyright : Unknownpgr</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Dependency Inversion","category":"development","date":"2023-04-07T14:12:02.717Z","postStr":"---\ntitle: Dependency Inversion\ncategory: development\ndate: 2023-04-07T14:12:02.717Z\n\n---\n\n이번에 '클린 아키텍처' 책을 읽었습니다. 그러면서 의존성 역전이 왜 중요하고 어떤 목적을 가지는지 깨닫게 됐습니다. 그래서 이를 간단히 정리해두려고 합니다.\n\n## 의존성 역전(Dependency Inversion)이란?\n\n의존성 역전은 소프트웨어 설계 원칙 중 하나이며 다음과 같이 정의됩니다.\n\n\u003e 상위 수준의 컴포넌트는 하위 수준의 컴포넌트에 의존하면 안된다.\n\n먼저 이 글에서 컴포넌트라는 말은 한 가지 기능을 수행하는 클래스나 함수들의 모임을 의미합니다. 즉, 모듈이나 패키지와 상통하는 의미로 사용하겠습니다.\n\n상위 수준의 컴포넌트는 순수 논리, 비즈니스 로직에 가까운 컴포넌트를 말하며 하위 수준의 컴포넌트란 구체적인 기술, 예컨대 데이터베이스, 파일 시스템, 웹 서버 등을 말합니다. 의존이란 말 그대로 코드 상에서 그 컴포넌트를 참조하는 것을 말합니다.\n\n이러한 원칙이 '의존성 역전'이라 불리는 이유는 보통 상위 컴포넌트가 하위 컴포넌트를 사용하므로 _제어 흐름은 상위 컴포넌트에서 하위 컴포넌트로 향하는 반면_ 의존성은 반대로 하위 컴포넌트에서 상위 컴포넌트로 향하기 때문입니다.\n\n여기서 중요한 것은 '제어 흐름'과 '의존성' 이 서로 같은 방향을 가리키는 것이 자연스럽지만 오히려 의존성이 제어 흐름과 반대로 되어야 한다는 것입니다.\n\n## 의존성 역전의 목적\n\n의존성 역전이 필요한 가장 중요한 이유는 코드의 유지보수성을 높이기 위함입니다.\n\n의존성 역전이 코드의 유지보수성을 높이는 이유는 간단합니다.\n\n1. 변경이 쉬운 / 빈번한 컴포넌트에 변경하기 어려운 컴포넌트가 의존하는 경우\n2. 변경하기 쉬운 컴포넌트의 수정이 어려운 컴포넌트의 수정을 수반하므로\n3. 대단히 작업량이 많아지기 때문입니다.\n\n특히 어떤 컴포넌트가 변경이 어려운 이유는 보통 다른 많은 컴포넌트들이 거기에 의존하기 때문입니다. 그렇기 때문에 작은 업데이트를 위해 코드베이스 전체를 수정하게 될 수도 있습니다.\n\n예를 들어 어떤 시스템에서 유저에게 알림을 보내는 것이 대단히 중심적이고 이곳저곳에서 자주 사용되는 기능이라고 가정해보겠습니다. 이 시스템은 문자 메시지를 사용하므로 개발자는 `SmsSender`라는 클래스를 만들어 기능을 구현했습니다. 이 기능은 수백 군데에서 사용되었습니다.\n\n그런데 갑자기 회사 대표가 알림 시스템에 메일을 추가하기로 결정했습니다.\n\n\u003e 개발자: 어...\n\n이 경우 '알림 보내기' 라는 변경이 어렵고 (많은 곳에서 사용되므로) 논리적인, 즉 고수준의 기능이 '문자 메시지 보내기' 라는 변경하기 쉽고 저수준인 기능에 의존하였으므로 이러한 문제가 발생했습니다.\n\n만약 알림 보내기 기능은 문자 메시지와 완전히 독립적으로 존재하고 반대로 문자 메시지를 보내는 기능이 알림 기능에 의존하였다면 이메일을 보내는 가능을 추가하거나 문자 메시지를 보내는 기능을 이메일까지 함께 보내도록 업데이트만 하면 되었을 것입니다.\n\n## 의존성 역전의 구현\n\n의존성 역전을 구현하는 다양한 방법이 있습니다. 객체지향 프로그래밍에서는 인터페이스를 사용하여 이를 구현할 수 있습니다. 이에 앞서, 먼저 기존의 구조를 분석해보겠습니다.\n\n\u003e 아래 다이어그램에서 의존성은 점선, 제어 흐름은 실선으로 표시하였습니다.\n\n\u003cimg src=\"./imgs/a.svg\"\u003e\u003c/img\u003e\n\n위 예시의 경우, 비즈니스 로직을 담당하는 컴포넌트에서 직접 `SmsSender`를 참조하고 있습니다. 그러므로 제어 흐름과 의존성이 같은 방향을 향합니다. 그러나 의존성 역전을 적용하면 오히려 `SmsSender`에서 비즈니스 로직 컴포넌트를 참조해야 합니다.\n\n이를 위해서\n\n- 비즈니스 로직 컴포넌트에 `AlertSender`라는 인터페이스, 혹은 추상 클래스를 추가합니다.\n- 그리고 알림을 보내는 로직에서는 `AlertSender`를 사용하여 알림을 보냅니다.\n- 그리고 `SmsSender`가 `AlertSender`를 상속하도록 만듭니다.\n\n\u003cimg src=\"./imgs/b.svg\"\u003e\u003c/img\u003e\n\n이렇게 하면 비즈니스 로직 컴포넌트는 자기 자신에게 포함된 `AlertSender`만을 참조하므로 외부 의존성이 없습니다. 그러나 반대로 `SmsSender`는 비즈니스 로직 컴포넌트에 의존성을 가집니다.\n그러므로 제어 흐름은 비즈니스 로직 컴포넌트에서 `SmsSender`쪽으로 향하지만 의존성은 반대로 `SmsSender`에서 비즈니스 로직 컴포넌트로 향합니다.\n\n이 경우 메일을 사용하는 새로운 알림 방식을 아래와 같이 구현할 수 있습니다. 이중 어떤 방법을 선택하든 비즈니스 로직에는 전혀 변함이 없습니다.\n\n\u003cimg src=\"./imgs/c.svg\"\u003e\u003c/img\u003e\n\n물론 아래와 같이 두 가지 방법을 모두 적용하도록 알림을 보내는 컴포넌트를 수정할 수 있습니다. 그러나 어떻게 되었든 그 수정은 비즈니스 로직에 전혀 영향을 미치지 않습니다.\n\n\u003cimg src=\"./imgs/d.svg\"\u003e\u003c/img\u003e\n\n이로부터 자연스럽게 Open-Closed 원칙도 달성됩니다.\n\n## 의존성 주입 (Dependency Injection)\n\n이 경우 한 가지 문제가 생깁니다. 비즈니스 로직 컴포넌트는 어떤 식으로든 `SmsSender`의 객체를 받아야 합니다. 그런데 비즈니스 로직 컴포넌트에서는 `SmsSender`에 대한 의존성이 전혀 없으므로 이를 생성할 수 없습니다.\n따라서 외부에서 `SmsSender` 객체를 생성한 후 비즈니스 로직 컴포넌트에 주입해주어야 합니다. 이를 의존성 주입이라 합니다.\n\n\u003cimg src=\"./imgs/e.svg\"\u003e\u003c/img\u003e\n\n의존성 주입을 하는 가장 간단한 방법은 그냥 메인 메소드에서 `SmsSender`의 객체를 실제로 생성하고 비즈니스 로직 컴포넌트에 주입하는 것입니다. BusinessLogic 컴포넌트는 이를 setter 함수 혹은 생성자 파라매터로 주입받을 수 있습니다.\n\n\u003e 그러므로 메인 메소드는 모든 클래스에 의존성을 가지는 가장 '더러운' 메소드가 됩니다. 그러나 메인 메소드에 의존성을 가지는 그 어떤 메소드, 클래스도 존재하지 않으므로 메인 메소드는 대단히 수정하기 쉽습니다. 따라서 메인 메소드에 의존성을 전부 몰아주어도 문제가 되지 않습니다.\n\n그러나 컴포넌트가 많아지면 이를 직접 수행하기가 번거로울 수 있습니다. 그래서 이 작업을 자동화해주는 것이 `Spring Framework`나 `TypeDi`같은 프레임워크입니다.\n\n\u003e Spring framework에서 Auto wired annotation을 쓰게 되면 코드가 스프링 프레임워크 자체(injector)와 강하게 결합하여 스프링 프레임워크 없이 클래스의 사용이 불가능합니다. 이로부터 독립적인 테스트 실행 등이 어려워지므로 사용을 지양해야 합니다. 특히 private field에 auto wired annotation을 사용하면 이는 Spring framework없이는 사용이 불가능하게 되며 겉으로 드러나지 않는 숨겨진 의존성을 만들게 됩니다.\n\n## DI가 필요없는 의존 관계\n\n당연히 모든 의존 관계에서 제어 흐름과 의존성이 반대여야 하는 것은 아닙니다. 제어 흐름과 의존성이 같아도 전혀 문제가 없는 부분이 있는데, 당연하게도 하위 컴포넌트가 원래부터 상위 컴포넌트를 의존하는 경우입니다. 이는 인터럽트 핸들러, main 함수, 웹 서비스의 entrypoint를 포함한 제어 진입점과 주 서비스 로직 사이에 있는 컴포넌트들에게 해당됩니다. 이러한 컴포넌트들은 제어 흐름 자체가 하위 컴포넌트에서 상위 컴포넌트로 향하므로 그 방향을 바꾸면 안 됩니다.\n\n## 결론\n\n- Open-Closed원칙에 따라 유지보수하기 쉬운 소프트웨어 아키텍쳐를 구성하기 위해 Dependency Inversion이 요구됩니다.\n- 제어 흐름은 고수준의 추상화된 컴포넌트에서 저수준의 상세 컴포넌트로 흐르지만 고수준의 컴포넌트는 수정이 어렵고 저수준의 컴포넌트는 수정이 쉬운데 의존성과 제어 흐름이 같은 방향이면 저수준 컴포넌트의 수정이 고수준 컴포넌트의 수정을 동반하여 유지보수가 어려워집니다.\n- 그러므로 인터페이스 등을 통한 Dependency Inversion을 구현, 고수준 컴포넌트가 저수준 컴포넌트에 영향을 받는 것을 막습니다.\n- 이때 고수준 컴포넌트는 저수준 컴포넌트의 객체를 생성할 방법이 없으므로 외부에서 객체를 생성하여 넣어 주는 것이 Dependency Injection입니다.\n- 이를 자동화한 것이 Spring, TypeDi 등의 프레임워크입니다.","html":"\u003cp\u003e이번에 '클린 아키텍처' 책을 읽었습니다. 그러면서 의존성 역전이 왜 중요하고 어떤 목적을 가지는지 깨닫게 됐습니다. 그래서 이를 간단히 정리해두려고 합니다.\u003c/p\u003e\n\u003ch2\u003e의존성 역전(Dependency Inversion)이란?\u003c/h2\u003e\n\u003cp\u003e의존성 역전은 소프트웨어 설계 원칙 중 하나이며 다음과 같이 정의됩니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e상위 수준의 컴포넌트는 하위 수준의 컴포넌트에 의존하면 안된다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e먼저 이 글에서 컴포넌트라는 말은 한 가지 기능을 수행하는 클래스나 함수들의 모임을 의미합니다. 즉, 모듈이나 패키지와 상통하는 의미로 사용하겠습니다.\u003c/p\u003e\n\u003cp\u003e상위 수준의 컴포넌트는 순수 논리, 비즈니스 로직에 가까운 컴포넌트를 말하며 하위 수준의 컴포넌트란 구체적인 기술, 예컨대 데이터베이스, 파일 시스템, 웹 서버 등을 말합니다. 의존이란 말 그대로 코드 상에서 그 컴포넌트를 참조하는 것을 말합니다.\u003c/p\u003e\n\u003cp\u003e이러한 원칙이 '의존성 역전'이라 불리는 이유는 보통 상위 컴포넌트가 하위 컴포넌트를 사용하므로 \u003cem\u003e제어 흐름은 상위 컴포넌트에서 하위 컴포넌트로 향하는 반면\u003c/em\u003e 의존성은 반대로 하위 컴포넌트에서 상위 컴포넌트로 향하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e여기서 중요한 것은 '제어 흐름'과 '의존성' 이 서로 같은 방향을 가리키는 것이 자연스럽지만 오히려 의존성이 제어 흐름과 반대로 되어야 한다는 것입니다.\u003c/p\u003e\n\u003ch2\u003e의존성 역전의 목적\u003c/h2\u003e\n\u003cp\u003e의존성 역전이 필요한 가장 중요한 이유는 코드의 유지보수성을 높이기 위함입니다.\u003c/p\u003e\n\u003cp\u003e의존성 역전이 코드의 유지보수성을 높이는 이유는 간단합니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e변경이 쉬운 / 빈번한 컴포넌트에 변경하기 어려운 컴포넌트가 의존하는 경우\u003c/li\u003e\n\u003cli\u003e변경하기 쉬운 컴포넌트의 수정이 어려운 컴포넌트의 수정을 수반하므로\u003c/li\u003e\n\u003cli\u003e대단히 작업량이 많아지기 때문입니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e특히 어떤 컴포넌트가 변경이 어려운 이유는 보통 다른 많은 컴포넌트들이 거기에 의존하기 때문입니다. 그렇기 때문에 작은 업데이트를 위해 코드베이스 전체를 수정하게 될 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어 어떤 시스템에서 유저에게 알림을 보내는 것이 대단히 중심적이고 이곳저곳에서 자주 사용되는 기능이라고 가정해보겠습니다. 이 시스템은 문자 메시지를 사용하므로 개발자는 \u003ccode\u003eSmsSender\u003c/code\u003e라는 클래스를 만들어 기능을 구현했습니다. 이 기능은 수백 군데에서 사용되었습니다.\u003c/p\u003e\n\u003cp\u003e그런데 갑자기 회사 대표가 알림 시스템에 메일을 추가하기로 결정했습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e개발자: 어...\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이 경우 '알림 보내기' 라는 변경이 어렵고 (많은 곳에서 사용되므로) 논리적인, 즉 고수준의 기능이 '문자 메시지 보내기' 라는 변경하기 쉽고 저수준인 기능에 의존하였으므로 이러한 문제가 발생했습니다.\u003c/p\u003e\n\u003cp\u003e만약 알림 보내기 기능은 문자 메시지와 완전히 독립적으로 존재하고 반대로 문자 메시지를 보내는 기능이 알림 기능에 의존하였다면 이메일을 보내는 가능을 추가하거나 문자 메시지를 보내는 기능을 이메일까지 함께 보내도록 업데이트만 하면 되었을 것입니다.\u003c/p\u003e\n\u003ch2\u003e의존성 역전의 구현\u003c/h2\u003e\n\u003cp\u003e의존성 역전을 구현하는 다양한 방법이 있습니다. 객체지향 프로그래밍에서는 인터페이스를 사용하여 이를 구현할 수 있습니다. 이에 앞서, 먼저 기존의 구조를 분석해보겠습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e아래 다이어그램에서 의존성은 점선, 제어 흐름은 실선으로 표시하였습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/7cd9b36b60fc73fe0a82a8a4a58d2ed7.svg\"\u003e\u003c/p\u003e\n\u003cp\u003e위 예시의 경우, 비즈니스 로직을 담당하는 컴포넌트에서 직접 \u003ccode\u003eSmsSender\u003c/code\u003e를 참조하고 있습니다. 그러므로 제어 흐름과 의존성이 같은 방향을 향합니다. 그러나 의존성 역전을 적용하면 오히려 \u003ccode\u003eSmsSender\u003c/code\u003e에서 비즈니스 로직 컴포넌트를 참조해야 합니다.\u003c/p\u003e\n\u003cp\u003e이를 위해서\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e비즈니스 로직 컴포넌트에 \u003ccode\u003eAlertSender\u003c/code\u003e라는 인터페이스, 혹은 추상 클래스를 추가합니다.\u003c/li\u003e\n\u003cli\u003e그리고 알림을 보내는 로직에서는 \u003ccode\u003eAlertSender\u003c/code\u003e를 사용하여 알림을 보냅니다.\u003c/li\u003e\n\u003cli\u003e그리고 \u003ccode\u003eSmsSender\u003c/code\u003e가 \u003ccode\u003eAlertSender\u003c/code\u003e를 상속하도록 만듭니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/3fa976b432689e4403845e5b5ee2add0.svg\"\u003e\u003c/p\u003e\n\u003cp\u003e이렇게 하면 비즈니스 로직 컴포넌트는 자기 자신에게 포함된 \u003ccode\u003eAlertSender\u003c/code\u003e만을 참조하므로 외부 의존성이 없습니다. 그러나 반대로 \u003ccode\u003eSmsSender\u003c/code\u003e는 비즈니스 로직 컴포넌트에 의존성을 가집니다.\n그러므로 제어 흐름은 비즈니스 로직 컴포넌트에서 \u003ccode\u003eSmsSender\u003c/code\u003e쪽으로 향하지만 의존성은 반대로 \u003ccode\u003eSmsSender\u003c/code\u003e에서 비즈니스 로직 컴포넌트로 향합니다.\u003c/p\u003e\n\u003cp\u003e이 경우 메일을 사용하는 새로운 알림 방식을 아래와 같이 구현할 수 있습니다. 이중 어떤 방법을 선택하든 비즈니스 로직에는 전혀 변함이 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/e6dd3b2dc78c8cff35a48a06f1d0900e.svg\"\u003e\u003c/p\u003e\n\u003cp\u003e물론 아래와 같이 두 가지 방법을 모두 적용하도록 알림을 보내는 컴포넌트를 수정할 수 있습니다. 그러나 어떻게 되었든 그 수정은 비즈니스 로직에 전혀 영향을 미치지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/120228f8662885591752d6093862bf7e.svg\"\u003e\u003c/p\u003e\n\u003cp\u003e이로부터 자연스럽게 Open-Closed 원칙도 달성됩니다.\u003c/p\u003e\n\u003ch2\u003e의존성 주입 (Dependency Injection)\u003c/h2\u003e\n\u003cp\u003e이 경우 한 가지 문제가 생깁니다. 비즈니스 로직 컴포넌트는 어떤 식으로든 \u003ccode\u003eSmsSender\u003c/code\u003e의 객체를 받아야 합니다. 그런데 비즈니스 로직 컴포넌트에서는 \u003ccode\u003eSmsSender\u003c/code\u003e에 대한 의존성이 전혀 없으므로 이를 생성할 수 없습니다.\n따라서 외부에서 \u003ccode\u003eSmsSender\u003c/code\u003e 객체를 생성한 후 비즈니스 로직 컴포넌트에 주입해주어야 합니다. 이를 의존성 주입이라 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/45b8703b557bd0d5a56bd21a9415bb40.svg\"\u003e\u003c/p\u003e\n\u003cp\u003e의존성 주입을 하는 가장 간단한 방법은 그냥 메인 메소드에서 \u003ccode\u003eSmsSender\u003c/code\u003e의 객체를 실제로 생성하고 비즈니스 로직 컴포넌트에 주입하는 것입니다. BusinessLogic 컴포넌트는 이를 setter 함수 혹은 생성자 파라매터로 주입받을 수 있습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e그러므로 메인 메소드는 모든 클래스에 의존성을 가지는 가장 '더러운' 메소드가 됩니다. 그러나 메인 메소드에 의존성을 가지는 그 어떤 메소드, 클래스도 존재하지 않으므로 메인 메소드는 대단히 수정하기 쉽습니다. 따라서 메인 메소드에 의존성을 전부 몰아주어도 문제가 되지 않습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e그러나 컴포넌트가 많아지면 이를 직접 수행하기가 번거로울 수 있습니다. 그래서 이 작업을 자동화해주는 것이 \u003ccode\u003eSpring Framework\u003c/code\u003e나 \u003ccode\u003eTypeDi\u003c/code\u003e같은 프레임워크입니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSpring framework에서 Auto wired annotation을 쓰게 되면 코드가 스프링 프레임워크 자체(injector)와 강하게 결합하여 스프링 프레임워크 없이 클래스의 사용이 불가능합니다. 이로부터 독립적인 테스트 실행 등이 어려워지므로 사용을 지양해야 합니다. 특히 private field에 auto wired annotation을 사용하면 이는 Spring framework없이는 사용이 불가능하게 되며 겉으로 드러나지 않는 숨겨진 의존성을 만들게 됩니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eDI가 필요없는 의존 관계\u003c/h2\u003e\n\u003cp\u003e당연히 모든 의존 관계에서 제어 흐름과 의존성이 반대여야 하는 것은 아닙니다. 제어 흐름과 의존성이 같아도 전혀 문제가 없는 부분이 있는데, 당연하게도 하위 컴포넌트가 원래부터 상위 컴포넌트를 의존하는 경우입니다. 이는 인터럽트 핸들러, main 함수, 웹 서비스의 entrypoint를 포함한 제어 진입점과 주 서비스 로직 사이에 있는 컴포넌트들에게 해당됩니다. 이러한 컴포넌트들은 제어 흐름 자체가 하위 컴포넌트에서 상위 컴포넌트로 향하므로 그 방향을 바꾸면 안 됩니다.\u003c/p\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eOpen-Closed원칙에 따라 유지보수하기 쉬운 소프트웨어 아키텍쳐를 구성하기 위해 Dependency Inversion이 요구됩니다.\u003c/li\u003e\n\u003cli\u003e제어 흐름은 고수준의 추상화된 컴포넌트에서 저수준의 상세 컴포넌트로 흐르지만 고수준의 컴포넌트는 수정이 어렵고 저수준의 컴포넌트는 수정이 쉬운데 의존성과 제어 흐름이 같은 방향이면 저수준 컴포넌트의 수정이 고수준 컴포넌트의 수정을 동반하여 유지보수가 어려워집니다.\u003c/li\u003e\n\u003cli\u003e그러므로 인터페이스 등을 통한 Dependency Inversion을 구현, 고수준 컴포넌트가 저수준 컴포넌트에 영향을 받는 것을 막습니다.\u003c/li\u003e\n\u003cli\u003e이때 고수준 컴포넌트는 저수준 컴포넌트의 객체를 생성할 방법이 없으므로 외부에서 객체를 생성하여 넣어 주는 것이 Dependency Injection입니다.\u003c/li\u003e\n\u003cli\u003e이를 자동화한 것이 Spring, TypeDi 등의 프레임워크입니다.\u003c/li\u003e\n\u003c/ul\u003e\n","imageMapping":{"./imgs/a.svg":"/imgs/7cd9b36b60fc73fe0a82a8a4a58d2ed7.svg","./imgs/b.svg":"/imgs/3fa976b432689e4403845e5b5ee2add0.svg","./imgs/c.svg":"/imgs/e6dd3b2dc78c8cff35a48a06f1d0900e.svg","./imgs/d.svg":"/imgs/120228f8662885591752d6093862bf7e.svg","./imgs/e.svg":"/imgs/45b8703b557bd0d5a56bd21a9415bb40.svg"},"name":"2023-04-07-dependency-inversion"},"postsInSameCategory":[{"name":"2023-08-16-the-form-refactoring","title":"The-Form Refactoring","date":"2023-08-16T14:17:01.499Z","category":"development"},{"name":"2023-04-10-reality-of-clean-architecture","title":"Reality of Clean Architecture","date":"2023-04-10T07:01:03.591Z","category":"development"},{"name":"2023-04-07-dependency-inversion","title":"Dependency Inversion","date":"2023-04-07T14:12:02.717Z","category":"development"},{"name":"2022-11-28-opensource","title":"Git-Key, 오픈소스 프로젝트","date":"2022-11-28T13:25:30.725Z","category":"development"},{"name":"2022-02-14-soma","title":"소프트웨어 마에스트로 회고","date":"2022-02-14T09:16:24.171Z","category":"development"}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2023-04-07-dependency-inversion"},"buildId":"usFFC4NPqMDnEnf-cuZwC","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>