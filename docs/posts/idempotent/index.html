<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="description" content="Unknownpgr&#x27;s Blog"/><link rel="icon" href="/favicon.png"/><meta property="og:title" content="Unknownpgr&#x27;s Blog"/><meta property="og:url" content="https://unknownpgr.com"/><meta property="og:image" content="/logo.png"/><title>Unknownpgr : 멱등성 (idempotent)에 대한 설명</title><meta property="og:title" content="Unknownpgr: 멱등성 (idempotent)에 대한 설명"/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/fcd26abcfb6841ad.css" as="style"/><link rel="stylesheet" href="/_next/static/css/fcd26abcfb6841ad.css" data-n-g=""/><link rel="preload" href="/_next/static/css/14062eec27ee8c3f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/14062eec27ee8c3f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-1cd5204319a0e744.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0ca39d1e6e08dd12.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-3739d6f13b15a64a.js" defer=""></script><script src="/_next/static/xB2RRnAJi1O2lVg1hpjzf/_buildManifest.js" defer=""></script><script src="/_next/static/xB2RRnAJi1O2lVg1hpjzf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="header_header__n6agz"><h1>[UNKNOWN-PGR]</h1><div><a class="header_nav__JpY1D" href="/">MAIN</a><a class="header_nav__JpY1D" href="/about/">ABOUT</a></div></div><main class="layout_main__j5lor"><div><h1 class="post_title__aQveY">멱등성 (idempotent)에 대한 설명</h1><main class="post_main__mmVmG"><p>이번에 프로젝트를 진행하며 API관련 공부를 하다 보니 멱등성(idempotent)에 대해 명확하게 정리해둘 필요를 느꼈습니다.</p>
<h1>멱등성(idempotnet)란?</h1>
<p>간단하게, 컴퓨터과학에서는 어떤 동일한 작업을 두 번 하더라도 똑같은 결과가 나올 경우 이 작업을 Idempotent하다고 말합니다.</p>
<p><img src="/imgs/4ac2bc2e09f2dd92c6bdc91efdbf5751.jpg" alt="on-off"></p>
<p>위 이미지는 기차의 목적지 표지판(그게 뭔지는 잘 모르겠습니다만)을 끄거나 켜는 장치입니다. 전원 버튼이 켜는 버튼과 끄는 버튼으로 분리되어있으므로 버튼을 여러 번 누르더라도 한 번 누른 것과 동일하게 동작합니다. 그러므로 이 전원 버튼을 누르는 작업은 idempotent하다고 말할 수 있습니다.  반대로 TV나 컴퓨터 등의 장치를 생각해보면 전원 버튼이 하나밖에 없습니다. 그러므로 처음 전원 버튼을 누를 때에는 전원이 켜지고, 두 번째 누르면 전원이 꺼집니다. 그러므로 이런 전자기기의 전원 버튼을 누르는 작업은 idempotent하지 않습니다.</p>
<h2>왜 멱등성을 가지게 설계해야 하는가?</h2>
<p>API를 비롯한 여러 연산들을 멱등성을 가지게 설계해야 하는 이유는 무엇일까요? 물론 여러가지 장점이 있겠습니다만, 제가 생각하는 장점 두 가지는 functional programming을 고려한 설계가 저절로 이뤄진다는 것과 양방향 통신을 할 필요가 없어 신뢰도가 높고 실행 속도가 빠르다는 것이라고 봅니다.</p>
<p>먼저 functional programming의 측면에서 멱등성을 살펴보겠습니다. 연산이 멱등하려면 오직 그 결과가 입력에만 의존해야 합니다. 왜냐하면 연산이 입력에만 의존하지 않을 경우, 같은 연산을 두 번 해도 다른 결과를 얻을 수 있으므로 멱등하지 않기 때문입니다. 예를 들어 어떤 변수 <mjx-container class="MathJax" jax="SVG" style="direction: ltr; position: relative;"><svg style="overflow: visible; min-height: 1px; min-width: 1px; vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z" style="stroke-width: 3;"></path></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline" style="top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; position: absolute; padding: 1px 0px 0px 0px; border: 0px; display: block; width: auto; overflow: hidden;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></mjx-assistive-mml></mjx-container>의 값을 설정하는 연산을 생각해봅시다. 만약 이 값을 예컨대 랜덤한 값이나 현재 시간, 혹은 <mjx-container class="MathJax" jax="SVG" style="direction: ltr; position: relative;"><svg style="overflow: visible; min-height: 1px; min-width: 1px; vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.191ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 2294.4 748" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z" style="stroke-width: 3;"></path></g><g data-mml-node="mo" transform="translate(794.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z" style="stroke-width: 3;"></path></g><g data-mml-node="mn" transform="translate(1794.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" style="stroke-width: 3;"></path></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline" style="top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; position: absolute; padding: 1px 0px 0px 0px; border: 0px; display: block; width: auto; overflow: hidden;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>+</mo><mn>1</mn></math></mjx-assistive-mml></mjx-container> 등으로 설정한다면 연산을 여러 번 하게 되면 <mjx-container class="MathJax" jax="SVG" style="direction: ltr; position: relative;"><svg style="overflow: visible; min-height: 1px; min-width: 1px; vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z" style="stroke-width: 3;"></path></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline" style="top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; position: absolute; padding: 1px 0px 0px 0px; border: 0px; display: block; width: auto; overflow: hidden;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></mjx-assistive-mml></mjx-container>값이 매번 달라집니다. 그러므로 어떤 연산을 멱등하게 설계하면 그 연산의 결과는 자연스럽게 입력에만 의존할 수밖에 없고, 따라서 저절로 functional 한 로직을 작성할 수 있습니다.</p>
<p>다음으로 양방향 통신의 측면에서 멱등성을 살펴보겠습니다. 이는 특히 웹이나 DB측면에서 멱등성을 바라본 것입니다. 먼저 신뢰도 측면에셔, 멱등한 연산은 여러 번 적용하더라도 결과가 같기 때문에 실수로, 혹은 오류로 인해 요청이 두 번 들어가는 경우라도 결과가 바뀌는 경우가 없어 신뢰도가 높습니다.</p>
<blockquote>
<p>그런 상황이 얼마나 발생하겠느냐고 할 수도 있겠지만, Kafka와 같은 파이프라인 구조를 사용할 경우 경우에 따라 delivery-once가 지켜지지 않을 수도 있습니다. 좀 low-level이기는 하지만, TCP 통신의 경우에도 패킷이 전달되었지만 ACK패킷이 유실되어 같은 패킷이 두 번 전달되는 경우가 발생할 수 있습니다. 물론 커널에서 중복 패킷을 무시하므로 일반적인 케이스에서는 이를 신경쓸 필요가 없습니다.</p>
</blockquote>
<p>그리고 속도 측면에서 보통 연산이 멱등하지 않은 경우 DB참조가 필요하기 때문인 경우가 많은데, 클라이언트가 서버에서 값을 받아오는 것이 매우 오래 걸릴 뿐만 아니라 서버 내부에서도 보통 DB가 병목 지점인 경우가 많으므로 DB참조가 많으면 좋지 않습니다. 이때 연산을 멱등하게 설계하면 단방향, 즉 DB를 참조하는 연산 없이 DB에 쓰는 연산만으로 구현할 수 있으므로 실행 속도를 향상시킬 수 있습니다.</p>
<h2>멱등성에 대한 실용적인 예시</h2>
<p>예를 들어 웹 사이트 게시글에서 '좋아요'를 누르는 연산을 가정해보겠습니다. '좋아요'를 두 번 누르면 취소됩니다. 이 연산을 다음과 같이 구현한다고 가정해봅시다.</p>
<ol>
<li>모든 유저의 '좋아요' 상태는 기본적으로 False이다.</li>
<li>유저가 사이트를 방문하면 기존에 '좋아요'를 눌렀는지 여부를 브라우저로 전송한다.</li>
<li>브라우저에서 유저가 버튼을 누른다.</li>
<li>서버로 <code>clickLike</code> 요청이 전송된다.</li>
<li>서버는 <code>clickLike</code> 요청을 받으면 DB에서 '좋아요' 상태를 반전한다.</li>
<li>브라우저에서 버튼의 상태를 반전한다.</li>
</ol>
<p>이 로직은 간단하게 생각하면 별로 문제될 것이 없어보입니다. 그러나 다음과 같은 시나리오를 생각해볼 수 있습니다.</p>
<ol>
<li>유저가 데스크톱으로 게시글을 읽고 있습니다.</li>
<li>그러다가 집 밖에 나갈 필요가 생겨서 스마트폰으로 읽던 글을 이어서 읽습니다. (YouTube, Facebook 등 대부분의 매체가 모바일과 데스크톱을 동시 지원하므로 별로 특별한 케이스가 아닙니다.)</li>
<li>글을 다 읽은 유저는 글이 마음에 들어서 좋아요를 누릅니다. (서버에서 '좋아요' 상태가 True로 바뀝니다.)</li>
<li>이후에 다시 데스크톱으로 돌아온 유저는 '좋아요'가 눌려있지 않은 것을 발견합니다. (유저가 새로고침을 아직 하지 않았다고 가정해봅시다.)</li>
<li>유저는 좋아요를 한 번 더 누릅니다. (서버에서 '좋아요' 상태가 False로 바뀝니다.)</li>
<li>그런데 브라우저에서 버튼의 상태는 좋아요가 눌린 것으로 표시됩니다.</li>
</ol>
<blockquote>
<p>위 예시에서 든 '좋아요' 기능은 별로 중요하지 않은 기능이지만, 유저의 개인정보나 환경설정과 같은 중요한 기능으로 쉽게 확장해볼 수 있습니다.</p>
</blockquote>
<p>이 문제를 기존 로직을 그대로 가져가면서 해결하려면 Websocket등을 사용해서 실시간 동기화를 구현하거나 서버에서 요청을 받은 후 새로운 상태를 브라우저로 반환하도록 구현해야 합니다.</p>
<p>그러나 실시간 동기화를 모든 유저에 대해 구현하면 서버에 엄청난 부담이 될 것이고, 반전한 상태를 브라우저로 반환하면 서버에서 응답이 전송될 때까지 유저가 기다려야 합니다.</p>
<p>이때 API를 멱등하게 설계하여 서버로 <code>clickLike</code> 요청을 전송하는 대신 like상태를 True로 설정하는 <code>like/true</code> 요청과 False로 설정하는 <code>like/false</code> 요청을 전송한다고 가정해봅시다. 그러면 위와 같은 시나리오가 발생했을 경우 유저는 서버에 요청을 보내기만 하고 아무런 응답을 받지 않아도 유저가 의도한 대로 기능이 작동하는 것을 알 수 있습니다.</p>
</main><h1>Posts in <!-- -->development<!-- --> category</h1><ul><li class="post_list__OlrZL"><a href="/posts/rbac/">RBAC 구현</a></li><li class="post_list__OlrZL"><a href="/posts/review-jsp/">개발자가 마주치는 진짜 문제들[2]</a></li><li class="post_list__OlrZL"><a href="/posts/data-process/">개발자가 마주치는 진짜 문제들</a></li><li class="post_listSelected__vtK9Y"><a href="/posts/idempotent/">멱등성 (idempotent)에 대한 설명</a></li><li class="post_list__OlrZL"><a href="/posts/how-to-cooperate/">협업 잘하는 법</a></li></ul></div></main><footer class="footer_footer__E_Uzl">© 2020 Copyright : Unknownpgr</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"멱등성 (idempotent)에 대한 설명","category":"development","date":"2021-07-19T05:36:15.583Z","html":"\u003cp\u003e이번에 프로젝트를 진행하며 API관련 공부를 하다 보니 멱등성(idempotent)에 대해 명확하게 정리해둘 필요를 느꼈습니다.\u003c/p\u003e\n\u003ch1\u003e멱등성(idempotnet)란?\u003c/h1\u003e\n\u003cp\u003e간단하게, 컴퓨터과학에서는 어떤 동일한 작업을 두 번 하더라도 똑같은 결과가 나올 경우 이 작업을 Idempotent하다고 말합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/4ac2bc2e09f2dd92c6bdc91efdbf5751.jpg\" alt=\"on-off\"\u003e\u003c/p\u003e\n\u003cp\u003e위 이미지는 기차의 목적지 표지판(그게 뭔지는 잘 모르겠습니다만)을 끄거나 켜는 장치입니다. 전원 버튼이 켜는 버튼과 끄는 버튼으로 분리되어있으므로 버튼을 여러 번 누르더라도 한 번 누른 것과 동일하게 동작합니다. 그러므로 이 전원 버튼을 누르는 작업은 idempotent하다고 말할 수 있습니다.  반대로 TV나 컴퓨터 등의 장치를 생각해보면 전원 버튼이 하나밖에 없습니다. 그러므로 처음 전원 버튼을 누를 때에는 전원이 켜지고, 두 번째 누르면 전원이 꺼집니다. 그러므로 이런 전자기기의 전원 버튼을 누르는 작업은 idempotent하지 않습니다.\u003c/p\u003e\n\u003ch2\u003e왜 멱등성을 가지게 설계해야 하는가?\u003c/h2\u003e\n\u003cp\u003eAPI를 비롯한 여러 연산들을 멱등성을 가지게 설계해야 하는 이유는 무엇일까요? 물론 여러가지 장점이 있겠습니다만, 제가 생각하는 장점 두 가지는 functional programming을 고려한 설계가 저절로 이뤄진다는 것과 양방향 통신을 할 필요가 없어 신뢰도가 높고 실행 속도가 빠르다는 것이라고 봅니다.\u003c/p\u003e\n\u003cp\u003e먼저 functional programming의 측면에서 멱등성을 살펴보겠습니다. 연산이 멱등하려면 오직 그 결과가 입력에만 의존해야 합니다. 왜냐하면 연산이 입력에만 의존하지 않을 경우, 같은 연산을 두 번 해도 다른 결과를 얻을 수 있으므로 멱등하지 않기 때문입니다. 예를 들어 어떤 변수 \u003cmjx-container class=\"MathJax\" jax=\"SVG\" style=\"direction: ltr; position: relative;\"\u003e\u003csvg style=\"overflow: visible; min-height: 1px; min-width: 1px; vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.294ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 572 453\" aria-hidden=\"true\"\u003e\u003cg stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"\u003e\u003cg data-mml-node=\"math\"\u003e\u003cg data-mml-node=\"mi\"\u003e\u003cpath data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\" style=\"stroke-width: 3;\"\u003e\u003c/path\u003e\u003c/g\u003e\u003c/g\u003e\u003c/g\u003e\u003c/svg\u003e\u003cmjx-assistive-mml unselectable=\"on\" display=\"inline\" style=\"top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; position: absolute; padding: 1px 0px 0px 0px; border: 0px; display: block; width: auto; overflow: hidden;\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003cmi\u003ex\u003c/mi\u003e\u003c/math\u003e\u003c/mjx-assistive-mml\u003e\u003c/mjx-container\u003e의 값을 설정하는 연산을 생각해봅시다. 만약 이 값을 예컨대 랜덤한 값이나 현재 시간, 혹은 \u003cmjx-container class=\"MathJax\" jax=\"SVG\" style=\"direction: ltr; position: relative;\"\u003e\u003csvg style=\"overflow: visible; min-height: 1px; min-width: 1px; vertical-align: -0.186ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.191ex\" height=\"1.692ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -666 2294.4 748\" aria-hidden=\"true\"\u003e\u003cg stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"\u003e\u003cg data-mml-node=\"math\"\u003e\u003cg data-mml-node=\"mi\"\u003e\u003cpath data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\" style=\"stroke-width: 3;\"\u003e\u003c/path\u003e\u003c/g\u003e\u003cg data-mml-node=\"mo\" transform=\"translate(794.2,0)\"\u003e\u003cpath data-c=\"2B\" d=\"M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z\" style=\"stroke-width: 3;\"\u003e\u003c/path\u003e\u003c/g\u003e\u003cg data-mml-node=\"mn\" transform=\"translate(1794.4,0)\"\u003e\u003cpath data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\" style=\"stroke-width: 3;\"\u003e\u003c/path\u003e\u003c/g\u003e\u003c/g\u003e\u003c/g\u003e\u003c/svg\u003e\u003cmjx-assistive-mml unselectable=\"on\" display=\"inline\" style=\"top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; position: absolute; padding: 1px 0px 0px 0px; border: 0px; display: block; width: auto; overflow: hidden;\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003cmi\u003ex\u003c/mi\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmn\u003e1\u003c/mn\u003e\u003c/math\u003e\u003c/mjx-assistive-mml\u003e\u003c/mjx-container\u003e 등으로 설정한다면 연산을 여러 번 하게 되면 \u003cmjx-container class=\"MathJax\" jax=\"SVG\" style=\"direction: ltr; position: relative;\"\u003e\u003csvg style=\"overflow: visible; min-height: 1px; min-width: 1px; vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.294ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 572 453\" aria-hidden=\"true\"\u003e\u003cg stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"\u003e\u003cg data-mml-node=\"math\"\u003e\u003cg data-mml-node=\"mi\"\u003e\u003cpath data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\" style=\"stroke-width: 3;\"\u003e\u003c/path\u003e\u003c/g\u003e\u003c/g\u003e\u003c/g\u003e\u003c/svg\u003e\u003cmjx-assistive-mml unselectable=\"on\" display=\"inline\" style=\"top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; position: absolute; padding: 1px 0px 0px 0px; border: 0px; display: block; width: auto; overflow: hidden;\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003cmi\u003ex\u003c/mi\u003e\u003c/math\u003e\u003c/mjx-assistive-mml\u003e\u003c/mjx-container\u003e값이 매번 달라집니다. 그러므로 어떤 연산을 멱등하게 설계하면 그 연산의 결과는 자연스럽게 입력에만 의존할 수밖에 없고, 따라서 저절로 functional 한 로직을 작성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음으로 양방향 통신의 측면에서 멱등성을 살펴보겠습니다. 이는 특히 웹이나 DB측면에서 멱등성을 바라본 것입니다. 먼저 신뢰도 측면에셔, 멱등한 연산은 여러 번 적용하더라도 결과가 같기 때문에 실수로, 혹은 오류로 인해 요청이 두 번 들어가는 경우라도 결과가 바뀌는 경우가 없어 신뢰도가 높습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e그런 상황이 얼마나 발생하겠느냐고 할 수도 있겠지만, Kafka와 같은 파이프라인 구조를 사용할 경우 경우에 따라 delivery-once가 지켜지지 않을 수도 있습니다. 좀 low-level이기는 하지만, TCP 통신의 경우에도 패킷이 전달되었지만 ACK패킷이 유실되어 같은 패킷이 두 번 전달되는 경우가 발생할 수 있습니다. 물론 커널에서 중복 패킷을 무시하므로 일반적인 케이스에서는 이를 신경쓸 필요가 없습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e그리고 속도 측면에서 보통 연산이 멱등하지 않은 경우 DB참조가 필요하기 때문인 경우가 많은데, 클라이언트가 서버에서 값을 받아오는 것이 매우 오래 걸릴 뿐만 아니라 서버 내부에서도 보통 DB가 병목 지점인 경우가 많으므로 DB참조가 많으면 좋지 않습니다. 이때 연산을 멱등하게 설계하면 단방향, 즉 DB를 참조하는 연산 없이 DB에 쓰는 연산만으로 구현할 수 있으므로 실행 속도를 향상시킬 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e멱등성에 대한 실용적인 예시\u003c/h2\u003e\n\u003cp\u003e예를 들어 웹 사이트 게시글에서 '좋아요'를 누르는 연산을 가정해보겠습니다. '좋아요'를 두 번 누르면 취소됩니다. 이 연산을 다음과 같이 구현한다고 가정해봅시다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e모든 유저의 '좋아요' 상태는 기본적으로 False이다.\u003c/li\u003e\n\u003cli\u003e유저가 사이트를 방문하면 기존에 '좋아요'를 눌렀는지 여부를 브라우저로 전송한다.\u003c/li\u003e\n\u003cli\u003e브라우저에서 유저가 버튼을 누른다.\u003c/li\u003e\n\u003cli\u003e서버로 \u003ccode\u003eclickLike\u003c/code\u003e 요청이 전송된다.\u003c/li\u003e\n\u003cli\u003e서버는 \u003ccode\u003eclickLike\u003c/code\u003e 요청을 받으면 DB에서 '좋아요' 상태를 반전한다.\u003c/li\u003e\n\u003cli\u003e브라우저에서 버튼의 상태를 반전한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 로직은 간단하게 생각하면 별로 문제될 것이 없어보입니다. 그러나 다음과 같은 시나리오를 생각해볼 수 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e유저가 데스크톱으로 게시글을 읽고 있습니다.\u003c/li\u003e\n\u003cli\u003e그러다가 집 밖에 나갈 필요가 생겨서 스마트폰으로 읽던 글을 이어서 읽습니다. (YouTube, Facebook 등 대부분의 매체가 모바일과 데스크톱을 동시 지원하므로 별로 특별한 케이스가 아닙니다.)\u003c/li\u003e\n\u003cli\u003e글을 다 읽은 유저는 글이 마음에 들어서 좋아요를 누릅니다. (서버에서 '좋아요' 상태가 True로 바뀝니다.)\u003c/li\u003e\n\u003cli\u003e이후에 다시 데스크톱으로 돌아온 유저는 '좋아요'가 눌려있지 않은 것을 발견합니다. (유저가 새로고침을 아직 하지 않았다고 가정해봅시다.)\u003c/li\u003e\n\u003cli\u003e유저는 좋아요를 한 번 더 누릅니다. (서버에서 '좋아요' 상태가 False로 바뀝니다.)\u003c/li\u003e\n\u003cli\u003e그런데 브라우저에서 버튼의 상태는 좋아요가 눌린 것으로 표시됩니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e위 예시에서 든 '좋아요' 기능은 별로 중요하지 않은 기능이지만, 유저의 개인정보나 환경설정과 같은 중요한 기능으로 쉽게 확장해볼 수 있습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이 문제를 기존 로직을 그대로 가져가면서 해결하려면 Websocket등을 사용해서 실시간 동기화를 구현하거나 서버에서 요청을 받은 후 새로운 상태를 브라우저로 반환하도록 구현해야 합니다.\u003c/p\u003e\n\u003cp\u003e그러나 실시간 동기화를 모든 유저에 대해 구현하면 서버에 엄청난 부담이 될 것이고, 반전한 상태를 브라우저로 반환하면 서버에서 응답이 전송될 때까지 유저가 기다려야 합니다.\u003c/p\u003e\n\u003cp\u003e이때 API를 멱등하게 설계하여 서버로 \u003ccode\u003eclickLike\u003c/code\u003e 요청을 전송하는 대신 like상태를 True로 설정하는 \u003ccode\u003elike/true\u003c/code\u003e 요청과 False로 설정하는 \u003ccode\u003elike/false\u003c/code\u003e 요청을 전송한다고 가정해봅시다. 그러면 위와 같은 시나리오가 발생했을 경우 유저는 서버에 요청을 보내기만 하고 아무런 응답을 받지 않아도 유저가 의도한 대로 기능이 작동하는 것을 알 수 있습니다.\u003c/p\u003e\n","name":"idempotent"},"postsInSameCategory":[{"title":"RBAC 구현","category":"development","date":"2021-12-02T17:45:23.057Z","name":"rbac"},{"title":"개발자가 마주치는 진짜 문제들[2]","category":"development","date":"2021-09-16T01:20:31.668Z","name":"review-jsp"},{"title":"개발자가 마주치는 진짜 문제들","category":"development","date":"2021-08-15T15:30:08.769Z","name":"data-process"},{"title":"멱등성 (idempotent)에 대한 설명","category":"development","date":"2021-07-19T05:36:15.583Z","name":"idempotent"},{"title":"협업 잘하는 법","category":"development","date":"2021-01-09T13:39:34.560Z","name":"how-to-cooperate"}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"idempotent"},"buildId":"xB2RRnAJi1O2lVg1hpjzf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>