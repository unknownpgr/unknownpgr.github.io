<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="description" content="Unknownpgr&#x27;s Blog"/><link rel="icon" href="/favicon.png"/><meta property="og:title" content="Unknownpgr&#x27;s Blog"/><meta property="og:url" content="https://unknownpgr.com"/><meta property="og:image" content="/logo.png"/><title>Unknownpgr : 알고리즘:부분문자열</title><meta property="og:title" content="Unknownpgr: 알고리즘:부분문자열"/><meta name="next-head-count" content="9"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/2e1e96656eb72d38.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2e1e96656eb72d38.css" data-n-g=""/><link rel="preload" href="/_next/static/css/14062eec27ee8c3f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/14062eec27ee8c3f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-1cd5204319a0e744.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b2167bfc37ff4f0b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-fe089d9906e2f51a.js" defer=""></script><script src="/_next/static/mlDsSYuRos2I8DdvvANeQ/_buildManifest.js" defer=""></script><script src="/_next/static/mlDsSYuRos2I8DdvvANeQ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="nav_nav__XkaAa"><a class="nav_logo__drPJg" href="/">[UNKNOWN-PGR]</a><a class="nav_link__KHlEJ" href="/">Home</a><a class="nav_link__KHlEJ" href="/categories/">Categories</a><a class="nav_link__KHlEJ" href="/about/">About</a></nav><main class="layout_main__j5lor"><div><h1 class="post_title__aQveY">알고리즘:부분문자열</h1><main class="post_main__mmVmG"><p>다음 문제로 뭘 풀까 하다가 양심없게도 알고리즘 소모임에서 이번에 진행하는 <code>LeetCode</code> 문제를 보고 풀어보기로 했습니다. 오늘 풀어 본 문제는 <code>반복되는 문자가 없는 가장 긴 부분문자열</code>이라는 문제인데요. 말 그대로</p>
<ol>
<li>주어진 문자열의 연속되는 부분 문자열 중</li>
<li>반복되는 문자가 하나도 없는 것들 중</li>
<li>가장 긴 것의 길이는?</li>
</ol>
<p>이라는 문제였습니다.</p>
<h1><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 접근</h1>
<p>저는 처음에 이것이 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 시간/공간복잡도를 필요로 하는 dynamic programming 문제인줄로만 생각했습니다. 그래서 <code>dp</code>라는 이름의 2차원 배열을 만들고, <code>dp[s][e]</code>를 채웠습니다. <code>dp[s][e]</code>는</p>
<ul>
<li>만약 주어진 문자열에서 <code>s</code> 번째에서 시작해서 <code>e</code>번째에서 끝나는 부분 문자열이 반복되는 문자가 없을 경우
<ul>
<li>그 부분 문자열을 값을 가지고</li>
</ul>
</li>
<li>반복되는 문자가 있을 경우
<ul>
<li>False를 값으로 가집니다.</li>
</ul>
</li>
</ul>
<p>이렇게 구성할 경우, <code>dp[s][e]</code>의 값을 알아내려면 <code>dp[s+1][e]</code>와 <code>dp[s][e-1]</code>의 값만 알면 됩니다. 그러므로 <code>dp[x][x]=str[x]</code>로 초기화하고 점차 이 배열을 채워나가면서 <code>문자열 길이 = e-s+1</code>의 최댓값을 구하면 됩니다.</p>
<p>(실제로는 <code>dp[s][e]</code>에는 문자열 전체가 아니라 시작 문자와 끝 문자만 저장되면 됩니다. 그러나 이 알고리즘은 실패한 알고리즘이므로 아이디어만 설명하고 넘어갑니다.)</p>
<p>이 알고리즘은 <code>dp</code>배열을 구상하고 채우는 것이 약간 복잡할 뿐, 아이디어만 떠올리면 별로 어렵지 않습니다. 그래서 금방 python으로 코딩한 후, 제출해봤습니다. 아래는 소스코드입니다.</p>
<pre><code class="language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, st</span>):
        <span class="hljs-string">&quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;</span>
        l = <span class="hljs-built_in">len</span>(st)
        <span class="hljs-keyword">if</span> l==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        dp = [[<span class="hljs-literal">False</span>]*l <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l)]
        <span class="hljs-string">&#x27;&#x27;&#x27;
        dp[s][e] = substr[s][e] including s,e
        &#x27;&#x27;&#x27;</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l):
            dp[i][i] = st[i]
        ml = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,l):
<span class="hljs-comment">#           i = string length - 1</span>
            trueFlag = <span class="hljs-literal">False</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l-i):
                s = j
                e = s+i
                a = dp[s+<span class="hljs-number">1</span>][e]
                b = dp[s][e-<span class="hljs-number">1</span>]
                <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">False</span>) <span class="hljs-keyword">and</span> (b <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">False</span>) <span class="hljs-keyword">and</span> (b[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a[-<span class="hljs-number">1</span>]):
                    ml = i+<span class="hljs-number">1</span>
                    dp[s][e] = st[s]+st[e]
                    trueFlag = <span class="hljs-literal">True</span>
                <span class="hljs-keyword">else</span>:
                    dp[s][e] = <span class="hljs-literal">False</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> trueFlag:
                <span class="hljs-keyword">return</span> ml
        <span class="hljs-keyword">return</span> ml
</code></pre>
<p>결과는...</p>
<p><img src="/imgs/77da0f02c47ba1382dedb283eb859307.png" alt="image-20210119224241196"></p>
<p>하나가 시간이 부족해서 안 되네요. 맞왜틀을 몇 번 시전하고 난 후, 입력을 자세히 살펴보니 아래와 같은 문자열이 계속 반복되고 있었습니다. (<code>LeetCode</code>에서는 친절하게도 실패한 입력이 무엇인지를 알려줬습니다.)</p>
<pre><code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~
</code></pre>
<p>그러므로 전체 문자열 길이가 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>이라 하고, 이 문자열의 길이가 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>라 하면 길이 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>미만의 부분 문자열에서는 반복이 절대 나타나지 않습니다. 이 경우, 제 알고리즘에서는 시간복잡도가 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>m</mi><mi>k</mi><mo>−</mo><msup><mi>k</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2mk-k^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">mk</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>이 됩니다. 이는 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>과 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>에 대해 단조증가입니다. 그런데 대충 보니 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>은 문제에서 제시한 최댓값정도인 듯하고, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>는 가능한 모든 문자를 사용했으므로 또한 최댓값이 됩니다. 그래서 이것이 가능한 입력 중 최악의 입력케이스였습니다.</p>
<h1><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 접근</h1>
<p>근데 한참 고민하다 보니까, 그냥 해결책이 떠올랐습니다. <code>dp</code>배열을 저렇게 구상할 게 아니라, 이렇게 하면 어떨까?</p>
<pre><code>dp[i]=i번째 문자열을 끝으로 하는 반복되는 문자가 없는 가장 긴 부분문자열의 시작 위치
</code></pre>
<p>그리고 딕셔너리 <code>la</code>를 만들어서, 다음과 같이 정의합니다.</p>
<pre><code>la[x]=현재 위치 이전에 문자 x가 나타난 마지막 위치. x가 한 번도 만약 나타나지 않았으면 0.
</code></pre>
<p>이렇게 하면 다음과 같은 알고리즘을 사용할 수 있습니다.</p>
<ul>
<li>부분문자열의 최대 길이를 <code>maxLength=0</code>이라 두자.</li>
<li>위치 <code>i</code>에서 문자가 <code>x</code>라 하자.</li>
<li>만약 마지막으로 <code>x</code>가 나타난 위치가 <code>dp[i-1]</code>보다 작다면, 이는 <code>dp[i-1]</code>에서 <code>i</code>사이에는 중복된 문자가 하나도 없다는 뜻이다.
<ul>
<li>그러므로 <code>dp[i]=dp[i-1]</code></li>
</ul>
</li>
<li>만약 마지막으로 <code>x</code>가 나타난 위치(<code>la[x]</code>)가 <code>dp[i-1]</code>보다 크다면, 이는 <code>la[x]+1</code>과 <code>i</code>사이에는 중복된 문자가 하나도 없다는 뜻이다.
<ul>
<li>그러므로 <code>dp[i]=la[x]+1</code></li>
</ul>
</li>
<li><code>i-dp[i]+1</code>이 <code>maxLength</code>보다 크다면 <code>maxLength=i-dp[i]+1</code>.</li>
</ul>
<p>사실 이 알고리즘을 다시 한 번 살펴보면 <code>dp</code>배열에서 오직 <code>i-1</code>번째 인덱스에만 접근한다는 것을 알 수 있습니다. 그러므로 <code>dp</code>는 굳이 배열로 구성할 필요 없이 그냥 변수 하나로 둬도 무방합니다.</p>
<p>따라서 다음과 같이 코드를 작성해봤습니다. 아래 코드에서 <code>av</code>가 <code>dp</code>와 같은 의미입니다.</p>
<pre><code class="language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, st</span>):
        l = <span class="hljs-built_in">len</span>(st)
        <span class="hljs-keyword">if</span> l&lt;<span class="hljs-number">2</span>:
            <span class="hljs-keyword">return</span> l
        la = {st[<span class="hljs-number">0</span>]:<span class="hljs-number">0</span>}
        av = <span class="hljs-number">0</span>
        ml = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,l):
            <span class="hljs-keyword">if</span> st[i] <span class="hljs-keyword">in</span> la:
                av = <span class="hljs-built_in">max</span>(av,la[st[i]]+<span class="hljs-number">1</span>)
            la[st[i]]=i
            <span class="hljs-keyword">if</span> (i-av)&gt;ml:
                ml = i-av
        <span class="hljs-keyword">return</span> ml+<span class="hljs-number">1</span>
</code></pre>
<p>코드가 훨씬 짧고 간결해졌습니다.</p>
<p><img src="/imgs/744254c167103fcb5ed7518a756355e9.png" alt="image-20210119230859665"></p>
<p>제출 결과, 모든 케이스를 통과했고 상위 10%정도 실행 속도라고 하네요. ㅎㅎ</p>
<p>아래쪽에는 사용한 메모리에서 어느 정도 위치에 있는지를 보여주는데요.</p>
<p><img src="/imgs/720116994db629ee3ffbfdb460406b68.png" alt="image-20210119231015410"></p>
<p>흠... 뭔가 제가 모르는, 메모리를 더 적게 사용하는 방법이 있나 봅니다. 어쨌든 통과했고... 빠르면 된 거 아니겠습니까.ㅎ</p>
<p>메모리도 그래프가 저렇게 생겨서 그렇지, 5%정도밖에 차이가 나지 않습니다. 그런 걸 보니 뭔가 변수 하나 더 쓰고 말고 정도의 차이인가 봅니다.</p>
</main><h1>Posts in <!-- -->algorithm<!-- --> category</h1><ul><li class="post_list__OlrZL"><a href="/posts/2021-04-05-quine/">콰인(Quine)</a></li><li class="post_listSelected__vtK9Y"><a href="/posts/2021-01-19-algorithm-2/">알고리즘:부분문자열</a></li><li class="post_list__OlrZL"><a href="/posts/2021-01-17-algorithm-1/">알고리즘:N-queens problem</a></li></ul><div></div></div></main><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5695206410217978" data-ad-slot="9579212903" data-ad-format="auto" data-full-width-responsive="true"></ins><footer class="footer_footer__E_Uzl">© 2020 Copyright : Unknownpgr</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"알고리즘:부분문자열","category":"algorithm","date":"2021-01-19T14:25:47.455Z","html":"\u003cp\u003e다음 문제로 뭘 풀까 하다가 양심없게도 알고리즘 소모임에서 이번에 진행하는 \u003ccode\u003eLeetCode\u003c/code\u003e 문제를 보고 풀어보기로 했습니다. 오늘 풀어 본 문제는 \u003ccode\u003e반복되는 문자가 없는 가장 긴 부분문자열\u003c/code\u003e이라는 문제인데요. 말 그대로\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문자열의 연속되는 부분 문자열 중\u003c/li\u003e\n\u003cli\u003e반복되는 문자가 하나도 없는 것들 중\u003c/li\u003e\n\u003cli\u003e가장 긴 것의 길이는?\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이라는 문제였습니다.\u003c/p\u003e\n\u003ch1\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eO\u003c/mi\u003e\u003cmo stretchy=\"false\"\u003e(\u003c/mo\u003e\u003cmsup\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmn\u003e2\u003c/mn\u003e\u003c/msup\u003e\u003cmo stretchy=\"false\"\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eO(n^2)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.02778em;\"\u003eO\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.8141em;\"\u003e\u003cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e 접근\u003c/h1\u003e\n\u003cp\u003e저는 처음에 이것이 \u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eO\u003c/mi\u003e\u003cmo stretchy=\"false\"\u003e(\u003c/mo\u003e\u003cmsup\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmn\u003e2\u003c/mn\u003e\u003c/msup\u003e\u003cmo stretchy=\"false\"\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eO(n^2)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.02778em;\"\u003eO\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.8141em;\"\u003e\u003cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e 시간/공간복잡도를 필요로 하는 dynamic programming 문제인줄로만 생각했습니다. 그래서 \u003ccode\u003edp\u003c/code\u003e라는 이름의 2차원 배열을 만들고, \u003ccode\u003edp[s][e]\u003c/code\u003e를 채웠습니다. \u003ccode\u003edp[s][e]\u003c/code\u003e는\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e만약 주어진 문자열에서 \u003ccode\u003es\u003c/code\u003e 번째에서 시작해서 \u003ccode\u003ee\u003c/code\u003e번째에서 끝나는 부분 문자열이 반복되는 문자가 없을 경우\n\u003cul\u003e\n\u003cli\u003e그 부분 문자열을 값을 가지고\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e반복되는 문자가 있을 경우\n\u003cul\u003e\n\u003cli\u003eFalse를 값으로 가집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게 구성할 경우, \u003ccode\u003edp[s][e]\u003c/code\u003e의 값을 알아내려면 \u003ccode\u003edp[s+1][e]\u003c/code\u003e와 \u003ccode\u003edp[s][e-1]\u003c/code\u003e의 값만 알면 됩니다. 그러므로 \u003ccode\u003edp[x][x]=str[x]\u003c/code\u003e로 초기화하고 점차 이 배열을 채워나가면서 \u003ccode\u003e문자열 길이 = e-s+1\u003c/code\u003e의 최댓값을 구하면 됩니다.\u003c/p\u003e\n\u003cp\u003e(실제로는 \u003ccode\u003edp[s][e]\u003c/code\u003e에는 문자열 전체가 아니라 시작 문자와 끝 문자만 저장되면 됩니다. 그러나 이 알고리즘은 실패한 알고리즘이므로 아이디어만 설명하고 넘어갑니다.)\u003c/p\u003e\n\u003cp\u003e이 알고리즘은 \u003ccode\u003edp\u003c/code\u003e배열을 구상하고 채우는 것이 약간 복잡할 뿐, 아이디어만 떠올리면 별로 어렵지 않습니다. 그래서 금방 python으로 코딩한 후, 제출해봤습니다. 아래는 소스코드입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSolution\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eobject\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elengthOfLongestSubstring\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, st\u003c/span\u003e):\n        \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u0026quot;\n        :type s: str\n        :rtype: int\n        \u0026quot;\u0026quot;\u0026quot;\u003c/span\u003e\n        l = \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(st)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e l==\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n        dp = [[\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e]*l \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e _ \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(l)]\n        \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u0026#x27;\n        dp[s][e] = substr[s][e] including s,e\n        \u0026#x27;\u0026#x27;\u0026#x27;\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(l):\n            dp[i][i] = st[i]\n        ml = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,l):\n\u003cspan class=\"hljs-comment\"\u003e#           i = string length - 1\u003c/span\u003e\n            trueFlag = \u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e j \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(l-i):\n                s = j\n                e = s+i\n                a = dp[s+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e][e]\n                b = dp[s][e-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (a \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enot\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eand\u003c/span\u003e (b \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enot\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eand\u003c/span\u003e (b[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enot\u003c/span\u003e a[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]):\n                    ml = i+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n                    dp[s][e] = st[s]+st[e]\n                    trueFlag = \u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e\n                \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n                    dp[s][e] = \u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enot\u003c/span\u003e trueFlag:\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ml\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과는...\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/77da0f02c47ba1382dedb283eb859307.png\" alt=\"image-20210119224241196\"\u003e\u003c/p\u003e\n\u003cp\u003e하나가 시간이 부족해서 안 되네요. 맞왜틀을 몇 번 시전하고 난 후, 입력을 자세히 살펴보니 아래와 같은 문자열이 계속 반복되고 있었습니다. (\u003ccode\u003eLeetCode\u003c/code\u003e에서는 친절하게도 실패한 입력이 무엇인지를 알려줬습니다.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\\\u0026quot;#$%\u0026amp;'()*+,-./:;\u0026lt;=\u0026gt;?@[\\\\]^_`{|}~\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러므로 전체 문자열 길이가 \u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003em\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003em\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003em\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e이라 하고, 이 문자열의 길이가 \u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003ek\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003ek\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6944em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.03148em;\"\u003ek\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e라 하면 길이 \u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003ek\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003ek\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6944em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.03148em;\"\u003ek\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e미만의 부분 문자열에서는 반복이 절대 나타나지 않습니다. 이 경우, 제 알고리즘에서는 시간복잡도가 \u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eO\u003c/mi\u003e\u003cmo stretchy=\"false\"\u003e(\u003c/mo\u003e\u003cmn\u003e2\u003c/mn\u003e\u003cmi\u003em\u003c/mi\u003e\u003cmi\u003ek\u003c/mi\u003e\u003cmo\u003e−\u003c/mo\u003e\u003cmsup\u003e\u003cmi\u003ek\u003c/mi\u003e\u003cmn\u003e2\u003c/mn\u003e\u003c/msup\u003e\u003cmo stretchy=\"false\"\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eO(2mk-k^2)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.02778em;\"\u003eO\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord\"\u003e2\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.03148em;\"\u003emk\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e−\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.03148em;\"\u003ek\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.8141em;\"\u003e\u003cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e이 됩니다. 이는 \u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003em\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003em\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003em\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e과 \u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003ek\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003ek\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6944em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.03148em;\"\u003ek\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e에 대해 단조증가입니다. 그런데 대충 보니 \u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003em\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003em\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003em\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e은 문제에서 제시한 최댓값정도인 듯하고, \u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003ek\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003ek\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6944em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.03148em;\"\u003ek\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e는 가능한 모든 문자를 사용했으므로 또한 최댓값이 됩니다. 그래서 이것이 가능한 입력 중 최악의 입력케이스였습니다.\u003c/p\u003e\n\u003ch1\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eO\u003c/mi\u003e\u003cmo stretchy=\"false\"\u003e(\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo stretchy=\"false\"\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eO(n)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.02778em;\"\u003eO\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e 접근\u003c/h1\u003e\n\u003cp\u003e근데 한참 고민하다 보니까, 그냥 해결책이 떠올랐습니다. \u003ccode\u003edp\u003c/code\u003e배열을 저렇게 구상할 게 아니라, 이렇게 하면 어떨까?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edp[i]=i번째 문자열을 끝으로 하는 반복되는 문자가 없는 가장 긴 부분문자열의 시작 위치\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 딕셔너리 \u003ccode\u003ela\u003c/code\u003e를 만들어서, 다음과 같이 정의합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ela[x]=현재 위치 이전에 문자 x가 나타난 마지막 위치. x가 한 번도 만약 나타나지 않았으면 0.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 다음과 같은 알고리즘을 사용할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e부분문자열의 최대 길이를 \u003ccode\u003emaxLength=0\u003c/code\u003e이라 두자.\u003c/li\u003e\n\u003cli\u003e위치 \u003ccode\u003ei\u003c/code\u003e에서 문자가 \u003ccode\u003ex\u003c/code\u003e라 하자.\u003c/li\u003e\n\u003cli\u003e만약 마지막으로 \u003ccode\u003ex\u003c/code\u003e가 나타난 위치가 \u003ccode\u003edp[i-1]\u003c/code\u003e보다 작다면, 이는 \u003ccode\u003edp[i-1]\u003c/code\u003e에서 \u003ccode\u003ei\u003c/code\u003e사이에는 중복된 문자가 하나도 없다는 뜻이다.\n\u003cul\u003e\n\u003cli\u003e그러므로 \u003ccode\u003edp[i]=dp[i-1]\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e만약 마지막으로 \u003ccode\u003ex\u003c/code\u003e가 나타난 위치(\u003ccode\u003ela[x]\u003c/code\u003e)가 \u003ccode\u003edp[i-1]\u003c/code\u003e보다 크다면, 이는 \u003ccode\u003ela[x]+1\u003c/code\u003e과 \u003ccode\u003ei\u003c/code\u003e사이에는 중복된 문자가 하나도 없다는 뜻이다.\n\u003cul\u003e\n\u003cli\u003e그러므로 \u003ccode\u003edp[i]=la[x]+1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ei-dp[i]+1\u003c/code\u003e이 \u003ccode\u003emaxLength\u003c/code\u003e보다 크다면 \u003ccode\u003emaxLength=i-dp[i]+1\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e사실 이 알고리즘을 다시 한 번 살펴보면 \u003ccode\u003edp\u003c/code\u003e배열에서 오직 \u003ccode\u003ei-1\u003c/code\u003e번째 인덱스에만 접근한다는 것을 알 수 있습니다. 그러므로 \u003ccode\u003edp\u003c/code\u003e는 굳이 배열로 구성할 필요 없이 그냥 변수 하나로 둬도 무방합니다.\u003c/p\u003e\n\u003cp\u003e따라서 다음과 같이 코드를 작성해봤습니다. 아래 코드에서 \u003ccode\u003eav\u003c/code\u003e가 \u003ccode\u003edp\u003c/code\u003e와 같은 의미입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSolution\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eobject\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elengthOfLongestSubstring\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, st\u003c/span\u003e):\n        l = \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(st)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e l\u0026lt;\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e l\n        la = {st[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]:\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e}\n        av = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n        ml = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,l):\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e st[i] \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e la:\n                av = \u003cspan class=\"hljs-built_in\"\u003emax\u003c/span\u003e(av,la[st[i]]+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n            la[st[i]]=i\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (i-av)\u0026gt;ml:\n                ml = i-av\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ml+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e코드가 훨씬 짧고 간결해졌습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/744254c167103fcb5ed7518a756355e9.png\" alt=\"image-20210119230859665\"\u003e\u003c/p\u003e\n\u003cp\u003e제출 결과, 모든 케이스를 통과했고 상위 10%정도 실행 속도라고 하네요. ㅎㅎ\u003c/p\u003e\n\u003cp\u003e아래쪽에는 사용한 메모리에서 어느 정도 위치에 있는지를 보여주는데요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/720116994db629ee3ffbfdb460406b68.png\" alt=\"image-20210119231015410\"\u003e\u003c/p\u003e\n\u003cp\u003e흠... 뭔가 제가 모르는, 메모리를 더 적게 사용하는 방법이 있나 봅니다. 어쨌든 통과했고... 빠르면 된 거 아니겠습니까.ㅎ\u003c/p\u003e\n\u003cp\u003e메모리도 그래프가 저렇게 생겨서 그렇지, 5%정도밖에 차이가 나지 않습니다. 그런 걸 보니 뭔가 변수 하나 더 쓰고 말고 정도의 차이인가 봅니다.\u003c/p\u003e\n","name":"2021-01-19-algorithm-2"},"postsInSameCategory":[{"title":"콰인(Quine)","category":"algorithm","date":"2021-04-05T21:27:20.117Z","name":"2021-04-05-quine"},{"title":"알고리즘:부분문자열","category":"algorithm","date":"2021-01-19T14:25:47.455Z","name":"2021-01-19-algorithm-2"},{"title":"알고리즘:N-queens problem","category":"algorithm","date":"2021-01-17T17:26:17.050Z","name":"2021-01-17-algorithm-1"}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2021-01-19-algorithm-2"},"buildId":"mlDsSYuRos2I8DdvvANeQ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>