<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="description" content="Unknownpgr&#x27;s Blog"/><link rel="icon" href="/favicon.png"/><meta property="og:title" content="Unknownpgr&#x27;s Blog"/><meta property="og:url" content="https://unknownpgr.com"/><meta property="og:image" content="/logo.png"/><title>Unknownpgr : trace-cmd 및 ftrace 이해하기</title><meta property="og:title" content="Unknownpgr: trace-cmd 및 ftrace 이해하기"/><meta name="next-head-count" content="9"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/2e1e96656eb72d38.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2e1e96656eb72d38.css" data-n-g=""/><link rel="preload" href="/_next/static/css/14062eec27ee8c3f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/14062eec27ee8c3f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-1cd5204319a0e744.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b2167bfc37ff4f0b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-fe089d9906e2f51a.js" defer=""></script><script src="/_next/static/GEhWU355MLMK38xGjJhyZ/_buildManifest.js" defer=""></script><script src="/_next/static/GEhWU355MLMK38xGjJhyZ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="nav_nav__XkaAa"><a class="nav_logo__drPJg" href="/">[UNKNOWN-PGR]</a><a class="nav_link__KHlEJ" href="/">Home</a><a class="nav_link__KHlEJ" href="/categories/">Categories</a><a class="nav_link__KHlEJ" href="/about/">About</a></nav><main class="layout_main__j5lor"><div><h1 class="post_title__aQveY">trace-cmd 및 ftrace 이해하기</h1><main class="post_main__mmVmG"><p>이 글에서는 <code>ftrace</code> 및 <code>ftrace</code>의 커맨드라인 유틸리티인 <code>trace-cmd</code>의 동작 원리를 이해하고, 이를 사용하여 리눅스 커널 트레이싱을 해 보고자 합니다.</p>
<p><img src="/imgs/dc98064e8bc40d83d91362d4ce1dd9d3.png" alt="Commands To Check Bad Sectors On Hard Disk In Linux | Itsubuntu.com"></p>
<h1>ftrace 이해하기</h1>
<h2>ftrace란?</h2>
<p><code>ftrace</code> 란 linux에서 제공하는 일종의 프레임워크입니다. <code>ftrace</code>는 <code>strace</code> 등과 다르게 하나의 프로그램이 아니고 리눅스에서 제공하는 기능의 일종이라서, 안타깝게도 <code>ftrace ping 8.8.8.8</code> 과 같은 느낌으로 간단하게 사용할 수는 없습니다.</p>
<p><code>ftrace</code>는 <code>/sys/kernel/debug/tracing</code> 디렉토리에 있는 파일시스템에 접근하여 읽거나 쓰는 방식으로 작동합니다. 예를 들어서, 아래와 같이 <code>do_page_fault</code> 함수 호출을 tracing할 수 있습니다.</p>
<pre><code class="language-bash"><span class="hljs-built_in">cd</span> /sys/kernel/debug/tracing
<span class="hljs-built_in">echo</span> <span class="hljs-keyword">function</span> &gt; current_tracer
<span class="hljs-built_in">echo</span> do_page_fault &gt; set_ftrace_filter
<span class="hljs-built_in">cat</span> trace
</code></pre>
<p>위 코드를 보면, 먼저 <code>tracer</code>를 <code>function</code>으로 설정하고 있습니다. <code>tracer</code>란 트레이싱을 실제로 수행하는 플러그인을 말하는데, <code>function</code>으로 설정하면 모든 function call을 수집하고, <code>event</code>로 설정하면 모든 이벤트를 수집하는 방식입니다. 그 다음 줄의 <code>set_trace_filter</code>는 그 이름에서 알 수 있듯, 트레이싱되는 것들 중 일부만을 선택하겠다는 의미입니다. 이 경우에는 <code>do_page_fault</code> 함수만을 수집했습니다. 마지막으로 <code>trace</code> 파일을 읽음으로써 실제 트레이싱을 수행합니다. 아래는 <code>ftrace</code>의 사용 예시입니다. (<a href="https://lwn.net/Articles/365835/">출처</a>)</p>
<pre><code>    [tracing]# echo function &gt; current_tracer
    [tracing]# cat current_tracer
    function

    [tracing]# cat trace | head -10
    # tracer: function
    #
    #           TASK-PID    CPU#    TIMESTAMP  FUNCTION
    #              | |       |          |         |
                bash-16939 [000]  6075.461561: mutex_unlock &lt;-tracing_set_tracer
              &lt;idle&gt;-0     [001]  6075.461561: _spin_unlock_irqrestore &lt;-hrtimer_get_next_event
              &lt;idle&gt;-0     [001]  6075.461562: rcu_needs_cpu &lt;-tick_nohz_stop_sched_tick
                bash-16939 [000]  6075.461563: inotify_inode_queue_event &lt;-vfs_write
              &lt;idle&gt;-0     [001]  6075.461563: mwait_idle &lt;-cpu_idle
                bash-16939 [000]  6075.461563: __fsnotify_parent &lt;-vfs_write
</code></pre>
<h2>ftrace의 동작 원리</h2>
<p>이 <code>ftrace</code>는 그러면 어떻게 동작하는 걸까요? 유저 스페이스에서 동작하는 프로그램을 디버깅하는 것도 쉽지 않은데 커널에서 수행되는 작업들을, 그것도 여러 cpu에서 수행되는 작업들을 전부 수집하기란 쉽지 않아 보입니다. (사실 저는 <code>ftrace</code>에 대해 알기 전까지는 이런 작업이 가능하다는 것 자체를 몰랐습니다.) 심지어 <code>ftrace</code>를 사용한다고 해서 프로세스의 실행 속도가 엄청나게 느려지거나 하지도 않습니다. (물론 어느 정도 느려지기는 합니다만, 약 20~30%정도밖에 느려지지 않는다고 합니다.)</p>
<p><a href="https://en.wikipedia.org/wiki/Ftrace#cite_note-9">위키백과</a>와 여러 인터넷 자료들을 찾아 본 결과(<a href="https://jvns.ca/blog/2017/03/19/getting-started-with-ftrace/">자료 1</a>, <a href="https://elinux.org/images/d/d6/Measuring-function-duration-with-ftrace.pdf">자료 2</a>, <a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt">자료 3</a>), 자세하지는 않지만 대강의 작동 원리를 파악할 수 있었습니다.</p>
<h3>Function Entry Tracing</h3>
<p>먼저 function entry tracing의 경우 애초에 커널이 컴파일될 때 특수한 instruction이 삽입됩니다. 구체적으로는 커널을 컴파일할 때 <code>gcc</code>에서 <code>-pg</code> 옵션을 주면 함수가 호출될 때 <code>mcount</code>라는 함수를 호출하는 instruction을 삽입합니다. 구체적으로는 아래와 같습니다.</p>
<pre><code class="language-asm">mov ip, lr
bl 0 &lt;mcount&gt;
andeq r0, r0, r8, lsr #32
</code></pre>
<p>이 <code>mcount</code>라는 함수는 실제로 사용되는 함수는 아니며, 나중에 다른 함수로 대체될, 아무것도 하지 않는 function stub입니다.</p>
<p>이렇게 컴파일이 끝난 후, <code>recordmcount</code>라는 프로그램이 실행됩니다. 이 프로그램은 C 오브젝트의 ELF header를 파싱하여 <code>.text</code> 섹션(실제로 코드가 저장되는 섹션)에서 <code>mcount</code>함수를 호출하는 위치를 전부 찾아냅니다. 그리고 <code>__mcount_loc</code>이라는 섹션을 생성하여 이 섹션에 <code>mcount</code> 함수를 호출하는 위치를 전부 기록하고, 이것을 다시 원래 오브젝트에 링크합니다.</p>
<p>이후 커널이 부팅될 때, SMP가 초기화되기 전에 <code>ftrace</code>에 의해 이 부분이 전부 <code>NOP</code> (아무것도 하지 않는 instruction)으로 바뀝니다. 모듈의 경우에는 모듈이 로드되기 전에 이 과정이 수행됩니다. <code>ftrace</code>에는 트레이싱이 가능한 함수들의 목록이 저장되는 <code>available_filter_functions</code> 리스트가 있는데, 모듈의 경우에는 추가적으로 이 리스트에 모듈의 함수들이 등록됩니다. 물론 모듈이 unload될 때에는 이 리스트에서 모듈에 포함된 함수들을 삭제합니다.</p>
<p>부팅이 끝난 후 나중에 <code>ftrace</code>가 enable 되면 앞서 <code>NOP</code>으로 대체했던 instruction들을 다시 원래대로 돌리는 작업이 수행됩니다. 구체적으로는 다시 원래의 <code>mcount</code>를 호출하는 instruction들을 복구하되, 이번에는 기존의 function stub인 <code>mcount</code>를 호출하는 대신 <code>ftrace</code>에 구현되어있는 새로운 <code>mcount</code>를 호출하도록 합니다. 이 새로운 <code>mcount</code>는 stack frame 구조를 파악해서 tracing을 수행해주는 유용한 기능을 가지고 있습니다. (마치 Java에서 특정 객체 대신 interface를 사용하여 코딩해두면 나중에 해당 코드가 실행될 때에는 텅 빈 interface 대신 실제 객체가 들어가는 것과 비슷하다고 보시면 되겠습니다.)</p>
<p>(제가 참고한 자료들을 보면 Multi core CPU에서 race condition 방지를 위한 방법까지 포함돼 있지만, 이는 생략하겠습니다.)</p>
<p>이렇게 함으로써 함수 호출을 트레이싱할 수 있게 되는 것입니다.</p>
<h3>Function Exit Tracing</h3>
<p>그런데 <code>ftrace</code>는 함수 호출 뿐만이 아니라 함수 리턴 역시 트레이싱할 수 있는 기능을 가지고 있습니다. <code>gcc</code>의 <code>-pg</code>옵션은 오직 함수 호출 부분에만 <code>mcount</code>를 삽입해주고, 함수 리턴 부분은 건드리지 않습니다. 그러면 함수 리턴은 어떻게 트레이싱이 가능한 걸까요?</p>
<p>이는 <code>ftrace</code>의 <code>mcount</code>에 의해 이루어집니다. 즉, 컴파일 타임이 아니라 런타임에 작동하는 것입니다. 이 부분은 설명이 좀 복잡하니 예시를 들면서 설명하겠습니다.</p>
<ul>
<li>먼저 어떤 커널 함수 <code>void someFunction()</code>이 <code>ftrace</code>에 의해 구현된 <code>mcount</code>를 호출한다고 가정합니다.</li>
<li>어느 시점에 <code>someFunction</code>이 호출되었는데, 호출된 후 리턴해야 할 주소를 <code>someFunction_ret</code>이라 가정합니다.</li>
<li><code>ftrace</code>에는 함수의 리턴을 트레이싱할 수 있는 특수한 함수가 있는데, 이를 <code>functionExitTracer</code>라 부르기로 합니다.</li>
</ul>
<p>그러면 함수가 호출될 때 다음 작업이 이루어집니다.</p>
<ol>
<li><code>someFunciton</code>의 stack frame이 구성됩니다.</li>
<li><code>someFunction</code> 위치로 점프합니다.</li>
<li><code>mcount</code>가 호출됩니다.</li>
<li><code>mcount</code>에서는 <code>someFunction</code>의 stack frame을 분석하여 그 리턴 주소인 <code>someFunction_ret</code>을 찾아내어 저장합니다.</li>
<li><code>mcount</code>에서는 <code>someFunction</code>의 stack frame에서 리턴 주소를 찾아낸 후, 그것을 <code>functionExitTracer</code>의 주소로 수정합니다. 즉, <code>someFunction</code>이 종료될 때에는 <code>someFunction_ret</code>으로 점프하는 것이 아니라 <code>functionExitTracer</code>로 점프하게 됩니다.</li>
<li><code>someFunction</code>이 종료되고 <code>functionExitTracer</code>로 점프합니다.</li>
<li><code>functionExitTracer</code>에서 함수 반환 트레이싱 작업을 수행합니다.</li>
<li><code>functionExitTracer</code>가 리턴될 때에는 앞서 4번 단계에서 저장해두었던 <code>someFunction_ret</code>으로 점프합니다.</li>
</ol>
<p>이러한 과정을 통하여 함수 반환을 트레이싱할 수 있게 되는 것입니다.</p>
<h1>trace-cmd</h1>
<p>이제 본격적으로 kernel tracing을 해 보도록 하겠습니다. <code>trace-cmd</code>는 <code>ftrace</code>를 좀 더 편리하게 사용할 수 있도록 만들어 둔 커맨드라인 유틸리티로 <code>sudo apt-get install trace-cmd</code> 커맨드를 통해 간단히 설치할 수 있습니다.</p>
<h2>사용법</h2>
<p><code>trace-cmd</code>는 크게 record, report라는 두 가지 단계를 통해 트레이싱을 수행합니다.</p>
<p>먼저 record 단계에서는 <code>ftrace</code>를 이용하여 트레이싱을 수행하고, 그 내용을 <code>trace.dat</code>이라는 파일에 저장합니다. 이 파일에는 <code>raw</code>데이터가 들어 있습니다. 아래와 같이 실행할 수 있습니다.</p>
<pre><code class="language-bash">trace-cmd record host google.com <span class="hljs-comment"># 특정 프로그램을 시작과 동시에 트레이싱</span>
trace-cmd record <span class="hljs-comment"># Ctrl+C를 누를 때까지 트레이싱</span>
</code></pre>
<p>다음으로 report 단계에서는 <code>trace.dat</code>파일을 읽어서 그 내용을 예쁘게 출력해줍니다. 아래와 같이 실행할 수 있습니다.</p>
<pre><code>trace-cmd report
</code></pre>
<p>물론 <code>trace-cmd</code>는 이 두 가지 말고도 다양한 모드를 지원합니다. <a href="https://man7.org/linux/man-pages/man1/trace-cmd.1.html">trace-cmd man page</a>를 읽어보시면 모든 기능이 상세히 설명되어 있습니다. 그리고 <code>trace-cmd</code>의 record 역시 다양한 옵션을 제공합니다. 이 옵션들 역시 <a href="https://man7.org/linux/man-pages/man1/trace-cmd-record.1.html">trace-cmd-record man page</a>를 읽어보시면 상세히 설명되어있습니다. 그래서 이 글에서는 몇 가지 유용한 옵션만을 설명하고자 합니다.</p>
<p><code>-p</code> : 어떤 트레이서를 사용할지 설정합니다. <code>function</code> 트레이서는 이 옵션을 주지 않을 때 선택되는 기본 트레이서로, 모든 function call을 트레이싱합니다. <code>function_graph</code>는 function call 및 function exit을 트레이싱하여 보여줍니다.</p>
<p><code>-F</code> : <code>trace-cmd</code>는 기본적으로 모든 CPU의 모든 프로세스를 트레이싱합니다. 그러므로 실제로 트레이싱된 결과를 보면 온갖 프로세스가 섞여있을 뿐만 아니라, 문맥 교환 관련 호출들도 다 트레이싱됩니다. 이는 문맥 교환 등을 고려할 때에는 좋은 방법이겠지만, 한 프로세스의 동작을 보기에는 적합하지 않습니다. <code>-F</code> 옵션을 주면 특정 프로그램을 인자로 줘서 트레이싱할 때, 오직 그 프로세스만을 트레이싱합니다. (아무 프로그램도 인자로 주지 않고 실행할 때에는 사용할 수 없습니다.)</p>
<p><code>-P</code> : <code>-F</code>와 유사한데, 인자로 주어진 프로그램이 아니라 특정 PID를 가진 프로세스를 트레이싱합니다. 이미 실행 중인 프로세스를 트레이싱하고 싶을 때 유용합니다.</p>
<p><code>-c</code> : 특정 프로세스를 트레이싱할 때 그 자식 프로세스까지 함께 트레이싱합니다. <code>-P</code>나 <code>-F</code> 옵션과 함께 사용할 수 있습니다.</p>
<h2>예시</h2>
<p><code>trace-cmd</code>를 사용하여 <code>host google.com</code> 를 실행하고, 트레이싱해보겠습니다.</p>
<pre><code>~$ sudo trace-cmd record -F -p function_graph host google.com
  plugin 'function_graph'
google.com has address 142.250.206.238
google.com has IPv6 address 2404:6800:400a:804::200e
google.com mail is handled by 40 alt3.aspmx.l.google.com.
google.com mail is handled by 20 alt1.aspmx.l.google.com.
google.com mail is handled by 30 alt2.aspmx.l.google.com.
google.com mail is handled by 50 alt4.aspmx.l.google.com.
google.com mail is handled by 10 aspmx.l.google.com.
CPU 1: 13674 events lost
CPU0 data recorded at offset=0x644000
    3977216 bytes in size
CPU1 data recorded at offset=0xa0f000
    6316032 bytes in size
</code></pre>
<p>이제 트레이싱 된 결과를 확인해보겠습니다. 그냥 <code>report</code>를 수행하면 내용이 너무 길어서 보기 힘들기 때문에, 결과를 파일에 쓰도록 하겠습니다.</p>
<pre><code>~$ sudo trace-cmd report &gt; trace.txt
~$ ls -al --block-size k
total 63316K
...
-rw-r--r-- 1 root       root       16468K May 29 10:20 trace.dat
-rw-rw-r-- 1 unknownpgr unknownpgr 22707K May 29 10:23 trace.txt
</code></pre>
<p>1.6M짜리 raw 파일과 2.2M짜리 report 파일을 얻었습니다. 이 파일을 살펴보면 프로그램이 커널 내에서 어떻게 동작하는지 알 수 있습니다. 예를 들어, 아래와 같은 소켓 생성 부분을 찾을 수 있었습니다.</p>
<pre><code>           |  do_syscall_64() {
           |    __x64_sys_socket() {
           |      __sys_socket() {
           |        __sock_create() {
           |          security_socket_create() {
           |            apparmor_socket_create() {
           |              _cond_resched() {
0.255 us   |                rcu_all_qs();
0.709 us   |              }
1.335 us   |            }
2.130 us   |          }
           |          sock_alloc() {
           |            new_inode_pseudo() {
           |              alloc_inode() {
           |                sock_alloc_inode() {
           |                  kmem_cache_alloc() {
           |                    _cond_resched() {
0.225 us   |                      rcu_all_qs();
0.712 us   |                    }
0.251 us   |                    should_failslab();
0.803 us   |                    memcg_kmem_get_cache();
0.348 us   |                    memcg_kmem_put_cache();
3.821 us   |                  }
0.240 us   |                  __init_waitqueue_head();
5.003 us   |                }
           |                inode_init_always() {
           |                  make_kuid() {
0.330 us   |                    map_id_range_down();
0.867 us   |                  }
           |                  make_kgid() {
0.236 us   |                    map_id_range_down();
0.686 us   |                  }
0.495 us   |                  security_inode_alloc();
0.240 us   |                  __init_rwsem();
4.147 us   |                }
10.211 us  |              }
0.248 us   |              _raw_spin_lock();
11.224 us  |            }
0.240 us   |            get_next_ino();
12.585 us  |          }
0.255 us   |          try_module_get();
           |          inet_create() {
           |            sk_alloc() {
           |              sk_prot_alloc() {
           |                kmem_cache_alloc() {
           |                  _cond_resched() {
0.225 us   |                    rcu_all_qs();
0.682 us   |                  }
0.225 us   |                  should_failslab();
0.870 us   |                  memcg_kmem_get_cache();
0.225 us   |                  memcg_kmem_put_cache();
3.476 us   |                }
0.225 us   |                page_poisoning_enabled();
           |                security_sk_alloc() {
           |                  __kmalloc() {
0.233 us   |                    kmalloc_slab();
           |                    _cond_resched() {
0.221 us   |                      rcu_all_qs();
0.743 us   |                    }
0.225 us   |                    should_failslab();
0.232 us   |                    memcg_kmem_put_cache();
3.454 us   |                  }
3.945 us   |                }
0.225 us   |                try_module_get();
9.709 us   |              }
0.225 us   |              __init_waitqueue_head();
0.237 us   |              mem_cgroup_sk_alloc();
0.240 us   |              cgroup_sk_alloc();
12.446 us  |            }
           |            sock_init_data() {
0.237 us   |              init_timer_key();
0.885 us   |            }
           |            tcp_v4_init_sock() {
           |              tcp_init_sock() {
           |                tcp_init_xmit_timers() {
           |                  inet_csk_init_xmit_timers() {
0.225 us   |                    init_timer_key();
0.248 us   |                    init_timer_key();
0.225 us   |                    init_timer_key();
1.639 us   |                  }
           |                  hrtimer_init() {
0.342 us   |                    __hrtimer_init();
0.810 us   |                  }
           |                  hrtimer_init() {
0.232 us   |                    __hrtimer_init();
0.686 us   |                  }
4.136 us   |                }
0.228 us   |                jiffies_to_usecs();
           |                tcp_assign_congestion_control() {
0.228 us   |                  try_module_get();
1.005 us   |                }
6.896 us   |              }
7.567 us   |            }
0.450 us   |            __cgroup_bpf_run_filter_sk();
23.693 us  |          }
0.252 us   |          try_module_get();
0.266 us   |          module_put();
           |          security_socket_post_create() {
0.566 us   |            apparmor_socket_post_create();
1.268 us   |          }
43.083 us  |        }
           |        get_unused_fd_flags() {
           |          __alloc_fd() {
0.372 us   |            _raw_spin_lock();
0.371 us   |            expand_files();
1.785 us   |          }
2.314 us   |        }
           |        sock_alloc_file() {
           |          alloc_file_pseudo() {
           |            d_alloc_pseudo() {
           |              __d_alloc() {
           |                kmem_cache_alloc() {
           |                  _cond_resched() {
0.229 us   |                    rcu_all_qs();
0.675 us   |                  }
0.221 us   |                  should_failslab();
0.742 us   |                  memcg_kmem_get_cache();
0.307 us   |                  memcg_kmem_put_cache();
3.341 us   |                }
0.394 us   |                d_set_d_op();
4.789 us   |              }
5.464 us   |            }
0.330 us   |            mntget();
           |            d_instantiate() {
0.341 us   |              security_d_instantiate();
0.251 us   |              _raw_spin_lock();
           |              __d_instantiate() {
0.330 us   |                d_flags_for_inode();
0.244 us   |                _raw_spin_lock();
1.357 us   |              }
3.018 us   |            }
           |            alloc_file() {
           |              alloc_empty_file() {
           |                __alloc_file() {
           |                  kmem_cache_alloc() {
           |                    _cond_resched() {
0.236 us   |                      rcu_all_qs();
1.174 us   |                    }
0.221 us   |                    should_failslab();
0.799 us   |                    memcg_kmem_get_cache();
0.225 us   |                    memcg_kmem_put_cache();
3.870 us   |                  }
           |                  security_file_alloc() {
           |                    kmem_cache_alloc() {
           |                      _cond_resched() {
0.225 us   |                        rcu_all_qs();
0.660 us   |                      }
0.217 us   |                      should_failslab();
0.319 us   |                      memcg_kmem_put_cache();
2.423 us   |                    }
           |                    apparmor_file_alloc_security() {
           |                      _cond_resched() {
0.225 us   |                        rcu_all_qs();
0.690 us   |                      }
1.173 us   |                    }
4.388 us   |                  }
0.222 us   |                  __mutex_init();
9.401 us   |                }
10.335 us  |              }
11.119 us  |            }
21.465 us  |          }
22.151 us  |        }
           |        fd_install() {
0.293 us   |          __fd_install();
0.727 us   |        }
69.727 us  |      }
70.260 us  |    }
0.229 us   |    fpregs_assert_state_consistent();
71.509 us  |  }
</code></pre>
<h1>결론</h1>
<p>이 포스팅에서는 리눅스 커널 트레이싱 도구인 <code>trace-cmd</code>의 작동 원리를 살펴보고, 커맨드라인 유틸리티인 <code>trace-cmd</code>를 통해 실제로 프로세스의 커널 트레이싱을 수행해봤습니다. 재밌네요. 오늘도 리눅스 커널에 대한 이해가 깊어졌습니다. ㅎㅎ</p>
<p>다음에는 이를 이용하여 저번에 작성했던 <a href="/posts/internal-steps">웹브라우저에서 검색할 때 어떤 일이 벌어지나?</a> 글을 좀 더 자세하게 업데이트해볼까 합니다.</p>
<h2>TMI</h2>
<p>자료조사 하다 보니 폭발해버린 탭들....</p>
<p><img src="/imgs/42706f6947759e028597d926397736b9.png" alt="image-20210529195650458"></p>
</main><h1>Posts in <!-- -->computer structure<!-- --> category</h1><ul><li class="post_list__OlrZL"><a href="/posts/2021-06-18-ip-assign/">공인 IP 주소는 어떻게 할당되는가?</a></li><li class="post_listSelected__vtK9Y"><a href="/posts/2021-05-29-kernel-trace/">trace-cmd 및 ftrace 이해하기</a></li><li class="post_list__OlrZL"><a href="/posts/2021-05-27-timer/">ARM 타이머 이해하기</a></li><li class="post_list__OlrZL"><a href="/posts/2020-12-25-internal-steps/">웹브라우저에서 검색할 때 어떤 일이 벌어지나?</a></li></ul><div></div></div></main><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5695206410217978" data-ad-slot="9579212903" data-ad-format="auto" data-full-width-responsive="true"></ins><footer class="footer_footer__E_Uzl">© 2020 Copyright : Unknownpgr</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"trace-cmd 및 ftrace 이해하기","category":"computer structure","date":"2021-05-29T10:56:39.790Z","postStr":"---\ntitle: trace-cmd 및 ftrace 이해하기\ncategory: computer structure\ndate: 2021-05-29T10:56:39.790Z\n\n---\n\n이 글에서는 `ftrace` 및 `ftrace`의 커맨드라인 유틸리티인 `trace-cmd`의 동작 원리를 이해하고, 이를 사용하여 리눅스 커널 트레이싱을 해 보고자 합니다.\n\n![Commands To Check Bad Sectors On Hard Disk In Linux | Itsubuntu.com](imgs/Free_Linux_Tutorials.png)\n\n# ftrace 이해하기\n\n## ftrace란?\n\n`ftrace` 란 linux에서 제공하는 일종의 프레임워크입니다. `ftrace`는 `strace` 등과 다르게 하나의 프로그램이 아니고 리눅스에서 제공하는 기능의 일종이라서, 안타깝게도 `ftrace ping 8.8.8.8` 과 같은 느낌으로 간단하게 사용할 수는 없습니다.\n\n`ftrace`는 `/sys/kernel/debug/tracing` 디렉토리에 있는 파일시스템에 접근하여 읽거나 쓰는 방식으로 작동합니다. 예를 들어서, 아래와 같이 `do_page_fault` 함수 호출을 tracing할 수 있습니다.\n\n```bash\ncd /sys/kernel/debug/tracing\necho function \u003e current_tracer\necho do_page_fault \u003e set_ftrace_filter\ncat trace\n```\n\n위 코드를 보면, 먼저 `tracer`를 `function`으로 설정하고 있습니다. `tracer`란 트레이싱을 실제로 수행하는 플러그인을 말하는데, `function`으로 설정하면 모든 function call을 수집하고, `event`로 설정하면 모든 이벤트를 수집하는 방식입니다. 그 다음 줄의 `set_trace_filter`는 그 이름에서 알 수 있듯, 트레이싱되는 것들 중 일부만을 선택하겠다는 의미입니다. 이 경우에는 `do_page_fault` 함수만을 수집했습니다. 마지막으로 `trace` 파일을 읽음으로써 실제 트레이싱을 수행합니다. 아래는 `ftrace`의 사용 예시입니다. ([출처](https://lwn.net/Articles/365835/))\n\n```\n    [tracing]# echo function \u003e current_tracer\n    [tracing]# cat current_tracer\n    function\n\n    [tracing]# cat trace | head -10\n    # tracer: function\n    #\n    #           TASK-PID    CPU#    TIMESTAMP  FUNCTION\n    #              | |       |          |         |\n                bash-16939 [000]  6075.461561: mutex_unlock \u003c-tracing_set_tracer\n              \u003cidle\u003e-0     [001]  6075.461561: _spin_unlock_irqrestore \u003c-hrtimer_get_next_event\n              \u003cidle\u003e-0     [001]  6075.461562: rcu_needs_cpu \u003c-tick_nohz_stop_sched_tick\n                bash-16939 [000]  6075.461563: inotify_inode_queue_event \u003c-vfs_write\n              \u003cidle\u003e-0     [001]  6075.461563: mwait_idle \u003c-cpu_idle\n                bash-16939 [000]  6075.461563: __fsnotify_parent \u003c-vfs_write\n```\n\n## ftrace의 동작 원리\n\n이 `ftrace`는 그러면 어떻게 동작하는 걸까요? 유저 스페이스에서 동작하는 프로그램을 디버깅하는 것도 쉽지 않은데 커널에서 수행되는 작업들을, 그것도 여러 cpu에서 수행되는 작업들을 전부 수집하기란 쉽지 않아 보입니다. (사실 저는 `ftrace`에 대해 알기 전까지는 이런 작업이 가능하다는 것 자체를 몰랐습니다.) 심지어 `ftrace`를 사용한다고 해서 프로세스의 실행 속도가 엄청나게 느려지거나 하지도 않습니다. (물론 어느 정도 느려지기는 합니다만, 약 20~30%정도밖에 느려지지 않는다고 합니다.)\n\n[위키백과](https://en.wikipedia.org/wiki/Ftrace#cite_note-9)와 여러 인터넷 자료들을 찾아 본 결과([자료 1](https://jvns.ca/blog/2017/03/19/getting-started-with-ftrace/), [자료 2](https://elinux.org/images/d/d6/Measuring-function-duration-with-ftrace.pdf), [자료 3](https://www.kernel.org/doc/Documentation/trace/ftrace.txt)), 자세하지는 않지만 대강의 작동 원리를 파악할 수 있었습니다.\n\n### Function Entry Tracing\n\n먼저 function entry tracing의 경우 애초에 커널이 컴파일될 때 특수한 instruction이 삽입됩니다. 구체적으로는 커널을 컴파일할 때 `gcc`에서 `-pg` 옵션을 주면 함수가 호출될 때 `mcount`라는 함수를 호출하는 instruction을 삽입합니다. 구체적으로는 아래와 같습니다.\n\n```asm\nmov ip, lr\nbl 0 \u003cmcount\u003e\nandeq r0, r0, r8, lsr #32\n```\n\n이 `mcount`라는 함수는 실제로 사용되는 함수는 아니며, 나중에 다른 함수로 대체될, 아무것도 하지 않는 function stub입니다.\n\n이렇게 컴파일이 끝난 후, `recordmcount`라는 프로그램이 실행됩니다. 이 프로그램은 C 오브젝트의 ELF header를 파싱하여 `.text` 섹션(실제로 코드가 저장되는 섹션)에서 `mcount`함수를 호출하는 위치를 전부 찾아냅니다. 그리고 `__mcount_loc`이라는 섹션을 생성하여 이 섹션에 `mcount` 함수를 호출하는 위치를 전부 기록하고, 이것을 다시 원래 오브젝트에 링크합니다.\n\n이후 커널이 부팅될 때, SMP가 초기화되기 전에 `ftrace`에 의해 이 부분이 전부 `NOP` (아무것도 하지 않는 instruction)으로 바뀝니다. 모듈의 경우에는 모듈이 로드되기 전에 이 과정이 수행됩니다. `ftrace`에는 트레이싱이 가능한 함수들의 목록이 저장되는 `available_filter_functions` 리스트가 있는데, 모듈의 경우에는 추가적으로 이 리스트에 모듈의 함수들이 등록됩니다. 물론 모듈이 unload될 때에는 이 리스트에서 모듈에 포함된 함수들을 삭제합니다.\n\n부팅이 끝난 후 나중에 `ftrace`가 enable 되면 앞서 `NOP`으로 대체했던 instruction들을 다시 원래대로 돌리는 작업이 수행됩니다. 구체적으로는 다시 원래의 `mcount`를 호출하는 instruction들을 복구하되, 이번에는 기존의 function stub인 `mcount`를 호출하는 대신 `ftrace`에 구현되어있는 새로운 `mcount`를 호출하도록 합니다. 이 새로운 `mcount`는 stack frame 구조를 파악해서 tracing을 수행해주는 유용한 기능을 가지고 있습니다. (마치 Java에서 특정 객체 대신 interface를 사용하여 코딩해두면 나중에 해당 코드가 실행될 때에는 텅 빈 interface 대신 실제 객체가 들어가는 것과 비슷하다고 보시면 되겠습니다.)\n\n(제가 참고한 자료들을 보면 Multi core CPU에서 race condition 방지를 위한 방법까지 포함돼 있지만, 이는 생략하겠습니다.)\n\n이렇게 함으로써 함수 호출을 트레이싱할 수 있게 되는 것입니다.\n\n### Function Exit Tracing\n\n그런데 `ftrace`는 함수 호출 뿐만이 아니라 함수 리턴 역시 트레이싱할 수 있는 기능을 가지고 있습니다. `gcc`의 `-pg`옵션은 오직 함수 호출 부분에만 `mcount`를 삽입해주고, 함수 리턴 부분은 건드리지 않습니다. 그러면 함수 리턴은 어떻게 트레이싱이 가능한 걸까요?\n\n이는 `ftrace`의 `mcount`에 의해 이루어집니다. 즉, 컴파일 타임이 아니라 런타임에 작동하는 것입니다. 이 부분은 설명이 좀 복잡하니 예시를 들면서 설명하겠습니다.\n\n- 먼저 어떤 커널 함수 `void someFunction()`이 `ftrace`에 의해 구현된 `mcount`를 호출한다고 가정합니다.\n- 어느 시점에 `someFunction`이 호출되었는데, 호출된 후 리턴해야 할 주소를 `someFunction_ret`이라 가정합니다.\n- `ftrace`에는 함수의 리턴을 트레이싱할 수 있는 특수한 함수가 있는데, 이를 `functionExitTracer`라 부르기로 합니다.\n\n그러면 함수가 호출될 때 다음 작업이 이루어집니다.\n\n1. `someFunciton`의 stack frame이 구성됩니다.\n2. `someFunction` 위치로 점프합니다.\n3. `mcount`가 호출됩니다.\n4. `mcount`에서는 `someFunction`의 stack frame을 분석하여 그 리턴 주소인 `someFunction_ret`을 찾아내어 저장합니다.\n5. `mcount`에서는 `someFunction`의 stack frame에서 리턴 주소를 찾아낸 후, 그것을 `functionExitTracer`의 주소로 수정합니다. 즉, `someFunction`이 종료될 때에는 `someFunction_ret`으로 점프하는 것이 아니라 `functionExitTracer`로 점프하게 됩니다.\n6. `someFunction`이 종료되고 `functionExitTracer`로 점프합니다.\n7. `functionExitTracer`에서 함수 반환 트레이싱 작업을 수행합니다.\n8. `functionExitTracer`가 리턴될 때에는 앞서 4번 단계에서 저장해두었던 `someFunction_ret`으로 점프합니다.\n\n이러한 과정을 통하여 함수 반환을 트레이싱할 수 있게 되는 것입니다.\n\n# trace-cmd\n\n이제 본격적으로 kernel tracing을 해 보도록 하겠습니다. `trace-cmd`는 `ftrace`를 좀 더 편리하게 사용할 수 있도록 만들어 둔 커맨드라인 유틸리티로 `sudo apt-get install trace-cmd` 커맨드를 통해 간단히 설치할 수 있습니다.\n\n## 사용법\n\n`trace-cmd`는 크게 record, report라는 두 가지 단계를 통해 트레이싱을 수행합니다.\n\n먼저 record 단계에서는 `ftrace`를 이용하여 트레이싱을 수행하고, 그 내용을 `trace.dat`이라는 파일에 저장합니다. 이 파일에는 `raw`데이터가 들어 있습니다. 아래와 같이 실행할 수 있습니다.\n\n```bash\ntrace-cmd record host google.com # 특정 프로그램을 시작과 동시에 트레이싱\ntrace-cmd record # Ctrl+C를 누를 때까지 트레이싱\n```\n\n다음으로 report 단계에서는 `trace.dat`파일을 읽어서 그 내용을 예쁘게 출력해줍니다. 아래와 같이 실행할 수 있습니다.\n\n```\ntrace-cmd report\n```\n\n물론 `trace-cmd`는 이 두 가지 말고도 다양한 모드를 지원합니다. [trace-cmd man page](https://man7.org/linux/man-pages/man1/trace-cmd.1.html)를 읽어보시면 모든 기능이 상세히 설명되어 있습니다. 그리고 `trace-cmd`의 record 역시 다양한 옵션을 제공합니다. 이 옵션들 역시 [trace-cmd-record man page](https://man7.org/linux/man-pages/man1/trace-cmd-record.1.html)를 읽어보시면 상세히 설명되어있습니다. 그래서 이 글에서는 몇 가지 유용한 옵션만을 설명하고자 합니다.\n\n`-p` : 어떤 트레이서를 사용할지 설정합니다. `function` 트레이서는 이 옵션을 주지 않을 때 선택되는 기본 트레이서로, 모든 function call을 트레이싱합니다. `function_graph`는 function call 및 function exit을 트레이싱하여 보여줍니다.\n\n`-F` : `trace-cmd`는 기본적으로 모든 CPU의 모든 프로세스를 트레이싱합니다. 그러므로 실제로 트레이싱된 결과를 보면 온갖 프로세스가 섞여있을 뿐만 아니라, 문맥 교환 관련 호출들도 다 트레이싱됩니다. 이는 문맥 교환 등을 고려할 때에는 좋은 방법이겠지만, 한 프로세스의 동작을 보기에는 적합하지 않습니다. `-F` 옵션을 주면 특정 프로그램을 인자로 줘서 트레이싱할 때, 오직 그 프로세스만을 트레이싱합니다. (아무 프로그램도 인자로 주지 않고 실행할 때에는 사용할 수 없습니다.)\n\n`-P` : `-F`와 유사한데, 인자로 주어진 프로그램이 아니라 특정 PID를 가진 프로세스를 트레이싱합니다. 이미 실행 중인 프로세스를 트레이싱하고 싶을 때 유용합니다.\n\n`-c` : 특정 프로세스를 트레이싱할 때 그 자식 프로세스까지 함께 트레이싱합니다. `-P`나 `-F` 옵션과 함께 사용할 수 있습니다.\n\n## 예시\n\n`trace-cmd`를 사용하여 `host google.com` 를 실행하고, 트레이싱해보겠습니다.\n\n```\n~$ sudo trace-cmd record -F -p function_graph host google.com\n  plugin 'function_graph'\ngoogle.com has address 142.250.206.238\ngoogle.com has IPv6 address 2404:6800:400a:804::200e\ngoogle.com mail is handled by 40 alt3.aspmx.l.google.com.\ngoogle.com mail is handled by 20 alt1.aspmx.l.google.com.\ngoogle.com mail is handled by 30 alt2.aspmx.l.google.com.\ngoogle.com mail is handled by 50 alt4.aspmx.l.google.com.\ngoogle.com mail is handled by 10 aspmx.l.google.com.\nCPU 1: 13674 events lost\nCPU0 data recorded at offset=0x644000\n    3977216 bytes in size\nCPU1 data recorded at offset=0xa0f000\n    6316032 bytes in size\n```\n\n이제 트레이싱 된 결과를 확인해보겠습니다. 그냥 `report`를 수행하면 내용이 너무 길어서 보기 힘들기 때문에, 결과를 파일에 쓰도록 하겠습니다.\n\n```\n~$ sudo trace-cmd report \u003e trace.txt\n~$ ls -al --block-size k\ntotal 63316K\n...\n-rw-r--r-- 1 root       root       16468K May 29 10:20 trace.dat\n-rw-rw-r-- 1 unknownpgr unknownpgr 22707K May 29 10:23 trace.txt\n```\n\n1.6M짜리 raw 파일과 2.2M짜리 report 파일을 얻었습니다. 이 파일을 살펴보면 프로그램이 커널 내에서 어떻게 동작하는지 알 수 있습니다. 예를 들어, 아래와 같은 소켓 생성 부분을 찾을 수 있었습니다.\n\n```\n           |  do_syscall_64() {\n           |    __x64_sys_socket() {\n           |      __sys_socket() {\n           |        __sock_create() {\n           |          security_socket_create() {\n           |            apparmor_socket_create() {\n           |              _cond_resched() {\n0.255 us   |                rcu_all_qs();\n0.709 us   |              }\n1.335 us   |            }\n2.130 us   |          }\n           |          sock_alloc() {\n           |            new_inode_pseudo() {\n           |              alloc_inode() {\n           |                sock_alloc_inode() {\n           |                  kmem_cache_alloc() {\n           |                    _cond_resched() {\n0.225 us   |                      rcu_all_qs();\n0.712 us   |                    }\n0.251 us   |                    should_failslab();\n0.803 us   |                    memcg_kmem_get_cache();\n0.348 us   |                    memcg_kmem_put_cache();\n3.821 us   |                  }\n0.240 us   |                  __init_waitqueue_head();\n5.003 us   |                }\n           |                inode_init_always() {\n           |                  make_kuid() {\n0.330 us   |                    map_id_range_down();\n0.867 us   |                  }\n           |                  make_kgid() {\n0.236 us   |                    map_id_range_down();\n0.686 us   |                  }\n0.495 us   |                  security_inode_alloc();\n0.240 us   |                  __init_rwsem();\n4.147 us   |                }\n10.211 us  |              }\n0.248 us   |              _raw_spin_lock();\n11.224 us  |            }\n0.240 us   |            get_next_ino();\n12.585 us  |          }\n0.255 us   |          try_module_get();\n           |          inet_create() {\n           |            sk_alloc() {\n           |              sk_prot_alloc() {\n           |                kmem_cache_alloc() {\n           |                  _cond_resched() {\n0.225 us   |                    rcu_all_qs();\n0.682 us   |                  }\n0.225 us   |                  should_failslab();\n0.870 us   |                  memcg_kmem_get_cache();\n0.225 us   |                  memcg_kmem_put_cache();\n3.476 us   |                }\n0.225 us   |                page_poisoning_enabled();\n           |                security_sk_alloc() {\n           |                  __kmalloc() {\n0.233 us   |                    kmalloc_slab();\n           |                    _cond_resched() {\n0.221 us   |                      rcu_all_qs();\n0.743 us   |                    }\n0.225 us   |                    should_failslab();\n0.232 us   |                    memcg_kmem_put_cache();\n3.454 us   |                  }\n3.945 us   |                }\n0.225 us   |                try_module_get();\n9.709 us   |              }\n0.225 us   |              __init_waitqueue_head();\n0.237 us   |              mem_cgroup_sk_alloc();\n0.240 us   |              cgroup_sk_alloc();\n12.446 us  |            }\n           |            sock_init_data() {\n0.237 us   |              init_timer_key();\n0.885 us   |            }\n           |            tcp_v4_init_sock() {\n           |              tcp_init_sock() {\n           |                tcp_init_xmit_timers() {\n           |                  inet_csk_init_xmit_timers() {\n0.225 us   |                    init_timer_key();\n0.248 us   |                    init_timer_key();\n0.225 us   |                    init_timer_key();\n1.639 us   |                  }\n           |                  hrtimer_init() {\n0.342 us   |                    __hrtimer_init();\n0.810 us   |                  }\n           |                  hrtimer_init() {\n0.232 us   |                    __hrtimer_init();\n0.686 us   |                  }\n4.136 us   |                }\n0.228 us   |                jiffies_to_usecs();\n           |                tcp_assign_congestion_control() {\n0.228 us   |                  try_module_get();\n1.005 us   |                }\n6.896 us   |              }\n7.567 us   |            }\n0.450 us   |            __cgroup_bpf_run_filter_sk();\n23.693 us  |          }\n0.252 us   |          try_module_get();\n0.266 us   |          module_put();\n           |          security_socket_post_create() {\n0.566 us   |            apparmor_socket_post_create();\n1.268 us   |          }\n43.083 us  |        }\n           |        get_unused_fd_flags() {\n           |          __alloc_fd() {\n0.372 us   |            _raw_spin_lock();\n0.371 us   |            expand_files();\n1.785 us   |          }\n2.314 us   |        }\n           |        sock_alloc_file() {\n           |          alloc_file_pseudo() {\n           |            d_alloc_pseudo() {\n           |              __d_alloc() {\n           |                kmem_cache_alloc() {\n           |                  _cond_resched() {\n0.229 us   |                    rcu_all_qs();\n0.675 us   |                  }\n0.221 us   |                  should_failslab();\n0.742 us   |                  memcg_kmem_get_cache();\n0.307 us   |                  memcg_kmem_put_cache();\n3.341 us   |                }\n0.394 us   |                d_set_d_op();\n4.789 us   |              }\n5.464 us   |            }\n0.330 us   |            mntget();\n           |            d_instantiate() {\n0.341 us   |              security_d_instantiate();\n0.251 us   |              _raw_spin_lock();\n           |              __d_instantiate() {\n0.330 us   |                d_flags_for_inode();\n0.244 us   |                _raw_spin_lock();\n1.357 us   |              }\n3.018 us   |            }\n           |            alloc_file() {\n           |              alloc_empty_file() {\n           |                __alloc_file() {\n           |                  kmem_cache_alloc() {\n           |                    _cond_resched() {\n0.236 us   |                      rcu_all_qs();\n1.174 us   |                    }\n0.221 us   |                    should_failslab();\n0.799 us   |                    memcg_kmem_get_cache();\n0.225 us   |                    memcg_kmem_put_cache();\n3.870 us   |                  }\n           |                  security_file_alloc() {\n           |                    kmem_cache_alloc() {\n           |                      _cond_resched() {\n0.225 us   |                        rcu_all_qs();\n0.660 us   |                      }\n0.217 us   |                      should_failslab();\n0.319 us   |                      memcg_kmem_put_cache();\n2.423 us   |                    }\n           |                    apparmor_file_alloc_security() {\n           |                      _cond_resched() {\n0.225 us   |                        rcu_all_qs();\n0.690 us   |                      }\n1.173 us   |                    }\n4.388 us   |                  }\n0.222 us   |                  __mutex_init();\n9.401 us   |                }\n10.335 us  |              }\n11.119 us  |            }\n21.465 us  |          }\n22.151 us  |        }\n           |        fd_install() {\n0.293 us   |          __fd_install();\n0.727 us   |        }\n69.727 us  |      }\n70.260 us  |    }\n0.229 us   |    fpregs_assert_state_consistent();\n71.509 us  |  }\n```\n\n# 결론\n\n이 포스팅에서는 리눅스 커널 트레이싱 도구인 `trace-cmd`의 작동 원리를 살펴보고, 커맨드라인 유틸리티인 `trace-cmd`를 통해 실제로 프로세스의 커널 트레이싱을 수행해봤습니다. 재밌네요. 오늘도 리눅스 커널에 대한 이해가 깊어졌습니다. ㅎㅎ\n\n다음에는 이를 이용하여 저번에 작성했던 [웹브라우저에서 검색할 때 어떤 일이 벌어지나?](/posts/internal-steps) 글을 좀 더 자세하게 업데이트해볼까 합니다.\n\n## TMI\n\n자료조사 하다 보니 폭발해버린 탭들....\n\n![image-20210529195650458](imgs/image-20210529195650458.png)","html":"\u003cp\u003e이 글에서는 \u003ccode\u003eftrace\u003c/code\u003e 및 \u003ccode\u003eftrace\u003c/code\u003e의 커맨드라인 유틸리티인 \u003ccode\u003etrace-cmd\u003c/code\u003e의 동작 원리를 이해하고, 이를 사용하여 리눅스 커널 트레이싱을 해 보고자 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/dc98064e8bc40d83d91362d4ce1dd9d3.png\" alt=\"Commands To Check Bad Sectors On Hard Disk In Linux | Itsubuntu.com\"\u003e\u003c/p\u003e\n\u003ch1\u003eftrace 이해하기\u003c/h1\u003e\n\u003ch2\u003eftrace란?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eftrace\u003c/code\u003e 란 linux에서 제공하는 일종의 프레임워크입니다. \u003ccode\u003eftrace\u003c/code\u003e는 \u003ccode\u003estrace\u003c/code\u003e 등과 다르게 하나의 프로그램이 아니고 리눅스에서 제공하는 기능의 일종이라서, 안타깝게도 \u003ccode\u003eftrace ping 8.8.8.8\u003c/code\u003e 과 같은 느낌으로 간단하게 사용할 수는 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eftrace\u003c/code\u003e는 \u003ccode\u003e/sys/kernel/debug/tracing\u003c/code\u003e 디렉토리에 있는 파일시스템에 접근하여 읽거나 쓰는 방식으로 작동합니다. 예를 들어서, 아래와 같이 \u003ccode\u003edo_page_fault\u003c/code\u003e 함수 호출을 tracing할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecd\u003c/span\u003e /sys/kernel/debug/tracing\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u0026gt; current_tracer\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e do_page_fault \u0026gt; set_ftrace_filter\n\u003cspan class=\"hljs-built_in\"\u003ecat\u003c/span\u003e trace\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드를 보면, 먼저 \u003ccode\u003etracer\u003c/code\u003e를 \u003ccode\u003efunction\u003c/code\u003e으로 설정하고 있습니다. \u003ccode\u003etracer\u003c/code\u003e란 트레이싱을 실제로 수행하는 플러그인을 말하는데, \u003ccode\u003efunction\u003c/code\u003e으로 설정하면 모든 function call을 수집하고, \u003ccode\u003eevent\u003c/code\u003e로 설정하면 모든 이벤트를 수집하는 방식입니다. 그 다음 줄의 \u003ccode\u003eset_trace_filter\u003c/code\u003e는 그 이름에서 알 수 있듯, 트레이싱되는 것들 중 일부만을 선택하겠다는 의미입니다. 이 경우에는 \u003ccode\u003edo_page_fault\u003c/code\u003e 함수만을 수집했습니다. 마지막으로 \u003ccode\u003etrace\u003c/code\u003e 파일을 읽음으로써 실제 트레이싱을 수행합니다. 아래는 \u003ccode\u003eftrace\u003c/code\u003e의 사용 예시입니다. (\u003ca href=\"https://lwn.net/Articles/365835/\"\u003e출처\u003c/a\u003e)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    [tracing]# echo function \u0026gt; current_tracer\n    [tracing]# cat current_tracer\n    function\n\n    [tracing]# cat trace | head -10\n    # tracer: function\n    #\n    #           TASK-PID    CPU#    TIMESTAMP  FUNCTION\n    #              | |       |          |         |\n                bash-16939 [000]  6075.461561: mutex_unlock \u0026lt;-tracing_set_tracer\n              \u0026lt;idle\u0026gt;-0     [001]  6075.461561: _spin_unlock_irqrestore \u0026lt;-hrtimer_get_next_event\n              \u0026lt;idle\u0026gt;-0     [001]  6075.461562: rcu_needs_cpu \u0026lt;-tick_nohz_stop_sched_tick\n                bash-16939 [000]  6075.461563: inotify_inode_queue_event \u0026lt;-vfs_write\n              \u0026lt;idle\u0026gt;-0     [001]  6075.461563: mwait_idle \u0026lt;-cpu_idle\n                bash-16939 [000]  6075.461563: __fsnotify_parent \u0026lt;-vfs_write\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eftrace의 동작 원리\u003c/h2\u003e\n\u003cp\u003e이 \u003ccode\u003eftrace\u003c/code\u003e는 그러면 어떻게 동작하는 걸까요? 유저 스페이스에서 동작하는 프로그램을 디버깅하는 것도 쉽지 않은데 커널에서 수행되는 작업들을, 그것도 여러 cpu에서 수행되는 작업들을 전부 수집하기란 쉽지 않아 보입니다. (사실 저는 \u003ccode\u003eftrace\u003c/code\u003e에 대해 알기 전까지는 이런 작업이 가능하다는 것 자체를 몰랐습니다.) 심지어 \u003ccode\u003eftrace\u003c/code\u003e를 사용한다고 해서 프로세스의 실행 속도가 엄청나게 느려지거나 하지도 않습니다. (물론 어느 정도 느려지기는 합니다만, 약 20~30%정도밖에 느려지지 않는다고 합니다.)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Ftrace#cite_note-9\"\u003e위키백과\u003c/a\u003e와 여러 인터넷 자료들을 찾아 본 결과(\u003ca href=\"https://jvns.ca/blog/2017/03/19/getting-started-with-ftrace/\"\u003e자료 1\u003c/a\u003e, \u003ca href=\"https://elinux.org/images/d/d6/Measuring-function-duration-with-ftrace.pdf\"\u003e자료 2\u003c/a\u003e, \u003ca href=\"https://www.kernel.org/doc/Documentation/trace/ftrace.txt\"\u003e자료 3\u003c/a\u003e), 자세하지는 않지만 대강의 작동 원리를 파악할 수 있었습니다.\u003c/p\u003e\n\u003ch3\u003eFunction Entry Tracing\u003c/h3\u003e\n\u003cp\u003e먼저 function entry tracing의 경우 애초에 커널이 컴파일될 때 특수한 instruction이 삽입됩니다. 구체적으로는 커널을 컴파일할 때 \u003ccode\u003egcc\u003c/code\u003e에서 \u003ccode\u003e-pg\u003c/code\u003e 옵션을 주면 함수가 호출될 때 \u003ccode\u003emcount\u003c/code\u003e라는 함수를 호출하는 instruction을 삽입합니다. 구체적으로는 아래와 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003emov ip, lr\nbl 0 \u0026lt;mcount\u0026gt;\nandeq r0, r0, r8, lsr #32\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 \u003ccode\u003emcount\u003c/code\u003e라는 함수는 실제로 사용되는 함수는 아니며, 나중에 다른 함수로 대체될, 아무것도 하지 않는 function stub입니다.\u003c/p\u003e\n\u003cp\u003e이렇게 컴파일이 끝난 후, \u003ccode\u003erecordmcount\u003c/code\u003e라는 프로그램이 실행됩니다. 이 프로그램은 C 오브젝트의 ELF header를 파싱하여 \u003ccode\u003e.text\u003c/code\u003e 섹션(실제로 코드가 저장되는 섹션)에서 \u003ccode\u003emcount\u003c/code\u003e함수를 호출하는 위치를 전부 찾아냅니다. 그리고 \u003ccode\u003e__mcount_loc\u003c/code\u003e이라는 섹션을 생성하여 이 섹션에 \u003ccode\u003emcount\u003c/code\u003e 함수를 호출하는 위치를 전부 기록하고, 이것을 다시 원래 오브젝트에 링크합니다.\u003c/p\u003e\n\u003cp\u003e이후 커널이 부팅될 때, SMP가 초기화되기 전에 \u003ccode\u003eftrace\u003c/code\u003e에 의해 이 부분이 전부 \u003ccode\u003eNOP\u003c/code\u003e (아무것도 하지 않는 instruction)으로 바뀝니다. 모듈의 경우에는 모듈이 로드되기 전에 이 과정이 수행됩니다. \u003ccode\u003eftrace\u003c/code\u003e에는 트레이싱이 가능한 함수들의 목록이 저장되는 \u003ccode\u003eavailable_filter_functions\u003c/code\u003e 리스트가 있는데, 모듈의 경우에는 추가적으로 이 리스트에 모듈의 함수들이 등록됩니다. 물론 모듈이 unload될 때에는 이 리스트에서 모듈에 포함된 함수들을 삭제합니다.\u003c/p\u003e\n\u003cp\u003e부팅이 끝난 후 나중에 \u003ccode\u003eftrace\u003c/code\u003e가 enable 되면 앞서 \u003ccode\u003eNOP\u003c/code\u003e으로 대체했던 instruction들을 다시 원래대로 돌리는 작업이 수행됩니다. 구체적으로는 다시 원래의 \u003ccode\u003emcount\u003c/code\u003e를 호출하는 instruction들을 복구하되, 이번에는 기존의 function stub인 \u003ccode\u003emcount\u003c/code\u003e를 호출하는 대신 \u003ccode\u003eftrace\u003c/code\u003e에 구현되어있는 새로운 \u003ccode\u003emcount\u003c/code\u003e를 호출하도록 합니다. 이 새로운 \u003ccode\u003emcount\u003c/code\u003e는 stack frame 구조를 파악해서 tracing을 수행해주는 유용한 기능을 가지고 있습니다. (마치 Java에서 특정 객체 대신 interface를 사용하여 코딩해두면 나중에 해당 코드가 실행될 때에는 텅 빈 interface 대신 실제 객체가 들어가는 것과 비슷하다고 보시면 되겠습니다.)\u003c/p\u003e\n\u003cp\u003e(제가 참고한 자료들을 보면 Multi core CPU에서 race condition 방지를 위한 방법까지 포함돼 있지만, 이는 생략하겠습니다.)\u003c/p\u003e\n\u003cp\u003e이렇게 함으로써 함수 호출을 트레이싱할 수 있게 되는 것입니다.\u003c/p\u003e\n\u003ch3\u003eFunction Exit Tracing\u003c/h3\u003e\n\u003cp\u003e그런데 \u003ccode\u003eftrace\u003c/code\u003e는 함수 호출 뿐만이 아니라 함수 리턴 역시 트레이싱할 수 있는 기능을 가지고 있습니다. \u003ccode\u003egcc\u003c/code\u003e의 \u003ccode\u003e-pg\u003c/code\u003e옵션은 오직 함수 호출 부분에만 \u003ccode\u003emcount\u003c/code\u003e를 삽입해주고, 함수 리턴 부분은 건드리지 않습니다. 그러면 함수 리턴은 어떻게 트레이싱이 가능한 걸까요?\u003c/p\u003e\n\u003cp\u003e이는 \u003ccode\u003eftrace\u003c/code\u003e의 \u003ccode\u003emcount\u003c/code\u003e에 의해 이루어집니다. 즉, 컴파일 타임이 아니라 런타임에 작동하는 것입니다. 이 부분은 설명이 좀 복잡하니 예시를 들면서 설명하겠습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e먼저 어떤 커널 함수 \u003ccode\u003evoid someFunction()\u003c/code\u003e이 \u003ccode\u003eftrace\u003c/code\u003e에 의해 구현된 \u003ccode\u003emcount\u003c/code\u003e를 호출한다고 가정합니다.\u003c/li\u003e\n\u003cli\u003e어느 시점에 \u003ccode\u003esomeFunction\u003c/code\u003e이 호출되었는데, 호출된 후 리턴해야 할 주소를 \u003ccode\u003esomeFunction_ret\u003c/code\u003e이라 가정합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eftrace\u003c/code\u003e에는 함수의 리턴을 트레이싱할 수 있는 특수한 함수가 있는데, 이를 \u003ccode\u003efunctionExitTracer\u003c/code\u003e라 부르기로 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그러면 함수가 호출될 때 다음 작업이 이루어집니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003esomeFunciton\u003c/code\u003e의 stack frame이 구성됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esomeFunction\u003c/code\u003e 위치로 점프합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emcount\u003c/code\u003e가 호출됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emcount\u003c/code\u003e에서는 \u003ccode\u003esomeFunction\u003c/code\u003e의 stack frame을 분석하여 그 리턴 주소인 \u003ccode\u003esomeFunction_ret\u003c/code\u003e을 찾아내어 저장합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emcount\u003c/code\u003e에서는 \u003ccode\u003esomeFunction\u003c/code\u003e의 stack frame에서 리턴 주소를 찾아낸 후, 그것을 \u003ccode\u003efunctionExitTracer\u003c/code\u003e의 주소로 수정합니다. 즉, \u003ccode\u003esomeFunction\u003c/code\u003e이 종료될 때에는 \u003ccode\u003esomeFunction_ret\u003c/code\u003e으로 점프하는 것이 아니라 \u003ccode\u003efunctionExitTracer\u003c/code\u003e로 점프하게 됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esomeFunction\u003c/code\u003e이 종료되고 \u003ccode\u003efunctionExitTracer\u003c/code\u003e로 점프합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efunctionExitTracer\u003c/code\u003e에서 함수 반환 트레이싱 작업을 수행합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efunctionExitTracer\u003c/code\u003e가 리턴될 때에는 앞서 4번 단계에서 저장해두었던 \u003ccode\u003esomeFunction_ret\u003c/code\u003e으로 점프합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이러한 과정을 통하여 함수 반환을 트레이싱할 수 있게 되는 것입니다.\u003c/p\u003e\n\u003ch1\u003etrace-cmd\u003c/h1\u003e\n\u003cp\u003e이제 본격적으로 kernel tracing을 해 보도록 하겠습니다. \u003ccode\u003etrace-cmd\u003c/code\u003e는 \u003ccode\u003eftrace\u003c/code\u003e를 좀 더 편리하게 사용할 수 있도록 만들어 둔 커맨드라인 유틸리티로 \u003ccode\u003esudo apt-get install trace-cmd\u003c/code\u003e 커맨드를 통해 간단히 설치할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e사용법\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003etrace-cmd\u003c/code\u003e는 크게 record, report라는 두 가지 단계를 통해 트레이싱을 수행합니다.\u003c/p\u003e\n\u003cp\u003e먼저 record 단계에서는 \u003ccode\u003eftrace\u003c/code\u003e를 이용하여 트레이싱을 수행하고, 그 내용을 \u003ccode\u003etrace.dat\u003c/code\u003e이라는 파일에 저장합니다. 이 파일에는 \u003ccode\u003eraw\u003c/code\u003e데이터가 들어 있습니다. 아래와 같이 실행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003etrace-cmd record host google.com \u003cspan class=\"hljs-comment\"\u003e# 특정 프로그램을 시작과 동시에 트레이싱\u003c/span\u003e\ntrace-cmd record \u003cspan class=\"hljs-comment\"\u003e# Ctrl+C를 누를 때까지 트레이싱\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 report 단계에서는 \u003ccode\u003etrace.dat\u003c/code\u003e파일을 읽어서 그 내용을 예쁘게 출력해줍니다. 아래와 같이 실행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etrace-cmd report\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e물론 \u003ccode\u003etrace-cmd\u003c/code\u003e는 이 두 가지 말고도 다양한 모드를 지원합니다. \u003ca href=\"https://man7.org/linux/man-pages/man1/trace-cmd.1.html\"\u003etrace-cmd man page\u003c/a\u003e를 읽어보시면 모든 기능이 상세히 설명되어 있습니다. 그리고 \u003ccode\u003etrace-cmd\u003c/code\u003e의 record 역시 다양한 옵션을 제공합니다. 이 옵션들 역시 \u003ca href=\"https://man7.org/linux/man-pages/man1/trace-cmd-record.1.html\"\u003etrace-cmd-record man page\u003c/a\u003e를 읽어보시면 상세히 설명되어있습니다. 그래서 이 글에서는 몇 가지 유용한 옵션만을 설명하고자 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e-p\u003c/code\u003e : 어떤 트레이서를 사용할지 설정합니다. \u003ccode\u003efunction\u003c/code\u003e 트레이서는 이 옵션을 주지 않을 때 선택되는 기본 트레이서로, 모든 function call을 트레이싱합니다. \u003ccode\u003efunction_graph\u003c/code\u003e는 function call 및 function exit을 트레이싱하여 보여줍니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e-F\u003c/code\u003e : \u003ccode\u003etrace-cmd\u003c/code\u003e는 기본적으로 모든 CPU의 모든 프로세스를 트레이싱합니다. 그러므로 실제로 트레이싱된 결과를 보면 온갖 프로세스가 섞여있을 뿐만 아니라, 문맥 교환 관련 호출들도 다 트레이싱됩니다. 이는 문맥 교환 등을 고려할 때에는 좋은 방법이겠지만, 한 프로세스의 동작을 보기에는 적합하지 않습니다. \u003ccode\u003e-F\u003c/code\u003e 옵션을 주면 특정 프로그램을 인자로 줘서 트레이싱할 때, 오직 그 프로세스만을 트레이싱합니다. (아무 프로그램도 인자로 주지 않고 실행할 때에는 사용할 수 없습니다.)\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e-P\u003c/code\u003e : \u003ccode\u003e-F\u003c/code\u003e와 유사한데, 인자로 주어진 프로그램이 아니라 특정 PID를 가진 프로세스를 트레이싱합니다. 이미 실행 중인 프로세스를 트레이싱하고 싶을 때 유용합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e-c\u003c/code\u003e : 특정 프로세스를 트레이싱할 때 그 자식 프로세스까지 함께 트레이싱합니다. \u003ccode\u003e-P\u003c/code\u003e나 \u003ccode\u003e-F\u003c/code\u003e 옵션과 함께 사용할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e예시\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003etrace-cmd\u003c/code\u003e를 사용하여 \u003ccode\u003ehost google.com\u003c/code\u003e 를 실행하고, 트레이싱해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e~$ sudo trace-cmd record -F -p function_graph host google.com\n  plugin 'function_graph'\ngoogle.com has address 142.250.206.238\ngoogle.com has IPv6 address 2404:6800:400a:804::200e\ngoogle.com mail is handled by 40 alt3.aspmx.l.google.com.\ngoogle.com mail is handled by 20 alt1.aspmx.l.google.com.\ngoogle.com mail is handled by 30 alt2.aspmx.l.google.com.\ngoogle.com mail is handled by 50 alt4.aspmx.l.google.com.\ngoogle.com mail is handled by 10 aspmx.l.google.com.\nCPU 1: 13674 events lost\nCPU0 data recorded at offset=0x644000\n    3977216 bytes in size\nCPU1 data recorded at offset=0xa0f000\n    6316032 bytes in size\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 트레이싱 된 결과를 확인해보겠습니다. 그냥 \u003ccode\u003ereport\u003c/code\u003e를 수행하면 내용이 너무 길어서 보기 힘들기 때문에, 결과를 파일에 쓰도록 하겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e~$ sudo trace-cmd report \u0026gt; trace.txt\n~$ ls -al --block-size k\ntotal 63316K\n...\n-rw-r--r-- 1 root       root       16468K May 29 10:20 trace.dat\n-rw-rw-r-- 1 unknownpgr unknownpgr 22707K May 29 10:23 trace.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e1.6M짜리 raw 파일과 2.2M짜리 report 파일을 얻었습니다. 이 파일을 살펴보면 프로그램이 커널 내에서 어떻게 동작하는지 알 수 있습니다. 예를 들어, 아래와 같은 소켓 생성 부분을 찾을 수 있었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e           |  do_syscall_64() {\n           |    __x64_sys_socket() {\n           |      __sys_socket() {\n           |        __sock_create() {\n           |          security_socket_create() {\n           |            apparmor_socket_create() {\n           |              _cond_resched() {\n0.255 us   |                rcu_all_qs();\n0.709 us   |              }\n1.335 us   |            }\n2.130 us   |          }\n           |          sock_alloc() {\n           |            new_inode_pseudo() {\n           |              alloc_inode() {\n           |                sock_alloc_inode() {\n           |                  kmem_cache_alloc() {\n           |                    _cond_resched() {\n0.225 us   |                      rcu_all_qs();\n0.712 us   |                    }\n0.251 us   |                    should_failslab();\n0.803 us   |                    memcg_kmem_get_cache();\n0.348 us   |                    memcg_kmem_put_cache();\n3.821 us   |                  }\n0.240 us   |                  __init_waitqueue_head();\n5.003 us   |                }\n           |                inode_init_always() {\n           |                  make_kuid() {\n0.330 us   |                    map_id_range_down();\n0.867 us   |                  }\n           |                  make_kgid() {\n0.236 us   |                    map_id_range_down();\n0.686 us   |                  }\n0.495 us   |                  security_inode_alloc();\n0.240 us   |                  __init_rwsem();\n4.147 us   |                }\n10.211 us  |              }\n0.248 us   |              _raw_spin_lock();\n11.224 us  |            }\n0.240 us   |            get_next_ino();\n12.585 us  |          }\n0.255 us   |          try_module_get();\n           |          inet_create() {\n           |            sk_alloc() {\n           |              sk_prot_alloc() {\n           |                kmem_cache_alloc() {\n           |                  _cond_resched() {\n0.225 us   |                    rcu_all_qs();\n0.682 us   |                  }\n0.225 us   |                  should_failslab();\n0.870 us   |                  memcg_kmem_get_cache();\n0.225 us   |                  memcg_kmem_put_cache();\n3.476 us   |                }\n0.225 us   |                page_poisoning_enabled();\n           |                security_sk_alloc() {\n           |                  __kmalloc() {\n0.233 us   |                    kmalloc_slab();\n           |                    _cond_resched() {\n0.221 us   |                      rcu_all_qs();\n0.743 us   |                    }\n0.225 us   |                    should_failslab();\n0.232 us   |                    memcg_kmem_put_cache();\n3.454 us   |                  }\n3.945 us   |                }\n0.225 us   |                try_module_get();\n9.709 us   |              }\n0.225 us   |              __init_waitqueue_head();\n0.237 us   |              mem_cgroup_sk_alloc();\n0.240 us   |              cgroup_sk_alloc();\n12.446 us  |            }\n           |            sock_init_data() {\n0.237 us   |              init_timer_key();\n0.885 us   |            }\n           |            tcp_v4_init_sock() {\n           |              tcp_init_sock() {\n           |                tcp_init_xmit_timers() {\n           |                  inet_csk_init_xmit_timers() {\n0.225 us   |                    init_timer_key();\n0.248 us   |                    init_timer_key();\n0.225 us   |                    init_timer_key();\n1.639 us   |                  }\n           |                  hrtimer_init() {\n0.342 us   |                    __hrtimer_init();\n0.810 us   |                  }\n           |                  hrtimer_init() {\n0.232 us   |                    __hrtimer_init();\n0.686 us   |                  }\n4.136 us   |                }\n0.228 us   |                jiffies_to_usecs();\n           |                tcp_assign_congestion_control() {\n0.228 us   |                  try_module_get();\n1.005 us   |                }\n6.896 us   |              }\n7.567 us   |            }\n0.450 us   |            __cgroup_bpf_run_filter_sk();\n23.693 us  |          }\n0.252 us   |          try_module_get();\n0.266 us   |          module_put();\n           |          security_socket_post_create() {\n0.566 us   |            apparmor_socket_post_create();\n1.268 us   |          }\n43.083 us  |        }\n           |        get_unused_fd_flags() {\n           |          __alloc_fd() {\n0.372 us   |            _raw_spin_lock();\n0.371 us   |            expand_files();\n1.785 us   |          }\n2.314 us   |        }\n           |        sock_alloc_file() {\n           |          alloc_file_pseudo() {\n           |            d_alloc_pseudo() {\n           |              __d_alloc() {\n           |                kmem_cache_alloc() {\n           |                  _cond_resched() {\n0.229 us   |                    rcu_all_qs();\n0.675 us   |                  }\n0.221 us   |                  should_failslab();\n0.742 us   |                  memcg_kmem_get_cache();\n0.307 us   |                  memcg_kmem_put_cache();\n3.341 us   |                }\n0.394 us   |                d_set_d_op();\n4.789 us   |              }\n5.464 us   |            }\n0.330 us   |            mntget();\n           |            d_instantiate() {\n0.341 us   |              security_d_instantiate();\n0.251 us   |              _raw_spin_lock();\n           |              __d_instantiate() {\n0.330 us   |                d_flags_for_inode();\n0.244 us   |                _raw_spin_lock();\n1.357 us   |              }\n3.018 us   |            }\n           |            alloc_file() {\n           |              alloc_empty_file() {\n           |                __alloc_file() {\n           |                  kmem_cache_alloc() {\n           |                    _cond_resched() {\n0.236 us   |                      rcu_all_qs();\n1.174 us   |                    }\n0.221 us   |                    should_failslab();\n0.799 us   |                    memcg_kmem_get_cache();\n0.225 us   |                    memcg_kmem_put_cache();\n3.870 us   |                  }\n           |                  security_file_alloc() {\n           |                    kmem_cache_alloc() {\n           |                      _cond_resched() {\n0.225 us   |                        rcu_all_qs();\n0.660 us   |                      }\n0.217 us   |                      should_failslab();\n0.319 us   |                      memcg_kmem_put_cache();\n2.423 us   |                    }\n           |                    apparmor_file_alloc_security() {\n           |                      _cond_resched() {\n0.225 us   |                        rcu_all_qs();\n0.690 us   |                      }\n1.173 us   |                    }\n4.388 us   |                  }\n0.222 us   |                  __mutex_init();\n9.401 us   |                }\n10.335 us  |              }\n11.119 us  |            }\n21.465 us  |          }\n22.151 us  |        }\n           |        fd_install() {\n0.293 us   |          __fd_install();\n0.727 us   |        }\n69.727 us  |      }\n70.260 us  |    }\n0.229 us   |    fpregs_assert_state_consistent();\n71.509 us  |  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 포스팅에서는 리눅스 커널 트레이싱 도구인 \u003ccode\u003etrace-cmd\u003c/code\u003e의 작동 원리를 살펴보고, 커맨드라인 유틸리티인 \u003ccode\u003etrace-cmd\u003c/code\u003e를 통해 실제로 프로세스의 커널 트레이싱을 수행해봤습니다. 재밌네요. 오늘도 리눅스 커널에 대한 이해가 깊어졌습니다. ㅎㅎ\u003c/p\u003e\n\u003cp\u003e다음에는 이를 이용하여 저번에 작성했던 \u003ca href=\"/posts/internal-steps\"\u003e웹브라우저에서 검색할 때 어떤 일이 벌어지나?\u003c/a\u003e 글을 좀 더 자세하게 업데이트해볼까 합니다.\u003c/p\u003e\n\u003ch2\u003eTMI\u003c/h2\u003e\n\u003cp\u003e자료조사 하다 보니 폭발해버린 탭들....\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/imgs/42706f6947759e028597d926397736b9.png\" alt=\"image-20210529195650458\"\u003e\u003c/p\u003e\n","imageMapping":{"imgs/Free_Linux_Tutorials.png":"/imgs/dc98064e8bc40d83d91362d4ce1dd9d3.png","imgs/image-20210529195650458.png":"/imgs/42706f6947759e028597d926397736b9.png"},"name":"2021-05-29-kernel-trace"},"postsInSameCategory":[{"name":"2021-06-18-ip-assign","title":"공인 IP 주소는 어떻게 할당되는가?","date":"2021-06-18T18:49:15.638Z","category":"computer structure"},{"name":"2021-05-29-kernel-trace","title":"trace-cmd 및 ftrace 이해하기","date":"2021-05-29T10:56:39.790Z","category":"computer structure"},{"name":"2021-05-27-timer","title":"ARM 타이머 이해하기","date":"2021-05-27T16:41:32.103Z","category":"computer structure"},{"name":"2020-12-25-internal-steps","title":"웹브라우저에서 검색할 때 어떤 일이 벌어지나?","date":"2020-12-25T04:30:59.671Z","category":"computer structure"}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2021-05-29-kernel-trace"},"buildId":"GEhWU355MLMK38xGjJhyZ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>